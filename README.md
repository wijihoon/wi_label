## CS 관련 지식

### 네트워크

### OSI 7계층

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ Application(응용) 계층 : __최종 목적지로 응용 프로그램과 연관하여 서비스를 수행하는 계층__
    - ex) HTTP, FTP, DNS
+ Presentation(표현) 계층 : __데이터 압축, 변환이 이뤄지는 계층__
    - ex) JPEG, MPEG
+ Session(세션) 계층 : __데이터가 통신하기 위한 논리적 연결을 담당하는 계층__
    - ex) API, Socket
+ Transport(전송) 계층 : __종단 간의 사용자들에게 신뢰성 있는 데이터를 전달하는 계층__
    - 흐름 제어 : 송신측과 수신측 사이의 데이터 처리 속도 차이를 제어
    - 혼잡 제어 : 네트워크 혼잡을 피하기 위해 데이터의 전송 속도 제어
    - 오류 제어 : 오류 검출과 재전송
+ Network(네트워크) 계층 : __IP를 지정하고 라우터로 경로를 선택해 네트워크를 통해 패킷을 전달하는 계층__    
+ Data Link(데이터링크) 계층 : __신뢰성 있는 전송을 보장하기 위한 계층__
    - 오류 제어, 흐름 제어, 회선 제어
+ Physical(물리) 계층 : __전기적, 물리적 세부 사항을 정의하는 계층__

전송계층은 논리적으로 1:1 연결된 송신과 수신 호스트 즉, 종단간의 호스트에 신뢰성 관련 기능을 제공하고, 데이터 링크 계층은 물리적으로 1:1 연결된 호스트 사이의 전송 즉, 직접 묶여있는 호스트-노드 또는 노드-노드 사이에서의 신뢰성 관련 기능을 제공한다.  

계층을 나눈 이유 : 통신이 일어나는 과정을 단계별로 알 수 있고, 문제가 생기면 그 단계만 수정하면 된다.  

Application Layer : HTTPS 프로토콜을 사용하여 데이터를 감싸고 Transport Layer로 내린다.
Transport Layer : TCP인지 UDP인지에 대한 정보, 출발지와 도착지에 대한 포트정보를 헤더에 넣고 캡슐화한다. 이 결과물을 세그먼트 라고 한다.
Network Layer : 출발지와 도착지에 대한 IP정보를 헤더로 만들어 붙인다. 이 결과물을 패킷 이라고 한다.
Data Link Layer : 출발지의 Mac 주소와 가장 가까운 라우터의 맥주소를 붙인다. 이 결과물을 Frame 이라고 한다.
도착지에 대한 맥주소를 넣지 않는 이유는 출발지는 처음에 도착지에 대한 맥주소를 알지 못한다.
DHCP와 ARP()를 통해서 라우터의 IP를 받고 맥주소로 변환한 후에 헤더에 넣는다.
앞쪽에 Trailer가 붙게 되는데 이건 오류제어를 위한 정보가 담긴다.
Physical Layer : 전기신호로 변환하여 전송한다.


</details>

-----------------------

<br>


### 전송 계층

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ TCP 패킷 추적 관리
    - 데이터는 패킷 단위로 쪼개져 같은 목적지로 전송된다.
    - 따라서 패킷에 각각 번호를 부여하여 패킷의 분실 확인 처리를 하기 위해 목적지에서 패킷을 재조립한다.
+ 흐름제어
    - 송신측과 수신측 사이의 데이터 처리 속도 차이를 제어하기 위한 기법으로 송신측의 데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지한다.
    - 슬라이딩 윈도우를 사용한다.
        - 송신 측에서 0,1,2,3,4,5,6을 보낼 수 있는 프레임을 가지고 있고 0,1을 전송했다면 슬라이딩 윈도우 구조는 2,3,4,5,6으로 변한다. 
        - 수신측에서 ACK를 보내게 되면 송신측은 이전에 보낸 데이터 0,1을 수신측에서 정상적으로 받았음을 알게 되고 ACK 개수 만큼 프레임의 수를 오른쪽으로 확장한다.
+ 오류제어
    - 프레임이 손상되었거나 손실되었을 경우, 재전송을 통해 오류를 복구한다.
    - 2가지 방식
        - Stop and Wait ARQ
            - 수신측에서 ACK 또는 NAK을 보낸다.
            - 수신측에서 받지 못한 경우 NAK를 보내고 송신측은 해당 데이터를 재전송한다.
            - 만약 분실된 경우 일정 간격의 시간을 두고 타임이웃이 되면 송신측에서 데이터를 재전송한다.
        - Go-Back-n ARQ
            - 손상되거나 분실된 경우 확인된 마지막 프레임 이후로 모든 프레임을 재전송한다.
            - 예를 들어 수신측에서 1, 3을 받게 되면 3을 버리고 2를 받지 못했다고 송신측에 보내고 송신측은 2부터 데이터를 다시 보낸다.
        - SR ARQ
            - Go-Back-n을 보완한 방법으로 손실된 프레임만 재전송한다.
            - 별도의 데이터 재정렬을 수행해야 하며, 별도의 버퍼를 필요로 한다.
+ 혼잡제어
    - 네트워크 혼잡을 피하기 위해 송신측에서 보내는 데이터의 전송 속도를 제어하는 것
    - AIMD 방식
        - 처음 패킷 하나를 보내 문제가 없다면 Window Size를 1씩 증가시키는 방식
        - 문제가 발생하면 Window Size를 절반으로 줄인다.
        - 초기에 높은 대역폭을 사용하지 못하여 오랜 시간이 걸리고 네트워크가 혼잡해지는 상황을 미리 감지하지 못한다.
    - Slow Start 방식
        - 처음 패킷을 하나씩 보내는 것은 같지만 매 전송마다 2배씩 증가하여 데이터의 크기가 지수함수적으로 증가한다.
        - 전송되는 데이터의 크기가 임계값에 도달하면 혼잡 회피 단계로 넘어간다.
        - 혼잡 현상이 발생하면 Window size를 1로 줄인다.
        - 혼잡 현상이 발생했던 Window Size 절반 까지는 지수함수 꼴로 증가하고 이후부터는 1씩 증가한다.
    - Fast recovery 빠른 회복 방식
        - 혼잡 시 1로 줄이지 않고 절반으로 줄이고 선형 증가
    - 혼잡 회피
        - 임계값을 넘어가면 1씩만 선형적으로 증가

</details>

-----------------------

<br>


## DNS란

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ IP주소를 기억하기 쉬운 도메인으로 바꾸거나 도메인을 다시 IP주소로 바꾸어주는 데이터베이스 시스템
+ 연결되어있는 IP주소와 도메인이 저장된 곳이 DNS
+ 각 도메인들마다 DNS와 연결해주는 서버 역할을 하는 DNS 서버, 다른 말로 네임서버가 있다.

</details>

-----------------------

<br>



### www.google.com에 접속할 때 일어나는 일

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

1. www.google.com을 브라우저 주소창에 입력한다.
2. 브라우저는 캐싱된 DNS 기록을 통해 www.google.com에 대응되는 IP 주소가 있는지 확인한다.
    + 브라우저 캐시 확인
    + OS 캐시 확인
    + 라우터 캐시 확인
    + ISP 캐시 확인
3. 요청한 URL이 캐시에 없으면 ISP(인터넷 서비스 제공자, kt 등)의 DNS 서버가 www.google.com을 호스팅하고 있는 서버의 IP 주소를 찾기 위해 DNS query를 날려서 찾는다.
4. 브라우저는 IP주소를 받아 서버와 TCP 연결을 한다. (3 way handshaking)
    + 클라이언트가 서버로 접속 요청 SYN 패킷을 보낸다.
    + 서버에서는 수락하는 ACK와 SYN 패킷을 보낸다.
    + 클라이언트는 서버에게 확인 응답으로 ACK 패킷을 보낸다.
5. TCP 연결이 완료되면 브라우저가 웹 서버에 HTTP 요청을 보낸다.
6. 서버는 요청을 처리하고 response를 생성하고 보낸다.
7. 브라우저가 HTML content를 사용자에게 보여준다.

서버단에서 클라이언트 단으로 index.html을 응답으로 보내게 되는데 여기 안에는 구글의 이미지 google.png가 들어있다.  
웹 브라우저는 html파일을 읽어서 해석하는데 이미지 주소가 나오면 다시 해당 url로 서버에 요청을 보내고 위와 같은 요청을 반복한다.  

</details>

-----------------------

<br>



### 4 way-hand shaking

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

HTTP 요청과 응답 과정이 끝나면 연결과정을 종료하는 4-way-handshaking이 진행된다.
1. 클라이언트가 서버로 연결을 종료하겠다는 FIN 패킷 전송
2. 서버는 클라이언트에게 우선적으로 ACK 패킷 전송
3. 서버는 자신의 통신의 끝날 때까지 기다리고 끝나면 클라이언트에게 FIN 패킷 전송
4. 클라이언트는 확인했다는 의미로 ACK 패킷을 서버에게 전송
5. 서버가 보내는 FIN보다 서버가 보내는 데이터가 늦게 보내질 경우를 대비해 클라이언트는 일정 시간 동안 소켓을 닫지 않고 잉여 패킷을 기다림(time wait)
6. 이후에 연결 종료

</details>

-----------------------

<br>



### TCP의 연결 과정에서 3way와 4way가 단계 차이가 나는 이유

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

Client가 데이터 전송을 마쳤다고 하더라도 Server는 아직 보낼 데이터가 남아있을 수 있기 때문에 일단 ACK만 먼저 보내고, 데이터를 모두 전송한 후에 자신도 FIN 메시지를 보내기 때문이다.  

</details>

-----------------------

<br>


### Server에서 FIN 플래그를 전송하기 전에 전송한 패킷이 Routing 지연이나 패킷 유실로 인한 재전송 등으로 인해 FIN 패킷보다 늦게 도작한 상황이 발생하면?

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

이러한 현상을 대비하여 Client는 Server로부터 FIN 플래그를 수신하더라도 일정기간 time wait동안 세션을 남겨 놓고 잉여 패킷을 기다리는 과정을 거친다.  

</details>

-----------------------

<br>

### 초기 Sequence Number인 ISM을 0부터 시작하지 않고 난수를 생성해서 설정하는 이유

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

__커넥션을 맺을 때 사용하는 포트는 시간이 지남에 따라 재사용된다.__ 따라서 두 통신이 과거에 사용된 포트 번호 쌍을 사용할 가능성이 생기고 난수가 아닌 순차적 Number가 전송된다면 이전의 커넥션으로부터 오는 패킷으로 인식할 가능성이 생긴다.  

</details>

-----------------------

<br>



### 포트와 소켓

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ 포트
    - __네트워크를 통해 데이터를 주고받는 프로세스를 식별하기 위해 호스트 내부적으로 프로세스가 할당받는 고유한 값__
    - 하나의 IP 주소 내에 개별적으로 부여된 통신 프로세스
+ 소켓
    -  __네트워크상에서 동작하는 프로그램 간 통신의 종착점(Endpoint)__
    - __두 시스템 사이의 네트워크 연결을 나타내는 객체__
    - 소켓을 열기 위해선 호스트에 할당된 IP, 포트 번호, 프로토콜이 필요하다.
    - 위 세가지가 소켓을 정의할 수 있지만 유일하게 식별하지는 않는다.
    - 보내는 쪽과 받는 쪽 모두 소켓을 열어야 한다.
    - 하나의 프로세스가 같은 포트를 갖고 여러 개의 소켓을 열 수 있다.

</details>

-----------------------

<br>

### CIDR(사이더)

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

사이더(Classless inter-Domain Routing, CIDR)는 직역 그대로 __클래스없는 도메인간 라우팅 기법__ 이다.  
__기존 IP 주소 할당 방식이었던 클래스를 대체하며 IP주소의 네트워크 영역, 호스트영역을 유연하게 나누어준다.__  
서브넷 마스크는 /를 사용해서 명시한다.  

</details>

-----------------------

<br>

### 서브넷

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ Subnetting 
    - 기본의 class로 분리하는 IP 주소 체계에서, __네트워크 부분과 호스트 부분으로 IP영역대를 분리하는 것__
    - 분할하는 이유는 브로드캐스트에서 성능 저하가 발생하기 때문
    - 네트워크 부분이 같다면 같은 네트워크에 포함되어있는 호스트이고, 네트워크 부분을 서브넷 마스크를 통해 구분한다.
+ Subnet
    - __특정 지역에서 관리되는 IP 영역을 몇 개의 영역으로 나눠서 관리하는 것__
+ 장점
    - 네트워크 브로드캐스트 사이즈를 줄일 수 있다.
        - 브로드캐스트 : IP 네트워크에 있는 모든 로컬 네트워크 호스트로 데이터를 전송하는 방식
    - 효율적으로 관리할 수 있다.
    - 네트워크 분리에 따라 보안성 향상

10.0.0.0/24 로 예를 들면, 앞에 24비트(서브넷마스크) 10.0.0을 네트워크 영역 뒤에 마지막 0을 호스트 영역이라고 한다. 앞의 24비트는 네트워크 영역으로 같다면 같은 네트워크 대역이다. 뒤쪽의 8비트는 호스트 영역 범위인데 해당 10.0.0 네트워크에 호스트 영역으로 2^8개의 범위, 즉 2^8개의 Ip를 범위를 할당한다는 것이다. 여기서 8은 32비트 - 24비트로 나온 것이다.  
여기서 4개의 서브넷으로 쪼갠다고 한다면 마지막 8비트의 맨앞 2자리를 서브넷으로 구분하는데 사용한다. 2자리를 사용하는 이유는 2^n>=4 일때 n는 2가 최소값이기 때문이다. 만약 5개의 서브넷으로 쪼갠다면 앞에 3비트를 써야한다.  
4개의 서브넷으로 쪼갠다면 8비트의 맨앞 2자리가 00, 01, 10, 11로 구분되어 2자리가 서브넷 ID가 되고 나머지 뒤에 6자리가 사용가능한 호스트 ID가 된다.


</details>

-----------------------

<br>

### 캐스트

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ 유니 캐스트 : 특정 대상과 1:1 통신
+ 멀티 캐스트 : 특정 다수와 1:N 통신
+ 브로드 캐스트 : 네트워크에 있는 모든 대상과 통신

</details>

-----------------------

<br>


### MTU(Maximum Transmission Unit)

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

__패킷이나 프레임의 최대 크기__ 로 데이터의 크기가 크다면 단편화해야 한다.

</details>

-----------------------

<br>


### TCP, UDP

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


+ TCP
    - __연결형 서비스를 지원하는 전송계층 프로토콜__
    - 흐름 제어(송수신 측의 데이터 처리 속도차이 해결), 혼잡 제어(송신측의 전달과 네트워크 데이터 처리 속도 해결), 오류 제어(오류 검출과 재전송)를 통해 신뢰성을 보장
    - 인터넷 환경(http)에서 기본으로 사용
    - 초기화(3way-hand-shaking)과 종료(4way-hand-shaking) 필요
    - 전이중, 점대점 방식이다.
        - 전이중 : 전송이 양방향으로 동시에 일어날 수 있다.
        - 점대점 : __각 연결이 정확히 2개의 종단점을 가지고 있다.__
    - __멀티캐스팅이나 브로드캐스팅을 지원하지 않는다.__
+ UDP
    - __비연결성 서비스를 지원하는 전송 프로토콜__
    - __checksum 필드를 통해 최소한의 오류만 검출한다.__
    - __신뢰성이 낮지만 속도가 빠르다.(스트리밍 서비스에 이용)__
    - 전송을 위한 논리적인 경로가 없다.
    - 전송 순서를 보장하지 않음
    - 수신 여부를 확인하지 않음
+ 참고
    - __UDP와 TCP는 각각 별도의 포트 주소 공간을 관리하므로 같은 포트 번호를 사용해도 무방하다.__
    - 즉, 두 프로토콜에서 동일한 포트 번호를 할당해도 서로 다른 포트로 간주한다.
    - Checksum은 헤더와 데이터의 에러 확인 용도로 사용되나 UDP는 에러 복구를 위한 필드가 불필요하기 때문에 TCP 헤더에 비해 간단하다.

</details>

-----------------------

<br>



### HTTP, HTTPS


<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


+ HTTP 프로토콜의 특징
    - 비연결 지향(connectionless) : 클라이언트가 request를 서버에 보내고, 서버가 클라이언트에 요청에 맞는 response를 보내면 바로 연결을 끊는다.
    - 상태 정보 유지 안 함(stateless) : 연결을 끊는 순간 클라이언트와 서버의 통신은 끝나며 상태 정보를 유지하지 않는다.
+ HTTP
    - __www 상에서 정보를 주고받을 수 있는 포로토콜__
    - 클라이언트와 서버 사이에 이루어지는 요청/응답 프로토콜
    - 주로 HTML 문서를 주고 받는데 사용
    - TCP(HTTP/1, HTTP/2), UDP(HTTP/3)를 사용하며, 80번 포트를 사용한다.
+ HTTPS
    - __HTTP의 보안상 문제를 해결하기 위해 등장한 프로토콜__
    - HTTP는 텍스트로 자원을 주고받기 때문에 네트워크를 가로챈다면 내용이 유출되는 보안 이슈가 발생한다.
    - SSL, TLS(SSL의 최신 버전)를 이용해 암호화하여 주고받음
        - 응용 계층 및 전송 계층 사이에 위치
    - 443 포트 사용
    - 모든 HTTP 요청과 응답 데이터는 네트워크로 보내기지 전에 __전송 계층과 응용 계층 사이에서 암호화__ 된다.
    - __HTTP 자체를 암호화하는 것이 아니라 운반하는 HTTP Body 부만 암호화를 진행하고 Header는 암호화하지 않는다.__
    - __암호화 통신 방법 (공개키/개인키, 대칭키 방식을 혼합해서 사용)__
        1. A에서 B로 접속 요청
        2. B에서 공개키를 A에게 전달
        3. A는 자신의 대칭키를 공개키 A로 암호화해서 B에게 전달
        4. B는 개인키로 복호화하여 A의 대칭키를 얻음
        5. 얻어낸 대칭키를 이용하여 A와 B가 암호문을 주고 받음
    - 단점
        - 암호화 추가 비용 발생
        - 암호화 과정에서 웹 서버에 부하
        - 연결이 끊기면 재인증 시간이 소요


</details>

-----------------------

<br>


### HTTP Method

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ GET
    - 조회, 리소스 요청
+ POST
    - 요청된 데이터 처리
    - 자원을 생성
+ PUT
    - 요청된 자원이 없으면 생성
    - 요청된 자원을 새 것으로 전체 갱신
+ PATCH
    - 자원의 일부분만 수정
+ DELETE
    - 요청된 자원 삭제


</details>

-----------------------

<br>


### HTTP 멱등성

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


특정 HTTP 메서드를 여러 번 요청을 했을 경우, 매번 요청 결과가 같다면 해당 메소드를 멱등성 메소드라고 한다.  
GET, PUT, DELETE가 멱등성 메서드에 속하고 POST는 멱등성 메서드가 아니다.  
같은 POST를 연속적으로 보낸다면 명령은 여러 번 내린 것처럼 부가적인 결과를 가져오기 때문이다.(POST 요청을 반복하면 같은 내용이더라도 다른 데이터가 계속 추가된다.)  
GET은 여러 번 수행해도 서버의 상태가 변하지도 않고 같은 결과를 가져온다.  
PUT은 여러 번 수행해도 결과적으로 데이터는 요청한 값으로 수정된 항상 같은 상태이다.  
DELETE도 여러 번 수행해도 이미 존재하든, 존재하지 않든 그 데이터는 DELETE 요청을 보낸 시점에 사라진다.  
<br>

__cf 안전성__  
안전성은 호출해도 리소스를 변경하지 않는 특성으로 서버에 영향을 끼치는 여부로 생각하면 된다.  
GET 메서드만 안전성 메서드다.  


</details>

-----------------------

<br>



### keep-alive 헤더

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


HTTP는 매번 연결을 끊고 새로 생성한다.  
특정 시간까지는 access가 없더라도 기다리고 연결상태를 유지하는 헤더이다.  
HTTP 1.1부터는 defualt로 keep-alive를 지원한다.

</details>

-----------------------

<br>


### HTTP 1.0 vs HTTP 1.1


<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ HTTP 1.0
    - 요청 컨텐츠마다 TCP 커넥션을 맺고 끊음을 반복한다.
    - 요청1 -> 응답1 -> 요청2 -> 응답2 순으로 순차적으로 진행된다. 즉, 응답을 받아야만 다음 작업을 한다.
+ HTTP 1.1
    - 매 요청마다 TCP 커넥션을 맺고 끊음을 반복하지 않고 keep-alive를 통해 일정 시간 동안 커넥션을 유지한다.
    - 클라이언트는 각 요청에 대한 응답을 기다리지 않고 여러개의 요청을 연속적으로 보낸다.(파이프라이닝) 하지만 각 응답의 처리는 순차적으로 처리된다.

__cf) 파이프라이닝__  
![그림1](https://backtony.github.io/assets/img/post/interview/network-1.PNG)  

</details>

-----------------------

<br>


### HTTP/2.0

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ 하나의 커넥션으로 동시에 여러 개의 메세지를 주고 받을 수 있으며, response는 순서에 상관없이 stream으로 주고받는다.
+ 서버는 클라이언트의 요청에 대해 요청하지 않은 리소스를 마음대로 보낼 수 있다.
+ Header의 내용과 중복되는 필드를 재전송하지 않아 데이터를 절약한다.

### Multiplexed Streams
![그림2](https://backtony.github.io/assets/img/post/interview/network-2.PNG)  
HTTP/2.0은 한 커넥션에서 여러개의 메시지를 주고받을 수 있으며, 응답은 순서에 상관없이 stream으로 주고받는다.  
위 그림을 보면 하나의 커넥션에서 여러 병렬 스트림(3개)가 존재한다. Stream이 뒤섞여서 전송될 경우, 수신측에서 stream number을 이용해 재조합한다.  

### Server Push
![그림3](https://backtony.github.io/assets/img/post/interview/network-3.PNG)  
서버는 클라이언트 요청에 대해 요청하지 않은 리소스도 보낼 수 있다.  
HTTP/1.1에서는 HTML문서를 요청하고 받은뒤 그 안에 css,image 파일이 있다면 서버로 재요청했으나, HTTP/2.0에서는 Server Push 기능으로 클라이언트에서 요청하지 않은 (HTML문서에 포함된 리소스) 리소스를 Push 해주는 방법으로 클라이언트의 요청을 최소화하여 성능을 향상시킨다.

### Header Compression
![그림4](https://backtony.github.io/assets/img/post/interview/network-4.PNG)      
Header의 내용과 중복되는 필드를 재전송하지 않도록 하여, 데이터를 절약한다.  
기존에 HTTP Header가 Plain Text(평문)이었지만, HTTP/2에서는 Hash Table과 Huffman Coding을 사용하는 HPACK이라는 Header 압축방식을 이용하여 데이터 전송 효율을 높였다.  

</details>

-----------------------

<br>


### CORS


<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

교차 출처 리소스 공유(Cross-Origin Resource Sharing, CORS)는 추가 HTTP 헤더를 사용하여, 한 출처에서 실행 중인 웹 애플리케이션이 다른 출처의 선택한 자원에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 체제이다.  
웹 애플리케이션은 리소스가 자신의 출처(도메인, 프로토콜, 포트)와 다를 때 교차 출처 HTTP 요청을 실행한다.  
<br>

브라우저는 보안상의 이유로, 스크립트에서 시작한 교차 출처 HTTP 요청을 제한한다.  
예를 들면, domain-a.com <-> domain-b.com 간의 요청은 CORS정책 위반으로, 브라우저에서 요청을 제한한다.  
따라서 다른 출처의 리소스를 불러오기 위해서는, 그 출처에서 교차 출처 리소스 공유에 대한 헤더(CORS)를 응답 시 반환해주어야 한다. 기본적으로는 다음과 같이 동작한다.  
![그림5](https://backtony.github.io/assets/img/post/interview/network-5.PNG)  
1. 실제 요청을 보내기 전에 Preflight라는 예비 요청을 보낸다. 이때 HTTP의 OPTIONS 메서드를 이용해 서버에 보낸다.
2. 서버는 예비 요청이 CORS를 위반하고 있는지를 확인하고 정보를 클라이언트에게 보낸다.
3. Preflight에 대해 서버 응답이 안전하다면 실제 요청을 보낸다.

</details>

-----------------------

<br>


### REST API

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


__REST는 HTTP URI를 통해 자원을 명시하고 HTTP Method를 통해 자원을 처리하도록 설계된 아키텍처이다.__  
REST를 기반으로 만든 API를 REST API라고 한다.  
RESTful은 REST 아키텍처를 구현하는 웹서비스를 나타내는 것으로 REST 원리를 따르는 시스템을 RESTful이라고 한다.  
HATEOAS라는 개념이 있는데, 동적인 API를 제공할 수 있게 된다.  
__모든 관련된 동작__ 을 URI를 통해 알려주어, 클라이언트가 API의 변화에 일일이 대응하지 않아도 된다는 장점이 있다.  
HTTP를 기반으로 동작하다보니 HTTP의 이점을 그대로 가져올 수 있다.(무상태, 캐시처리 등등..)

### REST 하지 않다는 것
+ HTTP Method를 한가지만 사용하고 있다.(Post만 사용하고 있다던가)
+ URL에 동사를 사용하고 있다.(리소스는 명사적 특성을 갖는다.)

정리하면, HTTP의 자원을 제대로 활용하지 않고 있다면 REST하지 않다고 볼 수 있다.

</details>

-----------------------

<br>






### 쿠키, 세션

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


기본적으로 HTTP 프로토콜 환경은 "connectionless, stateless"한 특성을 가지기 때문에 서버는 클라이언트가 누구인지 매번 확인해야 한다.  
이 특성을 보완하기 위해서 쿠키와 세션을 사용한다.

+ 쿠키
    - __클라이언트 로컬에 저장되는 키와 값이 들어있는 작은 데이터 파일__
+ 세션
    - __일정 시간 동안 같은 브라우저로부터 들어오는 일련의 요구를 하나의 상태로 보고 그 상태를 유지하는 것__
+ 세션과 쿠키의 차이점
    - 저장 위치
        - 쿠키는 클라이언트, 세션은 서버
    - 라이프 사이클
        - 쿠키는 만료시간까지 유지, 세션은 브라우저 종료 시 삭제
    - 속도
        - 세션은 정보가 서버에 있기 때문에 처리가 요구되어 쿠키가 더 빠르다.
    - 보안
        - 쿠키는 클라이언트 로컬에 저장되어 취약하지만, 세션은 서버에서 관리해서 비교적 안전
+ 세션보다 주로 쿠키를 사용하는 이유
    - 세션은 서버의 자원을 사용하기 때문에 사용자가 많은수록 소모되는 자원이 상당하기 때문



</details>

-----------------------

<br>



### session의 값을 가져오는 key는 “user”입니다. 사용자 A가 접속해도 “user”로 값을 가져오고, 사용자 B가 접속해도 “user”로 가져오는데 어떻게 A와 B가 접속했을때 서로 다른 결과값을 받을수 있나요?

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

클라이언트가 해당 서버에 접속할 때 서버에는 세션 파일을 하나 생성하고 브라우저에게 JSESSIONID라는 쿠키를 전송한다.  
다음부터는 브라우저는 다른 페이지로 이동할 때마다 JSESSIONID를 서버로 함께 전송한다.  
그럼 서버는 JSESIONID 값을 보고 session을 매칭해서 어떤 사용자인지 체크할 수 있다.  
결국에는 다른 session 객체인 것이다.
</details>

-----------------------

<br>



### 세션은 서버에 저장되고, 쿠키는 클라이언트에 저장된다고 하셨는데, 그럼 쿠키가 안되는 상황에서도 세션은 사용할 수 있나요?

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

쿠키를 사용할 수 없을 때는 url 뒤쪽에 파라미터 값으로 전달하는 경우가 있다.
</details>

-----------------------

<br>




### JWT
<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------
보통 로그인 방식으로는 세션과 쿠기를 통해 구현한다.  
세션에 저장된 정보는 고유 세션ID가 부여되는데 사용자가 로그인을 하면 서버는 쿠키에 세션ID를 실어서 보낸다. 브라우저는 쿠키를 쿠키저장소에 갖고 있다가 다음 페이지를 요청할 때 해당 유저의 쿠키를 다시 요청헤더에 포함해서 전송한다. 서버는 쿠키 내부의 세션ID를 통해 세션 내부에 일치하는 유저 정보를 가져와서 처음에 로그인한 유저가 맞는지 확인하는 작업이 반복되면서 로그인 상태가 유지된다.  
세션은 서버의 메모리 내부에 저장되기 때문에 많아지는 만큼 메모리에 부하가 걸리게 되고, 확장 시 세션을 분산시키는 기술을 따로 설계해야 한다.  
__JWT는 토큰을 만들어 발행하는 방식__ 으로 쿠키에 담거나 HTTP 헤더에 담아서 보낼 수 있다. 따로 서버에서 저장하지 않기 때문에 토큰이 유효한지 검증하는 과정만 있으면 된다.  
하지만 탈취에 의해 악의적으로 사용될 가능성이 있기에 보통 유효시간을 짧게 가져가고 Refresh 토큰을 사용하는 방식으로 구현한다.  
쿠키는 웹브라우저에서 사용할 수 있는 기능이므로 모바일 애플리케이션에서는 JWT를 사용한 인증방식이 최적이다.

</details>

-----------------------

<br>


### OAuth

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

__자신이 소유한 리소스에 소프트웨어 애플리케이션이 접근할 수 있도록 허용해 줌으로써 접근 권한을 위임해주는 개방형 표준 프로토콜__

</details>

-----------------------

<br>



### URI

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

URI는 __인터넷 자원을 식별하기 위한 문자열__ 이다.  
URI는 인터넷 주소 같은 것으로 정보 리소스를 유일하게 식별하고 위치를 지정할 수 있다.  
```
http://test.com/company/location
http://test.com/member/jobhope
```
URI의 하위 개념으로 URL, URN이 있다.  

</details>

-----------------------

<br>





### URL

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

웹에서 자원의 위치를 나타낸다. 즉, 특정 서버의 한 __리소스에 대해 구체적인 위치__ 를 표현한다.
```
safefood.com 서버에서 food폴더 안의 salad.png를 요청하는 URL
>> http://safefood.com/food/salad.png

http://example.com/mypage.html - 실제 사이트 URL
http://img.naver.net/static/www/dl_qr_naver.png - 네이버 앱QR코드의 이미지에 대한 URL
```

</details>

-----------------------

<br>


### URN

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

어떤 리소스가 있을 때 해당 __리소스의 위치에 영향을 받지 않는 고유한 이름__ 역할을 한다.  
만약 backtony.github.io/12 라는 URL를 backtony.github/io/test/12 로 바꿨다면 찾을 수 없게 된다. URL은 주소이지 실제 이름이 아니기 때문에 해당 위치에 있는 리소스를 찾지 못한다.  
따라서 이를 방지하기 위해 객체를 가리키는 실제 객체 이름을 사용하는 방식으로 이렇게 되면 위치가 바뀌더라도 리소스의 위치를 찾을 수 있게 된다.


</details>

-----------------------

<br>



### 중간자 공격

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

두 사람이 서로 통신을 주고 받는데, 중간에 제 3의 인물이 끼여서 데이터를 중계한다면, 이 제3자는 그 내용을 모두 알 수 있고, 데이터를 위/변조할 경우 두 사람에게 서로 잘못된 정보를 전달하게 만들 수도 있다. 중간에서 데이터를 가로채는 것이 중간자 공격이다.  
중간자 공격은 4가지가 있다.
+ 스니핑
    - 시스템 및 네트워크에서 들어오고 나가는 데이터 패킷을 캡쳐한다.
+ 패킷 주입
    - 공격자가 일반 데이터와 함께 악의적인 데이터를 주입한다.
+ 세션 하이재킹
    - 세션 가로채기라고도 불리며 두 시스템 간 연결이 활성화된 상태를 가로채는 것
+ 보안 소켓 계층 스트리핑
    - 공격자는 SSL/TLS 연결을 차단하여 프로토콜 보안성이 있는 HTTPS에서 안전하지 않은 HTTP로 전환한다.

이 공격법을 방어하기 위한 목적으로 만들어진 것이 TLS 통신이다. TLS 통신은 클라이언트가 연결을 요청하면 서버에서 자신의 공개키가 포함된 인증서를 보내고, 클라이언트는 인증서의 내용을 연결 프로그램(웹 브라우저 등) 또는 운영체제에 내장된 루트 인증서 정보와 비교하여 무결성을 검증한 뒤, 인증서에 있는 공개키로 대칭형 암호화 키를 만들 수 있는 난수 정보를 공개키로 암호화해 서버로 보내며, 클라이언트와 서버가 각각 이 난수에서 암호화 키를 만들어내 암호화 연결이 개시된다.


</details>

-----------------------

<br>




### WebSocket과 Socket.io

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ WebSocket
    - 개념
        - 웹 페이지의 한계에서 벗어나 실시간으로 상호작용하는 웹 서비스를 만드는 표준 기술
    - 배경
        - HTTP 프로토콜을 클라이언트에서 서버로의 단방향 통신을 위해 만들어진 방법이다.
        - 실시간 웹을 구현하기 위해서는 양방향 통신이 가능해야 하는데, WebSocket 이전에는 AJAX를 이용해서 구현했고 각 브라우저마다 구현 방법이 달라 개발이 어려웠다.
        - 이를 위해 HTML5 표준의 일부로 WebSocket이 등장했다.
    - 특징
        - 소켓을 이용하여 자유롭게 데이터를 주고 받는다.
        - http 대싱 ws://로 시작하여 streaming과 유사한 방식으로 푸쉬를 지원한다.
        - 브라우저와 마찬가지로 서버에서도 WebSocket을 지원해야 한다.
        - 아직 확정된 상태가 아니라 브라우저별로 지원하는 WebSocket 버전이 다르다.
        - 즉, 시범적 기술로 아직 써볼만한 기술은 아니다.
+ Socket.io
    - 개념
        - 다양한 방식의 실시간 웹 기술을 사용할 수 있는 모듈
        - __WebSocket, FlashSocket, 등 다양한 방법을 하나의 API로 추상화한 것__
        - Socket.io는 JavaScript를 이용하여 브라우저 종류에 상관없이 실시간 웹을 구현할 수 있도록 한 기술
    - 특징
        - 현재 바로 사용할 수 있는 기술
        - WebSocket을 지원하는 여러 서버 구현체가 있지만 socket.io는 Node.js 밖에 없다.
        - 개발자는 socket.io로 개발하고 클라이언트로 푸쉬 메시지를 보내기만 하면, websocket을 지원하지 않는 브라우저의 경우 브라우저 모델과 버전에 따라 다른 방법으로 내부적으로 푸쉬를 보낸다.

__간단하게 정리하면, 실시간으로 상호작용하는 웹 서비스를 만드는 기술은 여러 개가 있고 표준 기술은 WebSocket이다. 아직 시범적인 기술이고, 이런 것들을 추상화 한 것이 Socket.io이다.__  

</details>

-----------------------

<br>    

### gRPC

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ RPC 
    - __프로그램이 네트워크의 세부 정보를 이해하지 않고도 네트워크 안의 다른 컴퓨터에 있는 프로그램에서 서비스를 요청하는 프로토콜__
    - 클라이언트에서 서비스를 요청(function call) 하면 서버에서 서비스를 제공하는 client-server 모델
+ gRPC
    - 구글에서 만든 RPC프레임워크로 protocol buffer와 HTTP2.0 를 사용
        - protocol buffer는 구조화된 데이터를 직렬화하기 위한 구글의 확장 가능한 메커니즘
        - HTTP2.0을 사용함기에 내부적으로 헤더 압축, protobuf로 통신시점에는 바이너리 데이터로 통신하기에 메시지 크기가 작고 양방향 통신이 가능
    - SSL/TLS를 사용하여 서버를 인증하고 클라이언트와 서버간 교환되는 모든 데이터는 암호화
    - __IDL(identity Definition Language)만 정의하면 높은 성능을 보장하는 서비스와 메시지에 대한 소스코드가 각 언어에 맞게 자동으로 생성된다. 따라서 개발자들은 생성된 코드를 클라이언트, 서버 간의 사용 언어에 구애받지 않고 사용하기만 하면 되어 정해진 규약을 공통으로 사용하기 때문에 의사소통 비용이 감소하게 된다.(JSON을 사용하는 HTTP의 경우 공식 표준이 없기 때문에 불필요한 의사소통 시간이 생긴다.)__

</details>

-----------------------

<br>    

<details>
  <summary>TCP와 UDP의 차이점에 대해서 설명해보세요.</summary>
  </br>
  <p>TCP는 연결 지향형 프로토콜이고 UDP는 데이터를 데이터그램단위로 전송하는 프로토콜입니다.</p>
  <p>TCP는 가상 회선을 만들어 신뢰성을 보장하도록(흐름 제어, 혼잡 제어, 오류 제어) 하는 프로토콜로 따로 신뢰성을 보장하기 위한 절차가 없는 UDP에 비해 속도가 느린편입니다.</p>
  <p>TCP는 그래서 파일전송과 같은 신뢰성이 중요한 서비스에 사용되고, UDP는 스트리밍, RTP와 같이 연속성이 더 중요한 서비스에 사용됩니다.</p>
  <p>+) 하지만 UDP도 신뢰성을 UDP자체에서 보장하지 않는 것 뿐이지, 개발자가 직접 신뢰성을 보장하도록 할 수 있습니다. 그래서 HTTP/3은 QUIC이라는 프로토콜을 기반으로 하는데, QUIC은 UDP를 기반으로 합니다. 즉, UDP 자체는 신뢰성을 보장하지 않지만, 추가적인 정의를 통해 신뢰성을 보장받을 수 있습니다.</p>
</details>

<details>
  <summary>TCP 3, 4 way handshake에 대해서 설명해보세요.</summary>
  </br>
  <p>TCP가 가상회선을 만들고 제거하는 과정에 대해서 묻는 질문입니다. TCP를 공부하셨다면 이 정도는 알겠지 하고 묻는 문제고, 실제 면접자리에서는 보통 네트워크에 대해서 설명할 때, 직접 설명하는 편입니다.</p>
  <p>TCP 3way handshake는 가상회선을 수립하는 단계입니다. 클라이언트는 서버에 요청을 전송할 수 있는지, 서버는 클라이언트에게 응답을 전송할 수 있는지 확인하는 과정입니다. SYN, ACK 패킷을 주고받으며, 임의의 난수로 SYN 플래그를 전송하고, ACK 플래그에는 1을 더한값을 전송합니다. 정확한 순서는 SYN(n) -> ACK(n + 1), SYN(m) -> ACK(m + 1) 순으로 일어납니다.</p>
  <p>왜 임의의 난수를 지정하느냐는 꼬리질문이 나올 수 있습니다. 기존 요청과 구분하기 위해서 정도로 알고있고, 그 이상은 생각해본적이 없네요.</p>
  </br>
  <p>TCP 4way handshake는 TCP연결을 해제하는 단계로, 클라이언트는 서버에게 연결해제를 통지하고 서버가 이를 확인하고 클라이언트에게 이를 받았음을 전송해주고 최종적으로 연결이 해제됩니다. 단, 서버에서 소켓이 닫혔다고 통지해도 클라이언트 측에서는 일정시간 대기하는데, 혹시나 패킷이 나중에 도착할 수 있기 때문입니다.</p>
</details>

<details>
  <summary>HTTP와 HTTPS의 차이점에 대해서 설명해보세요.</summary>
  </br>
  <p>HTTP는 따로 암호화 과정을 거치지 않기 때문에 중간에 패킷을 가로챌 수 있고, 수정할 수 있습니다. 따라서 보안이 취약해짐을 알 수 있습니다. 이를 보완하기 위해 나온 것이 HTTPS입니다. 중간에 암호화 계층을 거쳐서 패킷을 암호화합니다.</p>
</details>

<details>
  <summary>HTTPS에 대해서 설명하고 SSL Handshake에 대해서 설명해보세요.</summary>
  </br>
  <p>HTTPS는 HTTP에 보안 계층을 추가한 것입니다. HTTPS는 제3자 인증, 공개키 암호화, 비밀키 암호화를 사용합니다.</p>
  <p>제3자 인증은 믿을 수 있는 인증기관에 등록된 인증서만 신뢰하는 것이고, 공개키 암호화는 비밀키를 공유하기 위해 사용합니다. 비밀키 암호화는 통신하는 데이터를 암호화하는데 사용합니다.</p>
  <p>클라이언트는 TCP 3way handshake를 수행한 이후 Client Hello를 전송합니다. 서버는 인증서를 보냅니다.(다른 정보들도 전송하나 검색을 통해 알 수 있는 부분입니다. 대개 그 정도까지는 요구하지 않습니다.)</p>
  <p>클라이언트는 받은 인증서를 신뢰하기 위해서 등록된 인증기관인지 확인합니다. 이 인증서는 인증기관의 개인키로 암호화되어있고, 공개키로 검증할 수 있습니다.(브라우저에 내장되어있음) 클라이언트는 사이트의 정보와, 서버의 공개키를 얻을 수 있습니다.</p>
  <p>서버의 공개키로 통신에 사용할 비밀키를 암호화해서 서버에 보냅니다. 서버는 이를 개인키로 확인하고 이후 통신은 공유된 비밀키로 암호화되어 통신합니다.</p>
  <p>제3자 인증: 인증서, 인증기관/공개키 암호화: 인증서, 비밀키 공유/비밀키 암호화: 통신과정</p>
  <p>왜 공개키 암호화와 비밀키 암호화를 복합적으로 사용했는지도 질문을 받았습니다.</p>
</details>

<details>
  <summary>GET과 POST의 차이점에 대해서 설명해보세요.</summary>
  </br>
  <p>대개의 경우 아래의 HTTP 메서드 질문을 더 많이합니다. 하지만 둘의 차이만을 물을 수도 있습니다.</p>
  <p>GET요청은 서버에 존재하는 정보를 요청합니다. 이 때 반환되는 정보는 정보 자체가 아니라 정보의 표현입니다.(뒤의 내용은 REST와 연관이 있고, 굳이 답변하지 않으셔도 됩니다.) 일반적으로 Request Body는 입력하지 않는 것이 일반적이며, 레거시 시스템의 경우 요청을 받아들이지 않을 수 있습니다. 캐싱을 수행하기 때문에 캐싱되지 않는 요청은 GET 요청이 맞지 않을 수 있습니다.</p>
  <p>POST요청은 서버에 정보를 생성하는 것을 요청합니다. 예전 HTTP 통신은 POST 요청으로 데이터 삭제, 수정도 form요청으로 같이 수행했습니다. POST 요청은 서버의 상태를 변경시키기 때문에 멱등성이 유지되지 않습니다. 보통 Request Body에 요청하는 데이터를 담아 전송합니다.</p>
</details>

<details>
  <summary>HTTP 메서드와 이것이 하는 역할에 대해서 설명해보세요.</summary>
  </br>
  <p>보통 REST API를 설계했다면 이해할 수 있을정도로 설명하면 되는 것 같습니다.</p>
  <p>OPTIONS, HEAD, TRACE의 존재에 대해서는 알아만 둡시다. 특히 TRACE는 몰라도 되는 것 같습니다. OPTIONS는 해당 uri에 대해 서버가 허용하는 메서드를 확인할 때 사용합니다. HEAD는 GET과 비슷하나 header만 가져옵니다.</p>
  <ul>
    <li>GET 요청은 서버에 존재하는 데이터를 요청하는 것입니다. CRUD로 따지면 R입니다.</li>
    <li>POST 요청은 서버에 데이터를 생성하는 것을 요청합니다. CRUD로 따지면 C입니다.</li>
    <li>PUT 요청은 서버에 존재하는 데이터를 수정하거나 존재하지 않으면 생성합니다. CRUD로 따지면 C,U입니다.</li>
    <li>DELETE 요청은 서버에 데이터를 제거할 것을 요청합니다. 존재하지 않아도 동일하게 동작합니다. CRUD로 따지면 D입니다.</li>
    <li>PATCH 요청은 서버에 존재하는 데이터를 일부 수정합니다. CRUD로 따지면 U입니다.</li>
  </ul>
  <p>더 나아가서 불필요한 메서드는 허용하지 않고 필요한 메서드만 허용하는 Whitelist 방식으로 관리합시다. 자세한 내용은 HTTP Method 취약점에 대해 검색합시다.</p>
</details>

<details>
  <summary>RESTful이란 무엇이며, 이것에 대해서 아는대로 설명해보세요.(보충필요)</summary>
  </br>
  <p>REST는 굉장히 난해한 개념입니다. 하지만 REST가 무엇인지 대략의 감은 잡아둡시다. REST API를 설계했다면 충분히 물어볼만한 질문입니다.</p>
  <p>HTTP URI를 통해 자원을 표시하고 HTTP Method를 통해 자원에 대한 처리를 표현합니다. 사람이 읽을 수 있는 API라는 것이 특징입니다. HTTP를 사용하기 때문에 HTTP의 특성을 그대로 반영합니다. 또한 별도의 인프라 구축이 필요없습니다.</p>
  <p>단점으로는 명확한 표준이 존재하지 않는다는 점, RESTful을 완전히 만족하는 API를 만들기는 매우 까다롭다는 점(그런 REST API로 괜찮은가 참고), REST API가 분산환경에 적합하지 않다는 점이 있습니다.(멱등성을 보장하기 힘들기 때문)</p>
  <p>HATEOAS라는 개념이 있는데, 동적인 API를 제공할 수 있게됩니다.(모든 관련된 동작을 URI를 통해 알려줍니다.) 즉, 클라이언트가 API의 변화에 일일이 대응하지 않아도 된다는 장점을 가져옵니다.</p>
</details>

<details>
  <summary>CORS란 무엇이며 이것에 대해서 설명해보세요.</summary>
  </br>
  <p>CORS는 웹개발을 하다가 흔히 만날 수 있는 이슈입니다. 대개는 프론트엔드 개발시에 로컬에서 API 서버에 요청을 보낼 때 흔하게 발생합니다.</p>
  <p>서로 다른 도메인간에 자원을 공유하는 것을 뜻합니다. 대부분의 브라우저에서는 이를 기본적으로 차단하며, 서버측에서 헤더를 통해서 사용가능한 자원을 알려줍니다.</p>
  <p>preflight request는 실제 요청을 보내도 안전한지 판단하기 위해 사전에 보내는 요청입니다. OPTIONS 메서드로 요청하며 CORS를 허용하는지 확인합니다. CORS가 허용된 웹서버라면 사용 가능한 리소스를 헤더에 담아 응답합니다.</p>
</details>

<details>
  <summary>웹 서버 소프트웨어(Apache, Nginx)는 OSI 7계층 중 어디서 작동하는지 설명해보세요.</summary>
  ...
</details>

<details>
  <summary>웹 서버 소프트웨어(Apache, Nginx)의 서버 간 라우팅 기능은 OSI 7계층 중 어디서 작동하는지 설명해보세요.</summary>
  ...
</details>

### 운영체제

### 운영체제

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

![그림1](https://backtony.github.io/assets/img/post/interview/os-1.PNG)  
운영체제는 __하드웨어를 관리하고, 응용 프로그램과 하드웨어 사이에서 인터페이스 역할을 하는 시스템 소프트웨어__

cf) 여기서 인터페이스는 서로 다른 두 개의 시스템, 장치 사이에서 정보나 신호를 주고받는 경우의 접점이나 경계면을 의미한다.

</details>

-----------------------

<br>


### 커널

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

기본적으로 소프트웨어가 컴퓨터 시스템에서 수행되기 위해서는 메모리에 그 프로그램이 올라가 있어야 한다.  
하지만 운영체제 전체가 메모리에 올라가게 된다면 메모리 공간에 낭비가 심하다.  
따라서 운영체제 중 항상 필요한 부분만 메모리에 올리게 되는데 그것이 커널이다.  
즉, __커널이란 메모리에 상주하는 운영체제의 핵심 부분__ 이다.

</details>

-----------------------

<br>



### 메모리구조

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

![그림2](https://backtony.github.io/assets/img/post/interview/os-2.PNG)  

+ 코드 영역
    - __실행할 프로그램의 코드가 저장되는 영역으로 텍스트 영역__ 이라고 부른다.
    - CPU는 코드 영역에 __저장된 명령어를 하나씩 가져가서 처리__ 한다.
+ 데이터 영역(static 영역)
    - __전역 변수, 정적 변수가 저장되는 영역__ 이다.
    - 데이터 영역을 프로그램의 시작과 동시에 할당되며, 프로그램이 종료되면 소멸한다.
+ 힙 영역
    - 사용자가 직접 관리할 수 있는 영역으로 사용자에 의해 메모리 공간이 동적으로 할당되고 해제된다.
    - new 로 생성하는 object들이 저장되는 영역이다.
    - __런타임 시 크기__ 가 결정된다.
    - 힙 영역은 메모리의 낮은 주소에서 높은 주소 방향으로 할당된다.
    - __메모리 크기에 제한이 없고 직접 관리해야하며 속도가 스택에 비해 느리다.__
+ 스택 영역
    - __함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역__ 이다.
    - __컴파일 시__ 에 크기가 결정된다.
    - 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸한다.
    - 메모리의 높은 주소에서 낮은 주소의 방향으로 할당된다.
    - __스택 크기가 제한되어 있고 힙에 비해 상대적으로 빠르다.__

</details>

-----------------------

<br>


### 스택과 힙의 차이점

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ 스택 : 함수를 호출할 때 지역변수나 함수의 매개변수를 할당하는 공간
+ 힙 : 런타임 시 생성되는 객체들이 저장되는 공간
+ 두 영역은 같은 물리 메모리 공간을 공유하지만 쓰임새가 다르고 힙은 낮은 주소부터 채워지고 스택은 높은 주소부터 채워지기에 서로의 영역을 누가 침범하느냐에 따라 heap overflow, stack overflow가 발생한다.


</details>

-----------------------

<br>


### 힙영역을 크게 잡으면 안되는 이유


<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

GC의 수행 시간이 너무 오래 걸리게 된다.

</details>

-----------------------

<br>


### 프로세스와 스레드

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ 프로세스
    - __컴퓨터에서 실행중인 프로그램__
    - __각자 고유한 공간과 자원을 할당받는다.__
    - 각각의 code, data, stack, heap 영역을 보유
    - 각각의 영역을 갖기에 동기화 작업이 필요하지 않음
    - 각각의 영역을 갖기에 컨텍스트 스위칭 비용이 크다.
+ 스레드
    - __한 프로세스의 내의 실행 단위__
    - __stack만 고유한 영역을 갖고 나머지 영역은 프로세스 자원을 공유__
    - stack 이외의 영역을 공유하므로 동기화 작업이 필요
    - stack 이외의 영역을 공유하므로 컨텍스트 스위칭 비용이 적음

</details>

-----------------------

<br>


### 프로세스 생성 과정

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

1. PCB가 생성되며 OS가 실행한 프로그램의 코드를 읽어들여 프로세스에 할당된 메모리의 Text 영역에 저장한다.
    - Text segment(혹은 Code segment)는 실행가능한 명령어를 포함하고 있는 메모리 영역이다.
2. 초기화된 전역 변수 및 static 변수를 data 영역에 할당.
3. HEAP과 Stack은 초기 메모리 주소 초기화
4. PCB에 여러 정보가 기록되면 Ready Queue에서 CPU를 할당받기까지 대기한다.

</details>

-----------------------

<br>



### 크롬 탭은 프로세스인지 쓰레드인지

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

크롬은 탭마다 PID를 가지고 있으니 Process이며 각 Tab마다 랜더링 정보나 기타 데이터를 따로 관리한다고 한다.  
그로인해 메모리를 많이 잡아먹기도 하지만 하나의 Tab에 오류가 생겼다고 모든 Tab에 영향을 끼치진 않는다.

</details>

-----------------------

<br>



### 멀티 스레드 vs 멀티 프로세스

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ 멀티 스레드
    - __하나의 프로세스를 여러 개의 스레드로 구성하여 자원을 공유하면서 작업을 수행하는 것__
    - 멀티 프로세스보다 적은 메모리 공간을 차지하고 Context Switching이 빠른 장점이 있지만, 오류로 인해 하나의 스레드가 종료되면 전체 스레드가 종료될 수 있다는 점과 동기화 문제를 가지고 있다.
+ 멀티 프로세스
    - __하나의 프로그램을 여러 개의 프로세스로 구성하여 프로세스가 병렬적으로 작업을 수행하는 것__
    - 하나의 프로세스가 죽더라도 다른 프로세스에 영향을 끼지지 않는다는 장점이 있지만, 멀티 스레드보다 많은 메모리 공간을 차지하는 단점이 있다.


</details>

-----------------------

<br>



### 멀티 프로세스 대신 멀티 스레드를 사용하는 이유

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ 프로그램을 여러 개 키는 것보다 하나의 프로그램 안에서 여러 작업을 해결하는 것이 더욱 효율적이기 때문
+ 컨텍스트 스위칭 시 stack 영역만 초기화하면 되기 때문에 더 빠르다.
+ 프로세스를 생성하여 자원을 할당하는 콜이 줄어들어 자원을 효율적으로 관리할 수 있다.

</details>

-----------------------

<br>


### 스레드마다 스택을 독립적으로 할당하는 이유

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능함을 의미하고 이는 독립적인 실행 흐름이 추가된다는 것을 의미한다.  
즉, __독립적인 실행 흐름을 만들기 위해서 스레드마다 스택을 할당한다.__


</details>

-----------------------

<br>

### 스레드마다 PC 레지스터를 독립적으로 할당하는 이유

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

__PC값은 스레드가 명령어를 어디까지 수행했는지를 나타낸다.__ 스레드는 CPU를 할당받았다가 스케줄러에 의해서 다시 선점당한다. 따라서 명령어가 연속적으로 수행되지 못하기 때문에 이를 기억할 필요가 있어 독립적으로 할당한다.

</details>

-----------------------

<br>

### 컨텍스트 스위칭

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ __여러 프로세스를 처리해야 하는 상황에서 현재 진행중인 Task(프로세스, 스레드)의 상태를 PCB에 저장하고 다음에 진행할 Task의 상태값을 읽어 레지스터에 적재하는 과정__
+ 다음에 실행할 Task의 PCB정보를 읽어 Register에 적재하고 CPU가 이전에 진행했던 과정을 연속적으로 수행한다.
    - register는 CPU내부의 요청을 처리하는 데 필요한 데이터를 일시적으로 저장하는 작은 기억장치
+ __컨텍스트 스위칭을 진행하는 동안 다른 작업을 할 수 없다.__ -> 오버헤드의 원인
    - 오버헤드란 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간, 메모리 등을 의미한다.
    - A 라는 작업 처리에 단순히 10초가 걸리는데 안정성 고려하려 처리했더니 15초가 걸린경우 오버헤드는 5초이다.
+ __한 프로세스의 상태는 그 프로세스의 프로세스 제어 블록(PCB)에 기록되어 있다.__


### 진행 과정
1. CPU가 다른 프로세스로 전환하면 시스템은 프로세스의 상태를 PCB에 저장한다.
2. 대기열에서 다음 프로세스를 선택하고 PCB를 __복원__ 한다.
3. PCB의 __프로그램 카운터(레지스터)__ 가 로드되어 선택한 프로세스에서 실행을 계속한다.

</details>

-----------------------

<br>


### IPC(Inter Process Communication)

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


__프로세스간 통신__ 을 의미하며 프로세스는 커널이 제공하는 IPC 설비를 이용해 프로세스간의 통신을 한다.  
+ 메모리 공유 : 프로세스끼리 특정 공통 메모리 영역을 공유하여 통신
+ 메시지 전달 : 파이프(쉘에서 사용하는 그 파이프), 소켓

</details>

-----------------------

<br>


### 프로세스 종류

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ 자식 프로세스
    - fork로 자식 프로세스를 만든 상태, 부모의 데이터, 힙, 스택, PCB 복사
+ 데몬 프로세스
    - 백그라운드에서 동작하면서 특정한 서비스를 제공하는 프로세스
+ 고아 프로세스
    - 부모 프로세스가 먼저 종료되어 고립된 자식 프로세스
+ 좀비 프로세스
    - 자식 프로세스가 종료되었음에도 불구하고 부모 프로세스로부터 작업 종료에 대한 승인을 받지 못한 프로세스

</details>

-----------------------

<br>


### Deadlock

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


+ __두 개 이상의 프로세스나 스레드가 서로 자원을 기다리면서 무한히 대기하는 상태__
+ 발생 조건
    - 상호 배제
        - 한 자원에 여러 프로세스가 동시에 접근할 수 없다.
    - 점유 대기
        - 하나의 자원을 소유한 상태에서 다른 자원을 기다린다.
    - 비선점
        - 프로세스가 어떤 자원의 사용을 끝낼 때까지 프로세스의 자원을 뺏을 수 없다.
    - 순환 대기
        - 각 프로세스가 순환적으로 다음 프로세스가 요구하는 자원을 갖고 있다.

</details>

-----------------------

<br>


### 교착 상태 해결 방법

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

4가지 발생 조건 중 하나라도 제거하면 교착 상태를 막을 수 있다.  
공유 자원 중 많은 경우에 한 번에 한 프로세스 혹은 스레드만 접근할 수 있기 때문에 상호 배제 조건은 제거하기 어렵다.  
__대부분 교착 상태 방지 알고리즘은 순환 대기가 발생하는 것을 막는데 초점이 맞춰져 있다.__

+ 예방(Prevention)
    - 교착 상태 조건 중 하나를 제거함으로 데드락이 발생하지 않도록 예방하는 방식
    - 자원 낭비가 심하다.
+ 회피(Avoidance)
    - __데드락 발생 가능성을 인정하면서도 적절하게 회피하는 방식__
    - 은행원 알고리즘
        - 프로세스가 자원을 요구할 때 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지를 사전에 검사하는 알고리즘
        - 발생하지 않으면 자원을 할당하고, 발생하면 다른 프로세스가 자원을 해제할 때까지 대기한다.
        - 안전상태: 시스템이 교착상태를 일으키지 않으면서 각 프로세스가 요구한 최대 요구량만큼 필요한 자원을 할당해 줄 수 있는 상태
        - 항상 안전 상태를 유지할 수 있다는 장점이 있으나 최대 자원 요구량을 미리 알아야 하고 항상 불안전 상태를 방지해야 하므로 자원 이용도가 낮다.
+ 탐지(Detection) 및 회복(Recovery)
    - 은행원 알고리즘과 유사하게 시스템의 자원 할당 상태를 갖고 데드락이 발생했는지 여부를 탐색한다.
    - 탐지했다면 데드락을 회복한다.
        - 데드락 상태의 프로세스 모두 중단시키기
        - 프로세스를 하나씩 중단 시킬 때마다 탐지 알고리즘으로 데드락을 탐지하면서 회복시키기
        - 자원 섬점을 통해 해결하기(교착 상태에 있는 프로세스가 점유하고 있는 자원을 선점하여 다른 프로세스에 할당)

</details>

-----------------------

<br>


### 식사하는 철학자 문제(Dining Philosophers)

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

1. 일정 시간 생각한다.
2. 왼쪽 포크가 사용 가능해질 때까지 대기하고 사용가능하다면 집는다.
3. 오른쪽 포크가 사용 가능해질 때까지 대기하고 사용가능하다면 집는다.
4. 양쪽 포크를 잡으면 일정 시간만큼 식사한다.
5. 오른쪽 포크를 내려놓는다.
6. 왼쪽 포크를 내려놓는다.
7. 1번으로 돌아간다.

모두가 왼쪽 포크를 집게되면 모두 오른쪽 포크를 대기하게 되어 기아 상태가 발생한다.

#### 교착상태 조건 성립
+ 상호 배제 : 포크는 한 철학자만 사용할 수 있다.
+ 점유 대기 : 왼쪽 포크를 집은 상태에서 오른쪽 포크를 기다린다.
+ 비선점 : 이미 누군가가 집어든 포크를 강제로 빼앗을 수 없다.
+ 순환 대기 : 모든 철학자들이 오른쪽에 앉은 철학자가 포크를 놓기를 기다린다.

#### 해결책
+ 뮤텍스(화장실이 한개만 있는 식당)
    - 공유된 자원에 하나의 스레드만 접근할 수 있도록 한다.
+ 세마포어(화장실이 여러 개인 식당)
    - 철학자 문제를 예시로 들면 철학자는 5명이니 최대 4명만 접근할 수 있도록 한다.

</details>

-----------------------

<br>



### Critical Section(임계영역)

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

Critical Section은 __동일한 자원에 접근하는 코드 영역__ 을 의미한다.

</details>

-----------------------

<br>


### 임계영역 해결책


<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ 뮤텍스와 세마포어
    - 공유된 자원의 데이터를 여러 스레드(또는 프로세스)가 접근하는 것을 막는 것
+ 차이
    - 뮤텍스
        - __오직 1개만의 스레드(또는 프로세스)만 접근__ 할 수 있다.
        - 1개만 접근 가능하므로 반드시 락을 획득한 프로세스가 락을 해제해야 한다.
    - 세마포어
        - __세마포어 변수만큼의 스레드(또는 프로세스)가 접근__ 할 수 있다.
        - 현재 수행중인 프로세스가 아닌 다른 프로세스가 세마포어를 해제할 수 있다.
    
세마포어와 뮤텍스에 관해서는 [여기](https://worthpreading.tistory.com/90)에서 그림으로 잘 설명해주니 참고하자.  

</details>

-----------------------

<br>



### 경쟁 상태(Race Condition)


<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

두 개 이상의 프로세스가 공통 자원을 병렬적으로 읽거나 쓰는 동작을 할 때, 공용 데이터에 대한 접근 순서에 따라 결과값이 달라지는 상황

</details>

-----------------------

<br>



### 수준 스레드


<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

사용자 수준 스레드와 커널 수준 스레드는 __생성 주체가 누구냐에 따라 구분__ 된다.  

</details>

-----------------------

<br>




### 커널 수준 스레드


<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ __커널이 만들고 관리하는 스레드__
+ 장점 : __커널이 직접 제공해주므로 안정성과 다양한 기능을 제공__
+ 단점 : __유저 모드와 커널 모드의 빈번한 전환으로 성능 저하__
+ 사용자 수준 스레드와 커널 수준 스레드가 __1대1로 매핑__ 한다.  
+ 커널이 직접 스케줄링하고 실행하기 때문에 커널의 관리 지원을 받을 수 있지만, 유저모드와 커널모드의 전환이 빈번하게 이뤄져 성능저하가 발생한다.
+ __동일한 프로세스에서 할당된 여러 개의 스레드들 중 한 스레드가 Block되더라도 다른 스레드들은 실행시킬 수 있다.__  


</details>

-----------------------

<br>



### 사용자 수준 스레드

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


+ __스레드 관련 라이브러리로 구현해 사용하는 스레드__
+ 해당 스레드와 관련된 모든 행위를 사용자 영역에서 하기 때문에, 커널은 사용자 수준 스레드의 존재를 알지 못하고 스레드 교환에 개입하지 않는다.  
+ 사용자 수준 스레드 N개가 커널 수준 스레드 1개에 매핑되므로, __다대일 스레드 매핑__ 이라고 한다.  
+ 장점
    - __커널이 스레드를 모르기 때문에 모드 간의 전환이 없고 성능상 이득__
        - 스케쥴링이나 동기화를 위해 커널을 호출하지 않으므로, 커널 영역으로 전환하는 오버헤드 감소
    - 커널에 독립적으로 스케쥴링이 가능해 모든 운영체제에 적용 가능
    - 커널이 나닌 스레드 라이브러리에서 스레드 스케쥴링을 제어하므로 유연한 스케쥴링 가능
+ 단점
    - __사용자 수준 스레드들중 한 스레드가 블록당하면 모든 사용자 스레드가 블록된다.__
    - 커널이 스레드 관리에 개입하지 않으므로 스레드 간 보호에 커널 보호 방법을 사용할 수 없다.

</details>

-----------------------

<br>




### 사용자 모드와 커널 모드

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

CPU에는 여러 가지 명령어가 있고 이를 실행하는데 CPU도 권한 모드를 갖고 있다.  
+ 사용자 모드
    - __사용자가 접근할 수 있는 영역을 제한적으로 두고, 프로그램 자원에 함부로 침범하지 못하게 하는 모드__
    - 응용 프로그램이 사용
+ 커널 모드
    - __특정 명령어 실행과 원하는 작업 수행을 위한 자원 접근을 가능케 하는 모드__
    - OS가 사용

1. 1~1000 까지 더한다. (사용자 모드)
2. 파일에서 데이터를 가져온다. (커널 모드)
3. 1~1000 까지의 합과 데이터를 더한다. (사용자 모드)

위와 같이 프로세스가 실행되는 동안 프로세스는 수없이 유저모드와 커널모드를 왔다갔다 하면서 실행된다.  
여기서 __시스템 콜__ 이라는 개념이 나오게 되는데, 시스템 콜이란 __프로세스가 운영체제에게 어떤 기능을 사용하게 해달라고 요청할 때 사용하는 방식__ 이다.  
프로세스가 유저모드에서 실행되다가 특별한 요청이 필요할 때 시스템 콜을 이용해 커널에 요청을 하면 커널 모드로 전환된다.  
시스템 콜을 받은 커널이 그 요청에 대한 일을 처리하고 값을 리턴하면 다시 커널 모드에서 유저 모드로 전환된다.  
결과적으로 __두 모드로 권한을 분리함으로 인해 응용 프로그램이 전체 컴퓨터 시스템을 해치지 못하게 한다.__

</details>

-----------------------

<br>


### CPU Scheduling

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

실행 준비가 된 프로세스 중에서 그중 하나를 선택해 CPU를 할당하는 방식을 의미한다.    

</details>

-----------------------

<br>


### 프로세스 스케줄러 종류

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ 단기 스케줄러 : 어떤 프로세스를 실행 시킬지
+ 중기 스케줄러 : 메모리 공간이 부족한 경우 어떤 프로세스를 swap out 할지
+ 장기 스케줄러 : 어떤 프로세스를 ready queue에 보낼지

</details>

-----------------------

<br>


### CPU 성능 척도

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


+ CPU Utilization(이용률) : CPU가 놀지 않고 일한 시간
+ Throughput(처리량) : 단위 시간당 처리량, CPU가 얼마나 많은 일을 했는지
+ Turnaround Time(소요시간, 반환시간) : CPU 사용 시간 + 기다린 시간 (짧을수록 좋다)
+ Waiting Time(대기시간) : 프로세스가 Ready Queue에서 기다린 전체 시간의 합
+ Response Time(응답시간) : 프로세스가 Ready Queue에 들어가서 최초로 CPU 얻기까지 걸린 시간


</details>

-----------------------

<br>


### 선점 방식

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


하나의 프로세스가 다른 프로세스 대신에 CPU를 차지할 수 있다.
+ Round Robin(RR)    
    - __시간 할당량을 매 프로세스에 주고 할당된 시간 안에 완료하지 못한 프로세스는 레디 큐의 맨 뒤에 배치하는 방식__
+ Shortest Remaining Time First (SRTF)
    - __CPU 점유 시간이 가장 짧은 프로세스에 CPU를 먼저 할당하는 빙식__
    - SJF 방식에서 선점 방식만 다르다고 보면 된다.
    - __기아 문제__ 발생
+  Multilevel Feedback Queue(다중 레벨 피드백 큐)
    - 각 단계마다 하나의 큐를 두고, 큐 시간 할당량 내에 처리하지 못하면 다음 큐로 보내는 방식
    - 단계가 커질수록 시간 할당량이 커지는 형태

</details>

-----------------------

<br>

### 비선점 방식

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

하나의 프로세스가 끝나지 않으면 다른 프로세스는 CPU를 차지할 수 없다.
+ First Come First Served(FCFS)
    - 큐에 도착한 순서대로 실행
    - 최악의 경우 오래 걸리는 문제가 가장 먼저 들어옴
+ Shortest Job First (SJF)
    - CPU 점유 시간이 가장 짧은 프로세스에 CPU를 먼저 할당하는 방식
    - __기아 문제__ 발생
+ Highest Response Ratio Next
    - 준비 큐에서 기다리는 프로세스 중 응답비율이 가장 큰것을 먼저 처리하는 방식
    - 서비스 받을 시간이 분모, 대기 시간이 분자에 있어 대기 시간이 큰 경우 우선순위가 높아진다.


</details>

-----------------------

<br>


### 동시성과 병렬성

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ 동시성
    - __동시에 실행되는 것 같이 보이게 하는 것__
    - __싱글 코어에서 멀티스레드를 동작시키기 위한 방식__
+ 병렬성
    - __실제로 동시에 여러 작입이 처리 되는것__
    - 멀티 코어에서 멀티 스레드를 동작시키기 위한 방식
    - 한 번에 여러 스레드를 실행 한다.



</details>

-----------------------

<br>


### 인터럽트

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


인터럽트란 프로그램을 실행하고 있는 도중에 입출력 요청 또는 예외상황을 처리해야 하면 실행하던 프로그램을 멈추고 CPU가 해당 작업을 처리하도록 하는 것을 의미한다.

</details>

-----------------------

<br>


### 시스템 콜


<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

__시스템 콜은 사용자나 응용프로그램이 커널에서 제공하는 기능을 사용하기 위한 인터페이스이다.__  
운영체제는 커널이 제공하는 서비스를 시스템 콜을 이용해 제한함으로써 컴퓨터 자원을 보호한다.

</details>

-----------------------

<br>


### 메모리구조 순서

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

CPU에 가까운 순서대로 레지스터, 캐시, 주기억장시, 보조기억장치 순이다.  
+ 레지스터 : CPU 내에 존재하는 메모리로 빠르고 작다.
+ 캐시 : CPU와 주기억장치 사이에서 중간 저장소 역할을 한다.
+ 주기억장치 : 현재 수행되는 프로그램과 데이터 저장
+ 보조기억장치 : 용량이 크나 느리다.

</details>

-----------------------

<br>



### 메모리 관리

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

각각의 프로세스는 독립된 메모리 공간을 갖고, 운영체제 혹은 다른 프로세스의 메모리 공간에 접근할 수 없는 제한이 걸려있다. 단지, __운영체제__ 만이 운영체제 메모리 영역과 사용자 메모리 영역의 접근에 영향을 받지 않는다. 따라서 메모리에는 적절하게 관리되어 사용되야 한다.  


### 기본 용어
+ Swapping
    - 메모리의 관리를 위해 사용되는 기법
    - __CPU 할당 시간이 끝난 프로세스의 메모리를 보조기억장치(하드웨어)로 내보내고 다른 프로세스의 메모리를 불러들인다.__
+ 단편화
    - 프로세스들이 메모리에 적재되고 제거되는 일이 반복되다보면, __프로세스들이 차지하는 메모리 사이에 사용하지 못할 만큼의 생기는 작은 공간__ 을 의미한다.
    - 외부 단편화
        - __물리 메모리 공간 중 사용하지 못하게 되는 일부분__
        - 물리 메모리(RAM)에서 사이사이 남는 공간을 모두 합치면 충분한 공간이 되는 부분들이 분산되어 있을 때
    - 내부 단편화
        - __프로세스가 사용하는 메모리 공간에 포함되어있는 부분중 남는 부분__
+ 압축
    - 외부 단편화를 해소하기 위해 프로세스가 사용하는 공간들을 한쪽으로 모는 방식  


</details>

-----------------------

<br>  

### 메모리 fit

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ First fit : 메모리의 처음부터 검사해서 크기가 충분한 첫번째 메모리에 할당
+ Next fit : 마지막으로 참조한 메모리 공간에서부터 탐색을 시작해 공간을 찾음
+ Best fit : 모든 메모리 공간을 검사해서 내부 단편화를 최소화하는 공간에 할당
+ Worst fit : 남은 공간 중에 가장 큰 공간에 할당

</details>

-----------------------

<br>  


### 페이징 전략

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

![그림3](https://backtony.github.io/assets/img/post/interview/os-3.PNG)  
+ __프로세스의 주소공간을 동일한 크기의 페이지 단위로 나누고, 메모리는 동일한 크기의 Frame으로 나눠서 물리적 메모리에 불연속적으로 저장하는 방식__
+ 메모리가 불연속적으로 할당되어 있기 때문에 메모리로 가기 전에 각 페이지의 실제 메모리 주소가 저장되어 있는 페이지 테이블에서 물리 주소로 변경되어야 한다.
+ __내부 단편화__ 가 발생한다.


</details>

-----------------------

<br>  

### 세그멘테이션 전략

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

![그림4](https://backtony.github.io/assets/img/post/interview/os-4.PNG)  
+ __프로세스의 주소공간을 서로 크기가 다른 논리적인 블록단위인 세그먼트로 분할하고 메모리에 배치하는 방식__
+ 프로세스는 논리적인 블록단위 세그먼트로 Code, Data, Stack & Heap 으로 나눌 수 있다.
+ 세그멘테이션도 페이징과 유사하게 세그먼트 테이블이 존재하지만, 각각의 세그먼트의 크기가 다르므로 limit 정보가 주어진다.
+ __외부 단편화__ 가 발생한다.

</details>

-----------------------

<br>  


### 가상 메모리

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

가상 메모리는 __프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법__ 이다.  
가상 메모리가 존재하지 않았을 때는, 실행되는 코드의 전부를 물리 메모리에 존재시켜야 했고, 메모리 용량보다 큰 프로그램을 실행시킬 수 없었다.  
가상 메모리 기술 덕분에 물리 메모리 크기에 제약을 받지 않게 되어 동시에 많은 프로그램을 실행할 수 있게 되었다. 이에 따라 __응답시간은 유지되고 CPU이용율과 처리율이 높아졌다.__  
하지만 물리 메모리로 프로그램을 구동하는 것보다는 속도가 느린 단점이 있다.


### 가상 주소 공간
+ 프로세스가 요구하는 메모리 공간을 가상 메모리에서 제공함으로써 현재 직접적으로 필요하지 않은 메모리 공간은 실제 메모리에 올라가지 않도록 한다.
+ 예를 들어, 한 프로그램이 실행되며 논리 메모리 100KB를 요구하지만 실행에 필요한 메모리 공간의 합이 40KB라면, 실제 물리 메모리에는 40KB만 올라가고, 나머지 60KB는 가상 메모리에 존재해 요구 시에 물리 메모리에 올라간다.

### 이점
![그림5](https://backtony.github.io/assets/img/post/interview/os-5.PNG)  
+ __가상 메모리는 시스템 라이브러리가 여러 프로세스들 사이에 공유될 수 있도록 한다.__  
+ __프로세스들이 메모리를 공유하는 것을 가능케 하고, 프로세스들은 공유 메모리를 통해 통신할 수 있다.__  
    - 각 프로세스들은 공유 라이브러리를 자신의 주소 공간에 두고 사용하는 것 처럼 인식하지만, 공유 라이브러리는 실제로는 물리 메모리 영역에 올라가있고 모든 프로세스들에게 공유되고 있다.  

</details>

-----------------------

<br>  


### 요구 페이징(Demand Paging)

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

요구 페이징은 __프로그램 실행 시작 시에 프로그램 전체를 디스크에서 물리 메모리에 적재하는 대신, 초기에 필요한 것들만 적재하는 전략을 의미__ 한다.  
가상 메모리 시스템에서 많이 사용되며, 가상 메모리는 대부분 페이지로 관리된다.  
따라서, 가상 메모리에는 실행과정에서 필요해질 때 페이지들이 적재되고 단 한번도 접근되지 않은 페이지는 물리 메모리로 적재되지 않는다.  


</details>

-----------------------

<br>  


### 페이지 교체

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


요구 페이징에서 언급한 대로 프로그램 실행 시 모든 항목이 물리 메모리에 올라오지 않고, 프로세스 동작에 필요한 페이지만 요청하게 되는데 이때 페이지 부재(page fault)가 발생하게 되면, 원하는 페이지를 보조저장장치(하드웨어)에서 가져오게 된다.  
하지만, 물리 메모리가 모두 사용중이라면, 페이지 교체가 이뤄져야한다.

### 페이지 교체 알고리즘
+ FIFO
    - 가장 오래된 페이지를 교체한다.
+ OPT(Optimal)
    - 가장 먼 미래 동안 사용되지 않을 페이지를 교체한다.(불가능)
+ LFU(Least Frequently Use)
    - 가장 사용 빈도가 적은 페이지를 교체한다.
+ MFU(Most Frequently used)
    - 가장 사용 빈도가 많은 페이지를 교체한다.
+ LRU(Least Recently Use)
    - 가장 오랫동안 사용되지 않은 페이지를 교체한다.
+ NUR(Not Used Recently)
    - LRU와 유사한 알고리즘으로, 가장 오랫동안 사용되지 않은 페이지를 교체한다.
    - 이를 확인하기 위해서 참조비트와 변형비트를 사용한다.
    - 참조 비트 : 페이지가 호출되지 않았을 때는 0, 호출되었을 때는 1
    - 변형 비트 : 페이지 내용이 변경되지 않았을 때는 0, 변경되었을 때는 1
    - 00인것이 가장 먼저 교체되버린다.
+ Clock Algorithm
    - LRU와 유사한 알고리즘으로, 각 페이지가 최근에 참조되었는지 여부를 활용한다.
    - 페이지마다 reference bit을 갖고 있고, 초기에는 모두 0,  참조되면 1으로 변경된다.
    - page replacement가 진행되면 한쪽 방향으로 page table을 참조하기 시작하면서 1비트를 만다면 0비트로 내리고 0비트를 만나면 해당 페이지가 replacement 대상이 된다.
    - __가장 오랫동안 참조되지 않은 페이지를 찾을 수는 없지만, 가장 최근에 참조된 페이지는 피할 수 있다.__


</details>

-----------------------

<br>  



### Trashing

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

__메모리 영역에 접근하게 될 때, 메모리에 페이지 부재(=페이지 폴트(Page fault)율이 높은 것을 의미한다.__  
Page Fault, Page Replacement가 발생하면서 다양한 프로세스가 메모리에 올라오면 메모리의 유효공간은 줄어들고 CPU의 가동시간이 올라가면서 자원을 최대한 활용하는 상태에 이른다.  
시간이 흐르면 CPU 사용률이 떨어지게 되는데 이는 __메모리에 프로세스가 많아지면서 프로세스당 물리 메모리를 사용할 수 있는 프레임의 개수가 줄어들고, 페이지가 물리 메모리에 적게 올라온 프로세스는 명령을 조금만 수행해도 Page Fault가 발생하여 Page Replacement를 진행__ 하게 되기 때문이다.  
Page Replacement로 Swap 공간에서 페이지를 가져오기까지 상대적으로 오랜 시간이 걸리기 때문에 그동안 다른 프로세스가 CPU를 넘겨받지만 그 프로세스도 곧 Page Replacement를 진행하게 된다.  
__결과적으로 모든 프로세스들이 페이지를 교체하느라 바쁘고 CPU는 할일이 없어서 쉬게 되는데 CPU가 놀고있는 것을 발견한 운영체제는 더 많은 프로세스를 메모리에 올리면서 악순환이 반복된다.__  
이 현상을 Trashing이라고 한다.  
Trashing을 해소하기 위해 운영체제는 __Working Set 알고리즘과 Page Fault Frequency 알고리즘__ 을 사용한다.  
Working Set 알고리즘은 대부분의 프로세스가 일정한 페이지만 집중적으로 참조한다는 성격을 이용해서 __특정 시간동안 참조되는 페이지 개수를 파악하여 그 페이지 개수만큼 프레임이 확보되면 그때 페이지들을 메모리에 올리는 알고리즘이다.__  
Page Replacement 활동을 진행할 때도 프로세스마다 Working Set 단위로 페이지를 쫓아낸다.  
__Page Fault Frequency 알고리즘은 Page Fault 퍼센트의 상한과 하한을 두고 상한을 넘으면 지급하는 프레임 개수를 늘리고, 하한을 넘으면 지급 프레임 개수를 줄인다.__  
이도 남는 프레임이 없으면 프로세스 단위로 페이지를 쫓아낸다.  

</details>

-----------------------

<br>  



### 메모리가 고갈되면 어떤 현상이 발생할까요?

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

__프로세스들의 Swap이 활발해지면서 CPU 사용률이 하락하게 되고, CPU가 놀고있는 것을 발견한 운영체제는 프로세스를 추가하게 되는 쓰레싱 현상이 발생한다.__  
쓰레싱이 해소되지 않을 경우, Out of Memory 상태로 판단되어 중요도가 낮은 프로세스를 찾아 강제로 종료하게 된다.  

</details>

-----------------------

<br>  


### CPU 사용률을 계속 체크하는 이유

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

특정 시점만 체크한 경우 CPU 사용률이 높아보일 수 있다.  
연속 체크시 CPU 사용률이 급격하게 떨어지는 구간을 발견할 가능성이 높아지고, 이때 메모리 적재량을 함께 체크하면 쓰레싱 유무를 확인할 수 있게 된다.  
따라서 추가적인 서버자원을 배치하는 등 해결방안을 마련할 수 있다.

</details>

-----------------------

<br>  

### 캐시의 지역성

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

캐시 메모리는 __CPU와 메모리 사이의 속도 차이를 완화하기 위한 역할__ 을 한다.  
캐시는 메모리의 데이터를 미리 가져와 저장해두는 임시 장소로 앞으로 사용될 것으로 예상되는 데이터를 미리 저장해 놓는다.  
즉, __프로세서(CPU) 가까이에 위치하면서 빈번하게 사용되는 데이터를 놔두는 장소__ 이다.  
이러한 역할을 수행하기 위해서는 CPU가 어떤 데이터를 원할 것인가를 어느정도 예측하고 있어야 한다.  
캐시의 성능은 작은 용량의 캐시 메모리에 CPU가 이후에 참조할, 쓸모 있는 정보가 어느정도 들어있느냐에 따라 좌우되기 때문이다.  
적중률(Hit rate)를 극대화 시키기 위해 데이터 지역성(Locality)의 원리를 사용한다.  
+ 시간 지역성
    - 최근에 참조된 주소의 내용은 곧 다음에 다시 참조되는 특성
+ 공간 지역성
    - 참조된 주소와 인접한 주소의 내용이 다시 참조되는 특성

이런 지역성을 이용해 현재 접근하고 있는 메모리의 근처 값들을 캐시에 저장해 놓는다면 캐시 적중률을 높일 수 있다.

</details>

-----------------------

<br>  

### 캐시 라인

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

캐시에 목적 데이터가 저장되어 있다면 바로 접근하여 출력할수 있어야 캐시가 의미가 있어진다.  
따라서, 캐시에 저장하는 데이터에는 __데이터의 메모리 주소 등을 기록해 둔 태그__ 를 달아놓게 되고 __태그들의 묶음을 캐시라인__ 이라고 한다.  

</details>

-----------------------

<br>  



### Memory Corruption

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

버그로 인한 메모리 오염, 예상되지 않은 메모리 값 변경 등에 의해 발생한다.

</details>

-----------------------

<br>  


### DMA(Direct Memory Access)

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

데이터가 이동하는 데에는 언제나 CPU의 개입이 있어야 한다. 그러므로 대량의 데이터가 이동할 때는 CPU에 많은 부하가 걸리게 된다. 그래서 __CPU를 거치지 않고 직접 데이터를 전송하는 방법__ 이 모색되었는데 그것을 DMA라고 한다.
</details>

-----------------------

<br>  



운영체제는 제가 공부가 부족해서 틀리거나 다른 내용이 있을 수 있습니다.  
검색을 통해서 학습하시고, 간단한 자신만의 답을 만들어보세요.  
보통 중요하다곤 하나 지엽적인 지식은 잘 안물어보기도 합니다.(비전공자의 경우 더더욱 물어보지 않을 가능성이 큽니다.)

<details>
  <summary>프로세스와 스레드의 차이를 설명해보세요.</summary>
  </br>
  <p>프로세스는 실행중인 프로그램을 의미합니다. 스레드는 실행 제어만 분리한 것을 의미합니다.</p>
  <p>프로세스는 운영체제로부터 자원을 할당받지만, 스레드는 프로세스로부터 자원을 할당받고, 프로세스의 코드/데이터/힙영역을 공유하기 때문에 좀 더 효율적으로 통신할 수 있습니다. 또한 컨텍스트 스위칭도 캐시 메모리를 비우지 않아도 되는 스레드쪽이 빠릅니다. 그리고, 스레드는 자원 공유로 인해 문제가 발생할 수 있으니 이를 염두에 둔 프로그래밍을 해야합니다.</p>
  <p>한 프로세스 안에 여러개의 스레드가 생성될 수 있습니다.</p>
</details>

<details>
  <summary>컨텍스트 스위칭에 대해 설명해보세요.</summary>
  </br>
  <p>컨텍스트 스위칭은 한 Task가 끝날 때까지 기다리는 것이 아니라 여러 작업을 번갈아가며 실행해서 동시에 처리될 수 있도록 하는 방법입니다.</p>
  <p>인터럽트가 발생하면 현재 프로세스의 상태를 PCB에 저장하고 새로운 프로세스의 상태를 레지스터에 저장하는 방식으로 동작합니다. 이 때, CPU는 아무런 일을 하지 않으므로 잦은 컨텍스트 스위칭은 성능저하를 일으킬 수 있습니다.</p>
  <p>스레드와 프로세스의 동작방식이 약간 상이한데, 스레드는 캐시메모리나 PCB에 저장해야하는 내용이 적고, 비워야 하는 내용도 적기때문에 상대적으로 더 빠른 컨텍스트 스위칭이 일어날 수 있습니다.</p>
</details>

<details>
  <summary>동기와 비동기의 차이(블로킹, 넌블로킹) / 장단점에 대해 설명해보세요.</summary>
  </br>
  <p>동기/비동기는 두 개 이상의 무엇인가가 시간을 맞춘다/안맞춘다로 구분할 수 있습니다.</p>
  <p>동기 방식은 메서드 리턴과 결과를 전달받는 시간이 일치하는 명령 실행 방식입니다. 또, 동기 방식은 한 함수가 끝나는 시간과 바로 다음의 함수가 시작하는 시간이 같습니다.</p>
  <p>비동기 방식은 여러 개의 처리가 함께 실행되는 방식으로, 동기 방식에 비해 단위시간 당 많은 작업을 처리할 수 있습니다. 단, CPU나 메모리를 많이 사용하는 작업을 비동기로 처리하게 되면 과부하가 걸릴 수 있습니다. 프로그램의 복잡도도 증가하게 됩니다.</p>
  <p>블로킹/논블로킹은 동기/비동기와는 다른 관점으로, 내가 직접 제어할 수 없는 대상(IO/멀티스레드)을 상대하는 방법에 대한 분류입니다.</p>
  <p>블로킹 방식은 대상의 작업이 끝날 때 까지 제어권을 대상이 가지고 있는 것을 의미합니다. 반면에 논블로킹은 대상의 작업 완료여부와 상관없이 새로운 작업을 수행합니다.</p>
  <p>동기 논블로킹은 계속해서 polling을 수행하기 때문에 컨텍스트 스위칭이 지속적으로 발생해 지연이 발생합니다.</p>
  <p>https://youtu.be/HKlUvCv9hvA 를 참고합시다.</p>
</details>

<details>
  <summary>멀티스레드 프로그래밍에 대해 설명해보세요.</summary>
  </br>
  <p>멀티스레드 프로그래밍은 하나의 프로세스에서 여러개의 스레드를 만들어 자원의 생성과 관리의 중복을 최소화하는 것을 멀티스레드 프로그래밍이라고 합니다.</p>
  <p>장점
    <ul>
      <li>멀티 프로세스에 비해 메모리 자원소모가 줄어듭니다.</li>
      <li>힙 영역을 통해서 스레드간 통신이 가능해서 프로세스간 통신보다 간단합니다.</li>
      <li>스레드의 컨텍스트 스위칭은 프로세스의 컨텍스트 스위칭보다 빠릅니다.</li>
    </ul>
  </p>
  <p>단점
    <ul>
      <li>힙 영역에 있는 자원을 사용할 때는 동기화를 해야합니다.</li>
      <li>동기화를 위해서 락을 과도하게 사용하면 성능이 저하될 수 있습니다.</li>
      <li>하나의 스레드가 비정상적으로 동작하면 다른 스레드도 종료될 수 있습니다.</li>
    </ul>
  </p>
</details>

<details>
  <summary>Thread-safe 하다는 의미와 설계하는 법을 설명해보세요.</summary>
  </br>
  <p>두 개 이상의 스레드가 race condition에 들어가거나 같은 객체에 동시에 접근해도 연산결과의 정합성이 보장될 수 있게끔 메모리 가시성이 확보된 상태를 의미합니다.</p>
  <ul>
    <li>java.util.concurrent 패키지 하위의 클래스를 사용합니다.</li>
    <li>인스턴스 변수를 두지 않습니다.</li>
    <li>Singleton 패턴을 사용합니다.(이 때, 일반적으로 구현하는 Singleton Pattern은 Thread-safe 하지 않습니다.)[참고](https://github.com/ksundong/TIL/blob/master/DesignPattern/singleton-pattern.md)</li>
    <li>동기화(syncronized) 블럭에서 연산을 수행합니다.</li>
  </ul>
</details>

<details>
  <summary>프로세스 동기화에 대해 설명해보세요.</summary>
  </br>
  <p>알아야 하는 부분이 조금 많습니다. 면접때에는 적절히 짧게 끊어서 대답합시다. 너무 깊게 들어가면 말을 번복할 가능성도 있고, 잘 모른다는 인상을 주기 쉽습니다.</p>
  <p>다중 프로세스 환경에서 자원등에 한 프로세스만이 접근가능하도록 하는 것입니다.</p>
  <p>프로세스 동기화를 하지 않으면 데이터의 일관성이 깨지기 때문에 연산결과가 잘못 반환될 가능성이 존재하기 때문에 주의해야 합니다.</p>
  <p>Race Condition(경쟁 상태): 여러 프로세스나 스레드가 동기화 메커니즘 없이 자원에 접근하려는 상황을 가리킵니다. 공유된 자원에 대한 접근 순서에 따라 실행 결과가 달라질 수 있는 상황을 의미합니다.</p>
  <p>Critical Section(임계 구역): 여러 스레드가 동시에 접근해서는 안되는 공유자원에 접근하는 코드 블럭을 얘기합니다. 한 임계구역에 하나의 스레드 혹은 프로세스만 접근이 가능합니다. 임계 구역에 접근하는 것을 제어하기 위해 세마포어, 뮤텍스와 같은 매커니즘을 사용합니다.</p>
  <p>임계 구역 문제를 해결하기 위한 조건(모두 충족해야함)
    <ul>
      <li>상호 배제(Mutual Exclusion): 한 프로세스가 임계구역에서 동작중이면 다른 프로세스는 접근할 수 없다.</li>
      <li>진행(Progress): 임계구역에서 작업중인 프로세스가 없다면 입계구역으로 진입하려는 프로세스를 적절히 선택해서 진입할 수 있도록 합니다.</li>
      <li>유한 대기(Bounded Waiting): 한 프로세스가 임계영역으로 진입을 요청한 후 다른 프로세스는 진입이 유한한 횟수로 제한되어야 합니다. (기아상태 방지)</li>
    </ul>
  </p>
</details>

<details>
  <summary>교착상태와 기아상태의 해결방법에 대해 설명해보세요.</summary>
  </br>
  <p>교착상태(Deadlock)가 무엇인지 알고 있어야 합니다. 서로 다른 프로세스가 서로 점유하고 있는 자원의 반납을 대기하고 있는 상태를 의미합니다.</p>
  <p>발생조건
    <ul>
      <li>상호 배제: 한 번에 한 프로세스만 해당 자원을 사용할 수 있어야 합니다.</li>
      <li>점유 대기: 할당된 자원을 가진 상태에서 다른 자원을 기다립니다.</li>
      <li>비선점: 다른 프로세스가 자원의 사용을 끝낼 때 까지 자원을 뺏을 수 없습니다.</li>
      <li>순환대기: 각 프로세스가 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있습니다.</li>
    </ul>
  </p>
  <p>해결방법
    <ul>
      <li>예방: 4가지 조건 중 하나라도 만족되지 않도록 합니다.</li>
      <li>회피: 알고리즘을 데드락이 발생하지 않도록 합니다.</li>
      <li>회복: 교착상태가 발생할 때, 해결합니다.</li>
      <li>무시: 회복과정의 성능저하가 심하다면 그냥 무시합니다.</li>
    </ul>
  </p>
  <p>기아상태(Starvation): 여러 프로세스가 부족한 자원을 점유하기 위해 경쟁할 때, 특정 프로세스가 영원히 자원 할당이 되지 않는 경우입니다.</p>
  <p>우선순위를 변경합니다.(우선순위를 수시로 변경하거나, 오래 기다린 프로세스의 우선순위를 높여주거나, Queue를 사용합니다.)</p>
</details>

<details>
  <summary>세마포어와 뮤텍스의 차이에 대해 설명해보세요.</summary>
  </br>
  <p>세마포어는 여러개의 프로세스가 접근 가능한 공유자원을 관리하는 방식이고, 뮤텍스가 될 수 있지만, 뮤텍스는 한 번에 한 개의 프로세스만 접근 가능하도록 관리하는 방식입니다. 따라서 뮤텍스는 세마포어가 될 수 없습니다.</p>
  <p>또, 세마포어는 다른 프로세스가 세마포어를 해제할 수 있지만, 뮤텍스는 락을 획득한 프로세스만 락을 반환할 수 있습니다.</p>
</details>

<details>
  <summary>가상 메모리에 대해 설명해보세요.</summary>
  </br>
  <p>가상 메모리는 프로세스가 실제 메모리의 크기와 상관없이 메모리를 이용할 수 있도록 지원하는 기술 입니다.</p>
  <p>가상 메모리는 실제 메모리(RAM, main memory, first storage)와 보조 기억 장치(auxiliary storage, secondary storage)의 Swap 영역으로 구성됩니다.</p>
  <p>OS 는 메모리 관리자(Memory Management Unit)를 통해 메모리를 관리하며 프로세스는 사용하는 메모리가 실제 메모리인지, Swap 영역인지 모릅니다.</p>
  </br>
  <p>Java 에서는 Swap 영역을 잡아주지 않은 경우 OOM 이 발생할 수 있습니다.</p>
  <p>Swap 영역은 실제 메모리가 아니기 때문에 지연시간이 많이 발생하며, 가급적이면 Swap 메모리를 사용하지 않도록 설계하는 것이 좋고, 만약 계속해서 사용하는 양이 증가한다면 메모리 누수를 의심해 볼 수 있습니다.</p>
</details>

<details>
  <summary>캐시의 지역성에 대해 설명해보세요.</summary>
  </br>
  <p>캐시가 무엇인지, 왜 캐시를 사용하는지를 알고 있어야 합니다. 관련한 좋은 글을 링크해둡니다. https://parksb.github.io/article/29.html</p>
  <p>시간 지역성과 공간 지역성으로 나눌 수 있으며, 시간 지역성은 최근에 접근한 데이터에 다시 접근하는 경향을 의미하고, 공간 지역성은 최근 접근한 데이터의 주변 공간에 다시 접근하는 경향을 의미합니다.</p>
</details>

<details>
  <summary>프로세스 관련 용어를 설명해보세요. (알아만 둡시다.)</summary>
  </br>
  <p>PCB: 프로세스 제어 블록, 프로세스에 대한 중요한 정보를 저장합니다.</p>
  <p>PC: 프로그램 카운터, 프로세스 실행을 위한 다음 명령의 주소를 표시합니다.</p>
  <p>캐시메모리: 자주 사용되는 데이터가 저장되는 공간으로 CPU의 레지스터와 메모리 사이에서 병목 현상을 완화하는 장치입니다.</p>
</details>

### 데이터베이스

### DBMS

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


+ __데이터베이스 관리 시스템__ 으로 여러 사용자가 데이터베이스에 접근하여 사용할 수 있도록 해주는 소프트웨어


</details>

-----------------------

<br>

### DB를 사용하는 이유

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ 파일 시스템의 __데이터 중복, 비일관성, 검색 등의 문제__ 를 해결하기 위해서 사용
+ 파일 시스템이 OS마다 다를 수 있기 때문에 OS에 종속적인 파일 시스템을 이용하는 것은 프로그램의 확장성을 해침

</details>

-----------------------

<br>


### 스키마

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ __데이터베이스의 구조와 제약 조건에 관한 전반적인 명세를 기술한 메타데이터 집합__

</details>

-----------------------

<br>

### 뷰

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


+ 하나 이상의 테이블에서 유도된, __매모리에 물리적으로 존재하지 않는 가상 테이블__
+ 특정 사용자로부터 특정 속성을 숨기는 기능으로 뷰를 정의하여 그 뷰를 테이블처럼 사용
+ __인덱스를 가실 수 없고, 뷰의 정의를 변경할 수 없음__
+ 기본 키 포함하고 정의할 경우, 삽입, 삭제, 갱신 가능

</details>

-----------------------

<br>


### 키


<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


![그림1](https://backtony.github.io/assets/img/post/interview/db-1.PNG)  
+ 검색, 정렬 시 튜플을 구분하는 기준이 되는 속성
+ 유일성 : 키로 튜플을 유일하게 식별할 수 있음
+ 최소성 : 튜플을 구분하는데 꼭 필요한 속성들로만 구성

</details>

-----------------------

<br>


### 후보키
<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


+ 테이블을 구성하는 속성 중에서 튜플을 유일하게 식별할 수 있는 속성들의 부분 집합
    - 기본 키로 사용할 수 있는 속성들
+ 모든 테이블은 하나 이상의 후보 키를 가짐(기본키)
+ 유일성과 최소성 만족

</details>

-----------------------

<br>


### 기본 키

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


+ 후보 키 중에서 선택한 Primary Key
+ 특정 튜플을 유일하게 식별 가능
+ 중복 값과 NULL 불가
+ 유일성과 최소성 만족

</details>

-----------------------

<br>


### 대체 키

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


+ 후보 키가 두개 이상일 때, 기본 키를 제외한 나머지 후보 키

</details>

-----------------------

<br>


### 슈퍼 키

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


+ 고유하게 식별하는 모든 후보키의 조합하는 키
+ 유일성은 만족하지만, 최소성은 만족하지 않음

</details>

-----------------------

<br>


### 외래 키

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


+ __다른 릴레이션(테이블)의 속성, 참조 관계를 표현하는데 사용하는 키__
+ 테이블의 열 중 다른 테이블의 기본키를 참조하는 열
+ 테이블 간의 연결, 중복 방지, 무결성 유지

</details>

-----------------------

<br>




### 트랜잭션

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ __데이터베이스의 상태를 변화시키는 하나의 논리적인 작업 단위__
+ 논리적인 작업의 쿼리 캐수와 관계 없이 논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않아야 함을 보장

</details>

-----------------------

<br>

### 트랜잭션 특징 ACID

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ Atomicity(원자성)
    - 트랜잭션을 구성하는 연산 전체가 모두 정상적으로 실행되거나 모두 취소되어야 한다.
+ Consistency(일관성)
    - 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지한다.
+ Isolation(고립성)
    - 두 개 이상의 트랜잭션이 동시에 발생할 때, 서로의 연산에 영향을 주면 안된다.
+ Durability(영구성)
    - 커밋된 트랜잭션의 내용은 영구히 반영된다.

</details>

-----------------------

<br>

### 트랜잭션 상태

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ 활동(Active)
    - 트랜잭션이 실행 중인 상태
+ 장애(Fail)
    - 트랜잭션이 실행에 오류가 발생하여 중단한 상태
+ 철회(Aborted)
    - 트랜잭션이 비정상적으로 종료되어 Rollback 수행하는 상태
+ 부분 완료(Partially Commit)
    - 트랜잭션이 마지막 연산까지 실행했지만, Commit 연산이 실행되기 직전 상태
+ 완료(Commmitted)
    - 트랜잭션이 성공적으로 종료되어 commit 연산을 실행한 후의 상태

</details>

-----------------------

<br>


### 트랜잭션 격리수준

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ __Read Uncommitted__
    - 다른 트랜잭션에서 커밋되지 않은 내용에 접근 가능 __(Dirty Read)__
    - 락 발생 X
+ __Read Committed__
    - 커밋된 내용만 접근 가능
    - 한 트랜잭션 내에서 검색 결과가 비일관적인 현상 발생 __(Nonrepeatable read)__
    - 락 발생 X
+ __Repeatable Read__
    - 커밋이 완료된 데이터만 읽을 수 있으며, 트랜잭션 범위 내에서 조회한 내용이 항상 동일함을 보장
    - __일정범위의 레코드를 두번 이상 읽을 때, 첫 번재 쿼리에서 없던 유령 레코드가 두번째 쿼리에서 나타나는 현상을 Phantom read__
    - 락 발생
+ __Serializable__
    - 한 트랜잭션에서 사용하는 데이터는 다른 트랜잭션이 접근 불가능
    - 락 발생

</details>

-----------------------

<br>



### Commit

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ 트랜잭션이 성공하여 트랜잭션 결과를 영구적으로 반영하는 연산

</details>

-----------------------

<br>

### Rollback

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ 트랜잭션의 실행을 취소하였음을 알리는 연산
+ 트랜잭션이 수행한 결과를 원래의 상태로 원상 복귀시키는 연산

</details>

-----------------------

<br>


### 동시성 제어

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

동시성 제어는 동시에 여러개의 트랜잭션이 수행될 때, 트랜잭션들이 DB의 일관성을 파괴하지 않도록 트랜잭션 간의 상호작용을 제어하는 것을 의미한다.  

</details>

-----------------------

<br>


### Locking

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ 트랜잭션이 데이터에 접근하기 전에 Lock을 요청해서 Lock이 허락되면 해당 데이터에 접근할 수 있도록 하는 기법
+ 종류
    - 비관적 락(Pessimistic lock)
        - 공유락(Shared Lock) : 사용중인 데이터를 다른 트랜잭션이 읽기 허용, 쓰기 비허용
        - 베타락(Exclusive Lock) : 사용중인 데이터를 다른 트랜잭션이 읽기, 쓰기 비허용
        - __데이터 수정 즉시 트랜잭션 충돌을 감지할 수 있다.__
        - 롤백을 개발자가 일일이 하는 것이 힘든 경우, 충돌이 일어났을 때 롤백 비용이 많이 드는 경우, 주문 시에 쿠폰 사용, 알림 제공, 주문서 작성 등의 여러 기능이 한 트랜잭션에 묶여 있는 경우에 적합하다.
    - 낙관적 락(Optimistic lock)
        - 데이터 갱신 시 충돌이 발생하지 않을 것으로 가정하여 락을 걸지 않는 방식 -> __락이 아닌 버전 관리 기능을 통해서 트랜잭션 격리성 관리__
        - Version 컬럼을 별도로 추가해서 충돌 방지 -> Version 정보를 사용하면 최초 커밋만 인정된다.
            - 벌크 연산은 버전을 무시하기 때문에 벌크 연산에서는 버전을 증가시키려면 버전 필드를 강제로 증가시켜야 한다.
        - DB 가 제공하는 락 기능을 사용하지 않고 __JPA 가 제공하는 버전 관리 기능을 사용__ -> 애플리케이션에서 제공하는 락
        - __커밋 전까지는 충돌을 알 수 없다.__
        - __충돌이 나면 롤백 처리는 개발자의 몫이다.__
    - 둘의 사용을 판단하는 기준을 읽기와 수정 비율이 어디에 가까운지 보고 판단해야 한다. 수정의 비율이 높다면 Pessimistic을 사용하고 읽기의 비중이 높다면 Optimistic을 사용한다.


</details>

-----------------------

<br>

### 갱신 분실 문제



<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


A와 B가 동시에 제목이 같은 공지사항을 동시에 수정한다고 했을 때 A가 먼저 수정을 완료하고 B가 이후에 완료버튼을 눌렀다면 B의 수정사항만 남게되는데 이것을 갱신 분실 문제라고 한다.  
갱신 분실 문제는 데이터베이스 트랜잭션의 범위를 넘어서는 문제로 트랜잭션으로만 해결할 수는 없고 3가지 선택 방법이 있다.
+ 마지막 커밋만 인정하기
    - 위에서는 B의 커밋만 인정한다.
    - 기본값
+ 최초 커밋만 인정하기
    - 위에서는 A의 수정을 인정하고 B의 수정이 완료될 때 오류가 발생한다.
+ 충돌하는 갱신 내용 병합하기
    - 사용자 A와 사용자 B의 수정사항을 병합한다.

</details>

-----------------------

<br>


### MVCC(격리 수준 제어) 대신 락을 사용하는 이유


<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------



__낙관적 락이나 비관적 락은 다른 트랜잭션이 수정하는 것 자체를 막아버린다.__  
반면에 MVCC는 다른 트랜잭션이 수정하는 것 자체는 막지 못하고, 트랜잭션 격리 레벨에 따라 __일관된 읽기__ 를 제공한다.  
따라서 두 개의 트랜잭션이 동시에 수정할 때 처음의 수정사항만 반영하도록 하여 __갱신 분실 문제를 예방__ 하기 위해서는 락을 사용한다.  
MVCC가 일관된 읽기를 사용할 수 있는 이유는 변경되기 이전의 내용을 보관하고 있는 __언두 로그__ 에서 데이터를 가져오기 때문이다.

</details>

-----------------------

<br>

### 낙관적 락보다 DB 트랜잭션 레벨을 Repeatable Read로 하면 되지 않을까?

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


__Repeatable read는 선행 트랜잭션이 종료시까지 다른 트랜잭션이 update, delete하지 못하도록 완전히 락을 걸어버린다.__  
반면에 낙관적인 락은 애플리케이션 단에서 락을 걸지 않아 트랜잭션 자체를 blocking하지 않으면서도 다른 트랜잭션이 수정하는 것을 막아준다.  
락을 거는 것 자체가 성능에 영향을 줄 수 있기 때문에 읽기 작업의 비율이 높은 경우 격리 레벨을 조정하는 것보다 낙관적인 락을 사용하는게 더 좋다.

</details>

-----------------------

<br>

### 무결성 제약조건

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ 데이터베이스의 정확성, 일관성을 보장하기 위해 저장, 삭제, 수정 등을 제약하기 위한 조건
+ 개체 무결성 : 기본 키는 null, 중복값 불가능
+ 참조 무결성 : 외래 키는 null이거나 참조 테이블의 기본 키 값과 동일해야 함


</details>

-----------------------

<br>


### 조인

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ __두 개 이상의 테이블이나 데이터베이스를 연결하여 데이터를 검색하는 방법__
+ 적어도 하나의 컬럼을 서로 공유하고 있어야 한다.

### 종류
+ INNER JOIN
    - 기준 테이블과 join한 테이블의 __중복된 값__ 을 보여준다.
    - __교집합__ 과 같아고 보면 된다.
+ LEFT OUTER JOIN
    - 기준 테이블의 값 + join 테이블과 기준테이블의 중복된 값
    - 기준 테이블은 다 보여주고, join 테이블은 기준 테이블과 중복되는 값만 붙여준다고 생각하면 된다.
    - 기준 테이블과 중복되는 값이 없다면 join 테이블의 내용은 NULL로 표기된다.
+ RIGHT OUTER JOIN
    - LEFT OUTER JOIN의 반대이다.
+ FULL OUTER JOIN
    - 기준, Join 테이블의 합집합
    - 전부 다 보여주고 빈값들은 NULL로 채워진다.
+ CROSS JOIN
    - 크로스 곱이라고도 하는데 모든 경우의 수를 전부 표현해주는 방식이다.
    - 각 테이블의 데이터 개수가 N,M 이라면 결과는 N*M의 데이터 개수가 나온다.    
+ SELF JOIN
    - CROSS JOIN의 대상이 자기 자신인 것

</details>

-----------------------

<br>


### 트리거

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ __DML이 수행되었을 때, 자동으로 실행되게 정의한 프로시저__
    - 프로시저란 쿼리문을 마치 하나의 메서드 형식으로 만들고 어떠한 동작을 일괄적으로 처리하는 용도

</details>

-----------------------

<br>


### SQL

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


+ DML : 데이터 조작
    - Select, Insert, Update, Delete
+ DDL : 데이터(구조, 객체) 정의
    - Create, Drop(테이블 삭제), Truncate(테이블 데이터 삭제, 테이블 초기화), Alter
+ DCL : 권한 제어
    - Grant, Revoke


</details>

-----------------------

<br>

### 힌트

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ __옵티마이저가 항상 최적의 실행 경로 실행을 보장하지 않기 때문에 직접 최적의 실행 경로를 작성해주는 것__

</details>

-----------------------

<br>


### 인덱스

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ 추가적인 쓰기와 저장 공간사용을 통해 __데이터베이스의 검색 속도 향상시키기 위한 방법__
+ 칼럼의 값(key)와 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스 정의
+ 일반적으로 B+ 트리 자료구조를 사용
+ 장단점
    - 검색 속도 향상
    - 데이터의 추가, 삭제, 수정의 경우 인덱스도 변경하고 정렬해야 하므로 성능 저하
    - 추가적인 저장 공간 필요
+ 알고리즘
    - B 트리 알고리즘 : 컬럼의 값을 변형하지 않고 원래의 값으로 인덱싱, 등호 뿐만 아니라 부등호 연산에도 적용 가능
    - Hash 알고리즘 : 해시값을 이용한 인덱싱


</details>

-----------------------

<br>


### Cluster 인덱스

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ 인덱스로 지정한 컬럼을 기준으로 물리적으로 정렬하는 인덱스
+ 한 테이블당 1개 (Primary Key)
+ 위에서 언급한 일반적인 인덱스로 검색속도는 빠르지만, 입력,수정,삭제는 느림

</details>

-----------------------

<br>


### Non-Cluster 인덱스


<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ 데이터 자체는 정렬되지 않고, 인덱스값을 기준으로 정렬하여 새로 인덱스 페이지를 만드는 인덱스
+ 새로 인덱스 페이지를 만들고 리프 페이지에 실제 데이터가 위치한 주소를 가리킴
+ 한 테이블 당 여러 개 가능
+ 검색 속도는 Cluster에 비해 느리지만, 입력,수정,삭제가 빠름

</details>

-----------------------

<br>


### 멀티 인덱스

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ __두개 이상의 필드를 조합하여 생성한 인덱스__
+ 그냥 두개 인덱스로 조회하면 되지 않을까?
    - mysql은 단일 쿼리를 실행할 때 __하나의 테이블 당 하나의 인덱스만 사용__ 할 수 있다. 
    - 둘중 인덱싱데이터 내 행이 적은 것을 먼저 참조하게 된다.

</details>

-----------------------

<br>


### scan

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ Table Full Scan
    - 테이블에 속한 블록 전체를 읽어서 사용자가 원하는 데이터를 찾는다.
+ Index Range Scan
    - 인덱스 컬럼이 가공되지 않은 상태로 조건절에 있을 때 수행된다.
    - 인덱스에서 일정량을 스캔하면서 얻은 ROWID를 사용해 테이블 레코드를 찾는다.
+ Index Full Scan
    - 인덱스 컬럼이 조건에 없으면 Index Range Scan이 불가능하므로, 옵티마이저는 Table Full Scan을 고려한다.
    - 그런데 대용량 테이블이라 Table Full Scan에 대한 부담이 너무 크면 Index를 활용해야할 필요가 있다.
    - 인덱스의 전체 크기는 테이블의 전체 크기보다 훨씬 적으므로, Index Range Scan을 할 수 없을 때, Table Full Scan보다는 Index Full Scan을 고려한다.


</details>

-----------------------

<br>


### B 트리

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

![그림2](https://backtony.github.io/assets/img/post/interview/db-2.PNG)  
+ 이진 트리를 확장해서 많은 자식을 갖을 수 있는 __균형 트리__
+ key들이 항상 오름차순으로 정렬되어 구성
+ Branch와 Leaf 노드가 key와 data를 저장

</details>

-----------------------

<br>



### B+ 트리

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

![그림3](https://backtony.github.io/assets/img/post/interview/db-3.PNG)  
+ B트리를 확장해서 데이터의 빠른 접근을 위한 인덱스 역할만 하는 비단말 노드를 추가한 트리(리프들이 연결되어 있음)
+ __Branch 노드는 key만 저장__
+ key들이 항상 오름차순으로 정렬되어 구성
    - 하나의 노드에 더 많은 key를 담을 수 있게 되므로 트리의 높이가 B 트리에 비해 더 낮아진다.(cache hit를 높임)
+ Leaf 노드는 Key와 Data를 저장하고 Linked List로 연결되어 있음(검색에 유용)
    - 풀 스캔 시 B트리는 모든 노드를 확인해야하지만, B+ 트리의 경우 리프노드에 연결된 연결리스트로 선형 탐색이 가능하다.

</details>

-----------------------

<br>


### 해시 테이블

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ 칼럼 값으로 생성된 해시를 기반으로 인덱스 구현
+ O(1)로 매우 빠름
+ 해시 테이블은 __동등 연산에 특화된 자료구조__ 이기 때문에 __select 조건에서 부등호 연산 사용시 성능 저하__
+ __동등 비교에서는 효과적__
+ 해시는 데이터를 고정된 데이터의 크기로 변환시키는 것을 말함.

</details>

-----------------------

<br>


### 해시 인덱스 vs b 트리 인덱스

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ 동등 비교에서는 해시 인덱스가 효과적
+ 범위 검색에서는 b 트리 인덱스가 정렬되어 있어서 효과적

</details>

-----------------------

<br>


### 정규화

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

이상현상이 존재하는 테이블(릴레이션)을 분해하여 여러 개의 테이블(릴레이션)으로 생성하는 과정  
__이상현상을 제거하기 위해 테이블을 분리하는 작업__
+ 이상현상
    - 삽입 이상 : 불필요한 데이터를 추가해야만 삽입이 가능한 상황
    - 갱신 이상 : 전체의 데이터 중 일부만 변경하여 데이터가 불일치하는 상황
    - 삭제 이상 : 삭제로 인해 꼭 필요한 데이터까지 삭제되는 상황
+ 1 정규화 : 테이블의 컬럼이 하나의 값을 갖도록 테이블을 분해하는 것(도메인이 __원자값만__ 포함)
+ 2 정규화 : 기본키의 부분집합이 결정자가 안되도록 분리(완전 함수적 종속)
+ 3 정규화 : 이행종속 제거 (a -> b, b -> c 일때, a->c 가 성립되는 것을 분리, 즉, a-> b랑 b->c 테이블로 분리)
+ BCNF : __값을 정하는 결정자가 후보키가 되도록 테이블 분해(모든 결정키가 후보키)__

</details>

-----------------------

<br>


### 반정규화

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

__반정규화는 성능 향상을 위해 중복, 통합하는 기법으로 조인으로 인한 성능 저하가 예상되는 경우 반정규화를 사용한다.__

</details>

-----------------------

<br>


### 커넥션 풀

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

클라이언트 요청에 따라 각 애플리케이션의 스레드에서 데이터베이스에 접근하기 위해서는 커넥션이 필요하다.  
커넥션 풀이란 __미리 일정 수의 Connection을 만들어 풀에 보관해 두는 것__ 을 의미한다.  
+ 사용자의 요청에 따라 Connection을 생성하다 보면 많은 수의 연결이 발생했을 때 서버에 과부하가 걸리게 되므로 방지하기 위함
+ 커넥션 풀을 사용하면 생성, 소멸에 시간 소요가 없어지기 때문에 효율적
+ 한번에 사용할 수 있는 커넥션 수가 제어되어 애플리케이션이 쉽게 죽지 않음


</details>

-----------------------

<br>

### 관계형 DB, NoSQL

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


+ 관계형 DB
    - __정해진 스키마에 따라 데이터를 테이블에 저장하는 데이터베이스__
    - __데이터 구조를 보장하고 중복을 피할 수 있다.__
    - SQL을 사용하면 RDBMS에서 데이터를 저장, 수정, 삭제 및 검색 할 수 있다.
    - 데이터는 관계를 통해 여러 테이블에 분산된다.
    - 수직적 확장이 가능하다(단순히 서버의 성능을 향상시키는 것)
    - 사용처
        - __관계를 맺고 있는 데이터가 자주 변경되는 경우__
        - 변경될 여지가 없고, 명확한 스키마가 사용자와 데이터에게 중요한 경우
+ NoSQL
    - __스키마가 없거나 느슨한 스키마로 데이터 간의 관계없이 자유로운 형태로 데이터를 저장하는 데이터베이스__
    - 유연하기 때문에 언제든지 데이터를 조정하고 새로운 필드를 추가할 수 있다.
    - 중복을 계속 업데이트해야하는 단점이 있다.
    - __수평적 확장__ 으로 __트래픽 분산 및 대용량 처리__ 가 가능하다.
    - 레코드를 문서(documents)라고 부른다.
    - Eventual Consistency
        -Consistency를 보장해주지 못하기 때문에 나온 개념으로, Consistency를 완전히 보장하지는 않지만, 결과적으로 언젠가는 Conssistency가 보장됨을 의미
    - 사용처
        - __읽기를 자주 하지만 데이터 변경은 자주 없는경우__
        - 정확한 데이터 구조를 알 수 없거나, 변경/확장될 수 있는 경우
        - 데이터베이스를 수평적으로 확장해야하는 경우(막대한 양의 데이터를 다루는 경우)

</details>

-----------------------

<br>


### Redis, MongoDB, Memcached

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ redis
    - __싱글 스레드 인메모리 DB로 key-value 형태로 데이터를 저장__ 하며 주로 캐시에 사용
    - __스냅샷, AOF를 통해 백업 가능__
        - 스냅샷 기능을 통해 디스크에 백업하거나, AOF를 통해 명령 쿼리를 저장해두고 서버가 셧다운되면 재실행 방식으로 휘발을 막음
        - AOF :모든 작업을 log 파일에 기록해두고 서버가 재실행되면 순차적으로 연산을 수행하면서 데이터를 복구하는 방식
    - 자료구조 지원
+ MongoDB
    - __JSON과 유사한 문서(document)를 사용하여 스키마 없는 데이터를 저장한다.__
    - 물리 디스크 사용
+ Memcached
    - __멀티스레드__ 를 지원하는 고성능 분산 메모리 캐싱 시스템
    - 데이터 복제를 지원하지 않는다.

Memcached는 데이터베이스로드를 줄이고 웹 애플리케이션의 속도를 높이는데 유용하고, Redis는 확장 가능한 웹 애플리케이션을 구축하고 고급 데이터 구조가 필요할 때 사용할 수 있다.

</details>

-----------------------

<br>



### Elastic search

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ 자바 기반의 오픈소스 검색 엔진
+ ELK 스택으로 lastic search, Logstach, kibana 로 묶어서 사용함
+ 역색인(inverted index)로 데이터를 저장해서 전문(Full-text)검색 시에 RDBMS보다 성능이 뛰어남
    - 역색인이란 책 뒤에 보면 단어별로 위치가 어딘지 명시해놓은 방식
    - RDBMS는 인덱스가 B+ tree 방식으로 구현되어 있음

</details>

-----------------------

<br>

### Elastic search 키워드 검색 vs RDBMS %like%

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ RDBMS
    - __LIKE의 경우 와일드카드로 시작하는 경우, 인덱스를 사용하지 않기 때문에 전체 검색이 진행되어 느리다.__
    - LIKE의 경우 고정된 문자로 시작되는 경우, 인덱스가 동작한다.
+ Elastic search 
    - 전체 검색이 아니라 역색인을 기반으로 검색하기 때문에 빠르다.

</details>

-----------------------

<br>

### 클러스터링

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

![그림4](https://backtony.github.io/assets/img/post/interview/db-4.PNG)  

DB 클러스터링은 __DB스토리지는 공유하고 동일한 DB 서버를 다중화(여러 대)하는 방식__ 이다.  
동기 방식으로 동기화한다.  
+ Active-Active 방식
    - 여러 대의 DB서버가 트래픽을 분산해서 받는다.
    - 여러 대의 서버가 DB 스토리지를 공유하기 때문에 병목이 생길 수 있다.
+ Active-Standby 방식
    - 한쪽은 Standby 상태로 두어 Active 상태의 서버가 죽으면 FailOver되어 전환하는 방식
    - FailOver이 이루어지는 동안 손실이 존재한다.

</details>

-----------------------

<br>

### 레플리케이션

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

![그림5](https://backtony.github.io/assets/img/post/interview/db-5.PNG)  

DB 레플리케이션은 __DB 서버와 DB 스토리지를 다중화하는 방식__ 이다.  
+ 조회작업은 Slave에서 INSERT, DELETE, UPDATE 작업은 Master에서 수행하면서 트래픽 분산
+ Slave로 데이터를 옮길 때 비동기 방식으로 동작하기 때문에 일관성 있는 데이터를 얻지 못할 수 도 있다.
+ Master 노드가 다운되면 복구 및 대처가 까다롭다.

</details>

-----------------------

<br>


### 수직 파티셔닝

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ __큰 Table이나 인덱스를 관리하기 쉬운 단위로 분리하는 방식__
+ 예를 들어, 사람이라는 테이블이 너무 커지게 되면서 사람을 북유럽인, 아시아인, 서유럽인 이렇게 테이블로 분리하는 것이라고 볼 수 있다.
+ 장점
    - Insert 시 분리된 파티션으로 분산시켜 경합을 줄임
    - 읽기/쓰기 향상
    - 파티션 별로 백업 및 복구 가능
    - 데이터 전체 검색 시 필요한 부분만 탐색해서 성능 증가
+ 단점
    - 인덱스와 테이블을 별도로 파티셔닝 할 수 없다. 즉, 테이블과 인덱스를 같이 파티셔닝 해야한다.
    - 테이블 간 조인 비용 증가

</details>

-----------------------

<br>

### 샤딩(수평 파티셔닝)

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ __같은 테이블 스키마를 가진 데이터를 다수의 데이터베이스에 분산하여 저장하는 방식__
+ 데이터를 잘 분산시키기 위해 고려해야할 것이 Shard Key이고 이를 정하는 방식으로 Hash Sharding, Dynamic Sharding, Entity Group 방식이 있다.
+ 샤딩은 복잡도가 매우 높아지므로 다른 방식을 우선적으로 고려해야 한다.

</details>

-----------------------

<br>



### SQL Injection

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

__해커에 의해 조작된 SQL쿼리문이 데이터베이스에 그대로 전달되어 비정상적 명령을 실행시키는 공격 기법__ 을 말한다.  
입력값에 대한 검사, Error Message 노출을 하지 않도록 하여 대응한다.

</details>

-----------------------

<br>



### 행의 개수가 많은 테이블 설계

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ 파티셔닝 또는 샤딩으로 테이블을 분리하거나 레플리카를 사용해 write, read 트래픽을 분산시킬 수 있다.
+ 카디널리티가 높은 것을 기준으로 인덱스 설정
    - 인덱스도 공간을 차지하기 때문에 테이블당 최대 4개가 적당하다.
    - 조건절로 열을 같이 자주 사용하는 것이 있다면 멀티 인덱스를 고려한다.
+ 쿼리 성능 향상(JPA, Querydsl)
    - Entity 대신 DTO를 사용해 조회쿼리 최적화
        - 이미 알고 있는 값인 경우 as 표현식으로 대체
    - 연관된 Entity의 Save를 위해서는 반대편 Entity의 Id값만 있으면 되므로 Id만 조회해서 연관관계를 맺는다.
    - 모든 컬럼이 인덱스로 이뤄진 커버링 인덱스 방식으로 쿼리 작성
    - 더보기(slice) 방식의 페이징 쿼리의 경우 offset를 사용하지 않는 nooffset 방식으로 쿼리 최적화        
    - 같은 테이블에 여러 데이터를 insert 할 경우, 아무 세팅도 하지 않았다면 insert 쿼리가 여러번 나가게 되며 이를 배치 insert를 사용해 최적화
        - MySQL의 경우 Identity전략은 Insert를 실행하기 전까지는 ID에 할당된 값을 알 수 없기 때문에 Table 전략을 사용해야 하고 전략을 Identity로 유지하고 싶다면 JdbcTemplate을 사용한다.
    - exists 쿼리 같은 경우 조금만 복잡해지면 JPA 네이밍 쿼리로는 사용이 불가능하고 @Query로 직접 쿼리를 작성해야 하는데 JPQL는 select exist절을 지원하지 않기 때문에 count를 사용해야 함 -> Querydsl의 selectOne과 FetchFirst를 사용하면 JPA 네이밍 쿼리처럼 최적화 가능

</details>

-----------------------

<br>


### Statement, PreparedStatement

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

Statment는 __SQL문을 실행할 수 있는 객체__ 를 의미하고 둘다 첫 실행 시에 아래와 같은 과정을 거쳐 DB에 쿼리가 실행된다.
1. Parsing(구문 분석)
2. Compile
3. Execute

Statement는 매번 쿼리를 수행할 때마다 3단계를 거치게 되지만, PreparedStatement는 처음 한 번만 3단계를 거치고 이후에는 캐시에 담아서 재사용한다.  
간략하게 설명하면, statement는 매번 컴파일을 해야하지만, PreparedStatement는 캐싱해서 재사용하기 때문에 PreparedStatement가 성능이 더 좋다.  
PreparedStatement를 사용할 경우 바인딩에서 문자열을 이어서 사용하게 되면 SQL Injection 공격에 취약하므로 ?를 사용해서 바인딩해야 한다.  

</details>

-----------------------

<br>


### RabbitMQ와 Kafka

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

서비스가 점점 발전하고 규모가 커지게 되면서 서로 통신하고 데이터를 교환하는 방법이 필요해졌다.  
따라서 필요한 데이터를 담은 "메시지"라는 것을 한쪽에서 생성(produce)하면 다른 쪽에서 소비(consume)하는 구조를 사용하게 되었다.  
이 역할을 하는 것이 RabbitMQ와 Kafka이다.  
둘 다 한 곳에서 메시지를 넣어주면 필요한 곳에서 메시지를 꺼내 소비하는 방식으로 되어있지만 차이가 있다.  
+ RabbitMQ
    - 전통적인 메시지 브로커
    - 생산자와 소비자간의 보장되는 메시지 전달에 초점을 맞춰 브로커 중심적인 특징
    - 컨슈머가 메시지를 가져가면 큐에는 더 이상 남지 않고 사라진다. 따라서 소비자와 메시지 브로커의 결합력이 높아지게 되어 트래픽이 증가하면 수평적으로 확장하는데 어렵다.
    - 이벤트 메시지가 성공적으로 전달되었다고 판단될 경우 이 메시지가 큐에서 삭제되어버리기 때문에 후에 다시 이벤트를 재생하기가 어렵다.
+ Kafka
    - 최신 기술인 이벤트 스트리밍 플랫폼
    - 토픽을 컨슈머가 가져간 후에도 이벤트 스트림에서 계속 토픽을 유지하기 때문에 오류 수정이 필요하거나 앱을 리빌드 하는 등의 상황에서 이벤트를 다시 재생시킬 수 있다.
    - 레코드들을 consume 해도 레코들이 삭제되지 않기 때문에 RabbitMQ에 비해 유연하고 느슨한 결합을 가져가게 되고 유연한 확장이 가능해진다.
+ 결론
    - RabbitMQ의 경우 kafka에 비해 좀 더 쉽지만 컨슈머와 메시지 브로커간의 결합도가 높기 때문에 트래픽이 작으면서 비즈니스가 후에 확장되지 않을 확률이 높다면 RabbitMQ를 사용하는 것이 좋다.
    - 대규모 트래픽이 예상되고, 추후 확장이 예상된다면 kafka를 선택하는 것이 좀 좋다.


</details>

-----------------------

<br>

<details>
  <summary>데이터베이스에서 인덱스를 사용하는 이유 및 장단점에 대해 설명해주세요.</summary>
  </br>
  <p>데이터베이스에서 인덱스를 사용하는 이유는 검색성능을 향상시키기 위함입니다.</p>
  <p>하지만 검색성능을 실질적으로 향상시키기 위해서는 해당 쿼리가 index를 사용하는지, 카디널리티, Selectivity 같은 요소들이 고려된 인덱스가 생성되어야 합니다.</p>
  <p>일반적인 경우의 장점으로는 빠른 검색 성능을 들 수 있습니다.</p>
  <p>일반적인 경우의 단점으로는 인덱스를 구성하는 비용 즉, 추가, 수정, 삭제 연산시에 인덱스를 형성하기 위한 추가적인 연산이 수행됩니다.</p>
  <p>따라서, 인덱스를 생성할 때에는 트레이드 오프 관계에 놓여있는 요소들을 종합적으로 고려하여 생성해야합니다.</p>
</details>

<details>
  <summary>트랜잭션에 대해서 설명해주세요.</summary>
  </br>
  <p>트랜잭션이란 데이터베이스의 상태를 변화시키는 하나의 논리적인 작업 단위라고 할 수 있으며, 트랜잭션에는 여러개의 연산이 수행될 수 있습니다.</p>
  <p>트랜잭션은 수행중에 한 작업이라도 실패하면 전부 실패하고, 모두 성공해야 성공이라고 할 수 있습니다.</p>
</details>

<details>
  <summary>ACID에 대해서 설명해주세요.</summary>
  </br>
  <p>ACID는 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질입니다.</p>
  <p>
    <ul>
      <li>Atomicity(원자성): 트랜잭션의 연산은 모든 연산이 완벽히 수행되어야 하며, 한 연산이라도 실패하면 트랜잭션은 실패해야 합니다.</li>
      <li>Consistency(일관성): 트랜잭션은 유효한 상태로만 변경될 수 있습니다.</li>
      <li>Isolation(고립성): 트랜잭션은 동시에 실행될 경우 다른 트랜잭션에 의해 영향을 받지 않고 독립적으로 실행되어야 합니다.</li>
      <li>Durability(내구성): 트랜잭션이 커밋된 이후에는 시스템 오류가 발생하더라도 커밋된 상태로 유지되는 것을 보장해야 합니다. (일반적으로 비휘발성 메모리에 데이터가 저장되는 것을 의미)</li>
    </ul>
  </p>
</details>

<details>
  <summary>트랜잭션 격리 수준(Transaction Isolation Levels)에 대해서 설명해주세요.</summary>
  </br>
  <p>트랜잭션 격리수준은 고립도와 성능의 트레이드 오프를 조절합니다.</p>
  <p>
    <ul>
      <li>READ UNCOMMITTED: 다른 트랜잭션에서 커밋되지 않은 내용도 참조할 수 있다.</li>
      <li>READ COMMITTED: 다른 트랜잭션에서 커밋된 내용만 참조할 수 있다.</li>
      <li>REPEATABLE READ: 트랜잭션에 진입하기 이전에 커밋된 내용만 참조할 수 있다.</li>
      <li>SERIALIZABLE: 트랜잭션에 진입하면 락을 걸어 다른 트랜잭션이 접근하지 못하게 한다.(성능 매우 떨어짐)</li>
    </ul>
  </p>
</details>

<details>
  <summary>정규화에 대해서 설명해주세요.</summary>
  </br>
  <p>정규화는 데이터의 중복방지, 무결성을 충족시키기 위해 데이터베이스를 설계하는 것을 의미합니다.</p>
  <p>이 이상을 물어보는 경우가 있었는데, 학습이 좀 더 필요한 것 같습니다.</p>
</details>

<details>
  <summary>JOIN에 대해서 설명해주세요.</summary>
  </br>
  <p>단순히 SQL에서 JOIN 쿼리가 어떤식으로 동작하는지 알고 있어야 합니다.</p>
  <p>다이어그램으로 이해하는 편이 좋습니다.</p>
</details>

<details>
  <summary>RDBMS vs NOSQL에 대해서 설명해주세요.</summary>
  </br>
  <p>RDBMS는 데이터베이스를 이루는 객체들의 릴레이션을 통해서 데이터를 저장하는 데이터베이스입니다. SQL을 사용해 데이터의 저장, 질의, 수정, 삭제를 할 수 있으며 데이터를 효율적으로 보관하는 것을 목적으로 하고 구조화가 굉장히 중요합니다.</p>
  <p>장점으로는 명확한 데이터 구조를 보장하고, 중복을 피할 수 있습니다.</p>
  <p>NOSQL은 RDBMS에 비해 자유로운 형태로 데이터를 저장합니다. 또한 수평확장을 할 수 있고 분산처리를 지원합니다. 다양한 형태의 NOSQL 데이터베이스가 있고, 대표적으로 key-value store, bigtable, dynamo, document db, graph db 등이 있습니다.</p>
  <p>둘은 대체될 수 있는 것이 아니고, 각각 필요한 시점에 적절히 선택해서 사용해야 합니다. 둘 다 같이쓰는 상호보완적인 존재가 될 수도 있습니다.</p>
</details>

<details>
  <summary>Redis에 대해서 간단히 설명해주세요.</summary>
  </br>
  <p>Redis는 key-value store NOSQL DB입니다. 싱글스레드로 동작하며 자료구조를 지원합니다. 그리고 다양한 용도로 사용될 수 있도록 다양한 기능을 지원합니다. 데이터의 스냅샷 혹은 AOF 로그를 통해 복구가 가능해서 어느정도 영속성도 보장됩니다.</p>
  <p>스프링에서는 세션을 관리하거나, 캐싱을 하는데에 자주 사용되는 것으로 알고 있습니다.</p>
</details>

<details>
  <summary>Redis와 Memcached의 차이에 대해서 설명해주세요.</summary>
  </br>
  <p>Redis는 싱글 스레드 기반으로 동작하고, Memcached는 멀티스레드를 지원해서 멀티 프로세싱이 가능합니다.</p>
  <p>Redis는 다양한 자료구조를 지원하고, Memcached는 문자열 형태로만 저장합니다.</p>
  <p>Redis는 여러 용도로 사용할 수 있도록 다양한 기능을 지원합니다.</p>
  <p>Redis는 스냅샷, AOF 로그를 통해서 데이터 복구가 가능합니다.</p>
</details>

<details>
  <summary>Elastic Search에 대해서 간단히 설명해주세요.</summary>
  </br>
  <p>Elastic Search는 자바로 개발된 오픈소스 검색엔진 입니다. 보통 단독으로 사용하기보다는 ELK 스택이라고 부르는 Logstash, Kibana, Beats를 추가적으로 사용합니다.</p>
  <p>Inverted Index 구조로 데이터를 저장해서, 전문(Full-text) 검색시에 RDBMS에 비해 뛰어난 성능을 보장합니다.</p>
  <p>다양한 용도로 사용할 수 있습니다. (데이터 저장, 문서 검색, 위치 검색, 머신 러닝 기반 검색, 로그 분석, 보안 감사 분석 등)</p>
</details>

<details>
  <summary>Elastic Search의 인덱스구조와 RDBMS의 인덱스 구조의 차이에 대해 설명해주세요.</summary>
  </br>
  <p>Elastic Search는 Inverted-Index 구조로 데이터를 저장합니다. 이는 책의 색인을 생각해보면 쉬운데, 특정 단어가 출현하는 doc을 저장하는 것입니다. 반면 RDBMS는 B-Tree와 그와 유사한 인덱스를 사용합니다. 데이터가 어디에 존재하는지 어떤 순서로 저장하는 지의 차이라고 생각합니다. RDBMS에도 다양한 인덱스 구조가 있으나 여기서 예로 든 것은 B-Tree 인덱스입니다.</p>
</details>

<details>
  <summary>Elastic Search의 키워드 검색과 RDBMS의 LIKE 검색의 차이에 대해 설명해주세요.</summary>
  </br>
  <p>Elastic Search의 키워드 검색은 document를 저장할 때 수행하는 알고리즘과 동일한 알고리즘으로 키워드를 분리합니다. 그 중에서 랭킹알고리즘을 통해서 가장 유사한 순서대로 결과를 나타냅니다.</p>
  <p>RDBMS에서의 LIKE 검색은 와일드카드로 시작하지 않는 경우에만 인덱스를 사용하고 나머지 경우는 전체를 탐색하기 때문에 상대적으로 느립니다.</p>
</details>

<details>
  <summary>MongoDB에 대해서 간단히 설명해주세요.</summary>
  </br>
  <p></p>
</details>

<details>
  <summary>CAP 이론과, Eventual Consistency에 대해서 설명해주세요.</summary>
  </br>
  <p>CAP 이론은 분산 환경에서 모두를 만족하는 시스템은 없다는 이론입니다.</p>
  <p>
    <ul>
      <li>Consitenty(일관성): ACID의 일관성과는 약간 다릅니다. 모든 노드가 같은 시간에 같은 데이터를 보여줘야 한다는 것입니다.</li>
      <li>Availability(가용성): 모든 동작에 대한 응답이 리턴되어야 합니다.</li>
      <li>Partition Tolerance(분할 내성): 시스템 일부가 네트워크에서 연결이 끊기더라도 동작해야 합니다.</li>
    </ul>
  </p>
  <p>CAP는 해당 시스템이 이거다 하고 말하기 곤란한게 어떻게 클러스터링 하느냐에 따라 달라질 수 있습니다. 그렇기 때문에 어떤 전략을 취할 때 어떤 것을 선택했는가를 잘 알아야 합니다. (단순히 MySQL이 CA입니다. 보다는 어떤 이유로 CA인지 근거를 생각해보기) 그리고 어느정도 한계가 있는 이론이고 PACELC 이론이라고 또 있습니다.</p>
  <p>Eventual Consistency는 이 Consistency를 보장해주지 못하기 때문에 나온 개념으로, Consistency를 완전히 보장하지는 않지만, 결과적으로 언젠가는 Conssistency가 보장됨을 의미합니다.</p>
</details>

### 자료구조/알고리즘

보통의 자료구조/알고리즘적 지식은 코딩테스트로 검증합니다.  
하지만 아래의 개념을 적어도 이해는 한다고 생각하니, 혹시 모르는 부분이 있을 경우 학습을 권장합니다.

<details>
  <summary>시간 복잡도를 계산해주세요.</summary>
  </br>
  <p>코딩테스를 풀었다면 해당 코드에 대해서 시간복잡도를 물어볼 수 있습니다.</p>
  <p></p>
</details>

<details>
  <summary>배열과 링크드 리스트의 차이를 설명해주세요.</summary>
  </br>
  <p>배열은 메모리상에 순서대로 데이터를 저장합니다. 반면 링크드 리스트는 다음 데이터의 위치에 대한 포인터를 가지고 있는 구조입니다.</p>
  <p>배열은 데이터를 인덱스로 조회할 수 있기 때문에 인덱스 조회성능이 높고, 데이터가 메모리에 순서대로 저장되어 있기 때문에, 캐시의 지역성으로 인하여 비교적 빠르게 탐색을 수행할 수 있습니다.</p>
  <p>링크드 리스트는 중간에 데이터를 삽입하거나 삭제하는 것이 용이하다는 장점이 있습니다.</p>
</details>

<details>
<summary>List와 Set의 차이에 대해서 설명해주세요.</summary>
</br>
<p>List는 <b>중복</b>된 데이터를 저장하고 순서를 유지하는 선형 자료구조이고, Set은 <b>중복</b>되지 않은 데이터를 저장할 수 있고, 일반적으로 순서를 유지하지 않는 선형 자료구조입니다.(Set은 집합입니다., TreeSet과 같이 순서를 유지하는 Set도 존재합니다.) </p>
</details>

<details>
  <summary>Hash Function, HashTable에 대해서 설명해주세요.</summary>
  </br>
  <p></p>
</details>

<details>
  <summary>Stack, Queue에 대해서 설명해주세요.</summary>
  </br>
  <p><b>Stack</b></p>
  <p>스택은 선형 자료구조의 일종으로 마지막에 저장한 데이터를 가장 먼저 꺼내게 되는 LIFO(Last In First Out)방식의 자료구조 입니다. 스택의 사용 예시로는 웹 브라우저의 방문기록(뒤로가기), 실행 취소(undo) 등이 있습니다.</p>
  <p><b>Queue</b></p>
  <p>큐는 선형 자료구조의 일종으로 처음에 저장한 데이터를 가장 먼저 꺼내게 되는 FIFO(First In First Out)방식의 자료구조 입니다. 큐의 사용 예시로는 프린터의 인쇄 대기, 콜센터 고객 대기 시간 등이 있습니다.</p>
</details>

<details>
  <summary>Heap, Priority Queue에 대해서 설명해주세요.</summary>
  </br>
  <p></p>
</details>

<details>
  <summary>Tree, Binary Tree, BST, AVL Tree에 대해서 설명해주세요.</summary>
  </br>
  <p></p>
</details>

<details>
  <summary>BST의 최악의 경우의 예와 시간복잡도에 대해서 설명해주세요.</summary>
  </br>
  <p>BST가 아닌 Self-Balanced Tree를 사용하는 이유에 대해서 생각해보았다면 쉽게 답할 수 있는 문제입니다.</p>
  <p>예를들어 1부터 10까지 순차적으로 BST에 저장했다면, BST의 형태는 리스트와 같아집니다. 이 경우를 최악의 경우라고 하며 시간복잡도는 O(n)이 됩니다.</p>
</details>

<details>
  <summary>피보나치 수열을 코드로 구현하는 방법에 대해서 설명해주세요.</summary>
  </br>
  <p>질문의 의도는 피보나치 수열을 코드로 구현할 수 있는가? 만약 재귀를 사용했다면 어떤 문제가 있는가? DP를 사용할 수 있는가로 이어집니다.</p>
  <p>피보나치 수열은 보통 재귀정도로 구현할 수 있지만, 중복된 연산이 계속해서 발생하게 됩니다. 이런 중복된 연산을 메모리 등에 저장해두고 해당 결과가 존재하지 않을 때만 연산을 수행하도록 하면 보다 빠른 동작을 구현할 수 있게됩니다.</p>
</details>

<details>
  <summary>DFS, BFS에 대해서 설명해주세요.</summary>
  </br>
  <p></p>
</details>

<details>
  <summary>정렬, 탐색에 대해 설명해주세요.</summary>
  </br>
  <p></p>
</details>

### 암호학/보안(간단한 정도)

<details>
  <summary>비대칭키 암호화, 대칭키 암호화에 대해 간단히 설명해주세요.</summary>
  </br>
  <p>비대칭키 암호화란 공개키 암호화라고도 하며, 공개키는 외부에 공개되어있고, 비밀키는 내부적으로 가지고 있고 서로 각각의 키로 암호화하거나 해제할 수 있는 방식입니다. 이 방식은 대칭키를 공유하는 방식보다 비교적 안전하며, 대신 연산 성능이 떨어지는 편입니다.</p>
  <p>대칭키 암호화란 양측이 동일한 키를 가지고 있으며, 암호화와 해제에 동일한 키를 사용하는 방식입니다. 이 방식은 비밀키가 노출되는 문제가 있을 수 있으며, 연산성능은 덜 필요해 상대적으로 빠릅니다.</p>
</details>

<details>
  <summary>단방향 암호화에 대해서 간단히 설명해주세요.</summary>
  </br>
  <p>단방향 암호화는 복호화 불가능한 암호화라고 합니다. 대부분 해시 알고리즘을 이용해서 구현하며, 민감정보를 데이터베이스에 저장할 때, 해당 방식을 사용합니다.</p>
  <p>보통의 단방향 암호화는 빠른 성능을 보여, 무차별 대입 공격에 취약합니다. 따라서 이런 정보를 저장하기 위해 bcrypt와 같은 방식을 사용합니다.</p>
  <p>해시란 말에서 알 수 있듯이 충돌가능성이 있습니다. 이렇게 복호화 불가능한 암호화 방식이 위험하다는 것은 해시 충돌을 일으켰다는 말로 이해해도 됩니다.</p>
</details>

<details>
  <summary>JWT에 대해서 간단히 설명해주세요.</summary>
  </br>
  <p>JWT란 토큰 인증 방식에서 쓰이는 것이라고 볼 수 있습니다. 다른 사용으론 데이터를 공유하는데도 사용할 수 있지만 일반적으론 토큰 인증 방식에서 사용됩니다.</p>
  <p>JWT는 헤더, 페이로드, 시그니쳐로 구분됩니다. 헤더는 토큰의 타입, 암호화 알고리즘을 담고 있고, 페이로드는 토큰의 정보를 담는 부분이며, 시그니처는 토큰의 정보가 신뢰할 수 있는것인지 판단할 수 있도록 합니다.</p>
  <p>JWT는 세션 기반 인증과 주로 대비됩니다. 세션기반 인증은 서버에서 세션 정보를 관리해야하는 비용이 들게됩니다. 또한 분산환경에서도 관리하기 어렵습니다. 하지만 JWT는 그 자체로 정보를 가지고 있기 때문에 세션의 단점을 보완할 수 있습니다.</p>
  <p>JWT와 다른 토큰 기반 인증 방식을 비교하는 질문이 나온적도 있습니다.</p>
</details>

<details>
  <summary>OAuth에 대해서 간단히 설명해주세요.</summary>
  </br>
  <p>OAuth는 제3자 인증방식 입니다. 기본적으로 사용자는 서버를 신뢰할 수 없습니다. 그렇기 때문에, 민감정보를 작성하는 것을 꺼립니다. 서버측에서도 마찬가지 입니다. 사용자의 민감정보를 관리하는 것은 리소스가 필요합니다.</p>
  <p>그래서 OAuth를 사용해서 신뢰할 수 있는 서버에게 정보를 맡겨놓고 접근할 수 있는 권한을 주는 것이라고 이해하면 됩니다. 그러면 사용자 측에서는 민감정보를 굳이 입력하지 않고도 서비스를 사용할 수 있고, 서버측에서도 민감정보를 굳이 관리하지 않아도 되기 때문에 이점이라고 볼 수 있습니다.</p>
  <p>OAuth 아키텍처에 대해서 설명해주세요.</p>
</details>

<details>
  <summary>JWT와 OAuth의 차이는 무엇이 있을까요?</summary>
  </br>
</details>

<details>
  <summary>SQL Injection에 대해서 간단히 설명해주세요.</summary>
  </br>
  <p></p>
</details>

<details>
  <summary>XSS에 대해서 간단히 설명해주세요.</summary>
  </br>
  <p></p>
</details>

<details>
  <summary>CSRF에 대해서 간단히 설명해주세요.</summary>
  </br>
  <p></p>
</details>

### 컴파일러

<details>
  <summary>스크립트 언어와 컴파일 언어를 나열하고 차이점을 설명해주세요.</summary>
  </br>
  <p>스크립트 언어는 PHP, Javascript, Python이 대표적인 스크립트 언어입니다. 컴파일 언어는 C, C++, Swift, Go가 있습니다.</p>
  <p>Java는 조금 특수한 경우입니다. Java는 컴파일 시에 Java Byte Code로 컴파일 되며, 이는 JVM에서 인터프리터 방식으로 동작합니다. 하지만 JIT Compiler라는 기술과 Hotspot JVM이라는 기술의 합작으로 네이티브 언어와 유사한 수준의 퍼포먼스를 낼 수 있게 되었습니다.</p>
  <p>스크립트 언어와 컴파일 언어의 차이점은 스크립트 언어는 인터프리터라는 방식으로 한 라인 한 라인 기계어로 번역하며 실행하고, 우리가 컴파일 에러라고 부르는 문법 오류를 사전에 방지하지 못하기 때문에 주의해야 합니다. 바로바로 실행하기에는 좋기 때문에 해당 방식이 필요한 분야에 많이 사용됩니다. 컴파일 언어는 컴파일 과정을 거쳐 기계어 코드로 번역이 되기 때문에 사전에 검증을 할 수 있고, 최적화를 해줄 수 있습니다. 이것이 컴파일러가 가지는 장점입니다.</p>
</details>

## 언어 관련

### Java

### Java 장단점

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------
+ 장점
    + 운영체제에 독립적
        - JVM에서 동작하기 때문에 플랫폼에 종속적이지 않다.
    + 객체지향 언어
        - 캡슐화, 상속, 추상화, 다형성 등을 지원하여 객체 지향 프로그래밍이 가능
    + 동적 로딩을 지원
        - 애플리케이션이 실행될 때 모든 객체가 생성되지 않고, 각 객체가 필요한 시점에 클래스를 동적 로딩해서 생성된다. 또한 유지보수 시 해당 클래스만 수정하면 되기 때문에 전체 애플리케이션을 다시 컴파일할 필요가 없다. 따라서 유지보수가 쉽고 빠르다.
+ 단점
    + 비교적 느림
        - 한번의 컴파일링으로 실행 가능한 기계어가 만들어지지 않고 JVM에 의해 기계어로 번역되고 실행되는 과정을 거치기 때문에 조금 느리다.
    
</details>

-----------------------

<Br>

### OOP(객체 지향 프로그래밍) 특징

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

객체 지향 프로그래밍이란 __프로그램 구현에 필요한 객체를 파악하고 객체들 간의 상호작용을 통해 프로그램을 만드는 것__ 을 말한다.

+ 캡슐화
    - 정보 은닉 : 필요 없는 정보는 외부에서 접근하지 못하도록 제한
    - 높은 응집도, 낮은 결합도로 유연함과 유지보수성 증가
+ 추상화
    - 사물들의 공통적인 특징을 파악해서 하나의 개념(집합)으로 다루는 것    
    - 목적과 관련이 없는 부분을 제거하여 필요한 부분만을 표현하기 위한 개념
+ 상속
    - 기존 상위클래스에 근거하여 새롭게 클래스와 행위를 정의할 수 있게 도와주는 개념
+ 다형성
    - __형태가 같은데 다른 기능을 하는 것을 의미__
    - 오버라이딩, 오버로딩

</details>

-----------------------

<br>

### OOP(객체 지향 프로그래밍) SOLID 원칙

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ S : 단일 책임 원칙(Single Responsible Principle)
    - 객체는 단 하나의 책임만을 가져야한다.
    - 어떤 변화에 의해 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.
+ O : 개방 폐쇄 원칙(Open Closed Principle)
    - 기존 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계되어야 한다.
+ L : 리스코프 치환 원칙
    - 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야한다.
+ I : 인터페이스 분리 원칙
    - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
    - 인터페이스가 명확해지고, 대체 가능성이 높아진다.
+ D : 의존관계 역전 원칙 (Dependency Inversion Principle)
    - 의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운 것, 거의 변화가 없는 것에 의존하라는 것이다.
    - 쉽게 이야기하면, 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻

</details>

-----------------------

<br>

### 객체 지향 프로그래밍 vs 절차 지향 프로그래밍

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ 절차 지향 프로그래밍
    - 실행하고자 하는 절차를 정하고, 순차적으로 프로그래밍 하는 방식으로 빠르다.
    - 엄격하게 순서가 정해져 있기에 비효율적이고 유지보수가 어렵다.
    - 목적을 달성하기 위한 일의 흐름에 중점을 둔다.
+ 객체 지향 프로그래밍
    - 구현해야할 객체들 사이의 상호작용을 프로그래밍하는 방식으로 상속, 다형성, 추상화, 캡슐화를 통해 결합도를 낮추고 응집도를 높일 수 있으며 코드의 재사용성도 높일 수 있다.

</details>

-----------------------


<br>

### JVM의 구성 요소

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ 자바 프로그램을 실행하는 역할
    - 컴파일러를 통해 바이트 코드로 변환된 파일을 JVM에 로딩하여 실행
+ Class Loader : JVM 내(Runtime Data Area)로 Class 파일을 로드하고 링크
+ Execution Engine : 메모리(Runtime Data Area)에 적재된 클래스들을 기계어로 변경해 실행
+ Garbage Collector : 힙 메모리에서 참조되지 않는 개체들 제거
+ Runtime Data Area : 자바 프로그램을 실행할 때, 데이터를 저장


</details>

-----------------------

<br>


### JVM 실행과정

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

1. JVM은 OS로부터 메모리(Runtime Data Area)를 할당 받음
2. 컴파일러(javac)가 소스코드(.java)를 읽어 바이트 코드(.class)로 변환
3. Class Loader를 통해 Class파일을 JVM내 Runtime Data Area로 로딩
4. 로딩된 Class 파일을 Execution Engine을 통해 해석 및 실행


</details>

-----------------------

<br>

### JVM 메모리(Runtime Data Area) 구조

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

![그림5](https://backtony.github.io/assets/img/post/interview/gc-5.PNG)  
+ 메서드(static) 영역
    - 클래스가 사용되면 해당 클래스의 파일(.class)을 읽어들여, 클래스에 대한 정보(바이트 코드)를 메서드 영역에 저장
    - 클래스와 인터페이스, 메서드, 필드, static 변수, final 변수 등이 저장되는 영역입니다.
+ JVM 스택 영역
    - 스레드마다 존재하여 스레드가 시작할 때마다 할당
    - 지역변수, 매개변수, 연산 중 발생하는 임시 데이터 저장
    - 메서드 호출 시마다 개별적 스택 생성
+ JVM 힙 영역
    - 런타임 시 동적으로 할당하여 사용하는 영역
    - new 연산자로 생성된 객체와 배열 저장
    - 참조가 없는 객체는 GC(가비지 컬렉터)의 대상
+ pc register
    - 쓰레드가 현재 실행할 스택 프레임의 주소를 저장
+ Native Method Stack
    - C/C++ 등의 Low level 코드를 실행하는 스택

</details>

-----------------------

<br>


### 가비지 컬렉터

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

[JVM 가비지 컬렉터](https://backtony.github.io/interview/java/2021-11-30-interview-12/)

</details>

-----------------------

<br>




### 접근 제한자

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ public : 접근에 제한이 없음
+ private : 자기 자신 클래스 내에서만 접근 가능
+ default : 동일한 패키지 내에서만 접근 가능
+ protected : 동일한 패키지 내에서만 접근 가능 + 상속을 이용한 접근 가능

</details>

-----------------------

<br>

### String vs Char

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

Char은 내용물이 1개인 문자로 제한되는 반면에 String은 문자열을 담을 수 있다.  
Char의 경우 변수 안에 직접적으로 문자를 가지고 있지만 String은 reference 타입으로 실질적인 문자열이 아니라 주소값을 가지고 있다.  
이 때문에 비교 방식에 차이가 있다.  
Char의 경우 값이 같다면 ==(동일성) 비교를 사용할 수 있지만, String의 경우 내용이 같더라도 생성되는 주소가 다르기 때문에 == 비교를 사용하면 다른 결과가 나오게 되고 equals를 사용해야 한다.

</details>

-----------------------

<br>

### ==과 equals

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


+ ==
    - 참조 비교로 두 객체가 같은 메모리 공간을 가리키는지 확인
+ equals
    - 두 객체의 내부 값이 같은지 내용을 비교한다.
    - 기본 타입(Primitive Type)에 대해서는 적용할 수 없다.
    - 객체 비교시 override해서 원하는 방식으로 수정할 수 있다.


</details>

-----------------------

<br>


### 데이터 타입

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ Value Type
    - __기본 Primitive 타입으로 int, char 등이 있다.__
    - 기본 타입의 크기가 작고 고정적이기 때문에 __메모리 Stack 영역__ 에 저장된다.
    - 정수형 : byte, short, int, long
    - 실수형 : float, double
    - 논리형 : boolean
    - 문자형 : char
+ 참조 타입(Reference Type)
    - __기본형을 제외하고는 모두 참조형이다.__
    - String과 박싱 타입인 Integer 등이 있다.
    - 참조 타입은 데이터의 크기가 가변적이고, 동적이므로 __Heap 영역__ 에서 관리된다.
    - __데이터는 Heap 영역에서 관리되지만 메모리의 주소값은 Stack 영역에 담긴다.__
    - new 키워드를 이용해 객체를 생성하여 데이터가 생성된 __주소를 참조하는 타입__     
    - String과 배열은 일반적인 참조 타입과 달리 new 없이 생성 가능하지만 참조타입이다.
    - 더이상 참조하는 변수가 없을 때 GC에 의해 삭제된다.


</details>

-----------------------

<br>


### Call By Value와 Call By Reference

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------
+ Call By Value(값에 의한 호출)
    - 함수 호출 시 인자로 전달되는 __변수의 값을 복사하여 함수의 인자로 전달__ 한다.
    - 따라서, __함수 안에서 인자의 값이 변경되어도, 외부의 변수의 값은 변경되지 않는다.__
+ Call by Reference(참조에 의한 호출)
    - __함수 호출 시 인자로 전달되는 변수의 레퍼런스를 전달한다.__
    - 따라서 __함수 안에서 인자의 값이 변경되면, 인자로 전달된 변수의 값도 함께 변경된다.__

자바는 새롭게 지역 변수(다른 주소)를 만들어서 값만 복사하고 할당한다. 따라서 자바는 Call By Value에 해당한다.  

</details>

-----------------------

<br>


### hashcode

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

__두 객체가 동일한 객체인지 비교할 때 사용하고 heap 영역에 저장된 객체의 메모리 주소를 반환한다.__

</details>

-----------------------

<br>

### Wrapper class

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

프로그램에 따라 기본 타입의 데이터를 객체로 취급해야하는 경우가 있다.  
예를 들어, 메서드의 인수로 객체 타입만이 요구된다면, 기본 타입의 데이터를 그대로 사용할 수는 없다.  
이때 기본 타입의 데이터를 먼저 객체로 변환 후 작업을 수행해야 한다.  
__래퍼 클래스(Wrapper class)는 산술 연산을 위해 정의된 클래스가 아니므로, 인스턴스에 저장된 값을 변경할 수 없다.__  

기본 타입|래퍼 클래스
---|---
byte|Byte
short|Short
int|Integer
long|Long
float|Float
double|Double
char|Character
boolean|Boolean

래퍼 클래스는 각각 타입에 해당하는 데이터를 인수로 전달받아, 해당 값을 가지는 객체로 만들어준다.  


</details>

-----------------------

<br>


### 박싱, 언방식

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


래퍼 클래스는 산술 연산을 위해 정의된 클래스가 아니므로, __인스턴스에 저장된 값을 변경할 수 없다.__  
단지, 값을 참조하기 위해 새로운 인스턴스를 생성하고, 생성된 인스턴스의 값만을 참조할 수 있다.  
기본 타입을 래퍼클래스의 인스턴스로 변환하는 과정을 __박싱__, 래퍼클래스의 인스턴스에 저장된 값을 다시 기본 타입으로 꺼내는 과정은 __언방식__ 이라고 한다.
```java
Integer num = new Integer(17); // 박싱
int n = num.intValue();        // 언박싱
System.out.println(n); // 출력 값: 17


Character ch = 'X'; // Character ch = new Character('X'); : 오토박싱
char c = ch;        // char c = ch.charValue();           : 오토언박싱
System.out.println(c); // 출력 값: X
```
JDK1.5 부터는 위와 같이 자바 컴파일러가 알아서 언방식, 박싱 작업을 해준다.  

<br>

```java
public class Wrapper03 {
    public static void main(String[] args) {
      Integer num1 = new Integer(10);
      Integer num2 = new Integer(20);
      Integer num3 = new Integer(10);

      System.out.println(num1 < num2);       // true
      System.out.println(num1 == num3);      // false
      System.out.println(num1.equals(num3)); // true
    }
}
```
래퍼 클래스를 비교할 때는 ==를 사용하면 안되고, __equals 메서드를 사용해야 한다.__  
래퍼 클래스는 객체 이므로 주소값 비교가 아니라 내부 값을 비교하는 equals를 써야한다.  


</details>

-----------------------

<br>


### non-static vs static

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


+ non-static
    - 공간적 특성
        - 객체마다 별도고 존재하고 인스턴스 변수라고 부른다.
    - 시간적 특성
        - 객체와 생명주기가 동일하다.
+ static
    - 공간적 특성
        - __클래스당 하나만 생성된다.__
        - __동일한 클래스의 모든 객체들에 의해 공유된다.__
    - 시간적 특성
        - 객체가 생기기 전에 이미 생성되어 객체를 생성하지 않아도 사용 가능하다.
        - 객체가 사라져도 사라지지 않는다.
        - 프로그램 종료시에 사라진다.

</details>

-----------------------

<br>


### main이 static인 이유

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

__static 멤버는 프로그램 시작 시(클래스 로딩) 메모리에 로드되어 인스턴스를 생성하지 않아도 호출이 가능하기 때문이다.__  
+ 실행 과정
    - 코드를 실행하면 컴파일러가 .java를 .class 바이트 코드로 변환
    - 클래스 로더가 .class 파일을 메모리 영역에 로드
    - Runetime Data Area 중 Method Area(=Class area, Static area)라고 불리는 영역에 Class Variable이 저장되는데, static 변수도 여기에 포함
    - JVM은 Method Area에 로드된 main()을 싱행

</details>

-----------------------

<br>


### final vs finally vs finalize

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ final 키워드
    - 변수, 메서드 클래스가 __변경 불가능__ 하도록 만든다.
    - 기본 타입 변수에 적용 시
        - 해당 변수의 값 변경 불가능하다.
    - 참조 변수에 적용 시
        - 참조 변수가 힙 내의 다른 객체를 가리키도록 변경할 수 없다.
    - 메서드에 적용 시
        - 해당 메서드를 오버라이드할 수 없다.(오버로딩은 가능)
    - 클래스에 적용 시        
        - 해당 클래스를 상속 받아서 사용할 수 없다.
+ finally 키워드
    - try catch 블록 뒤에서 항상 실행될 코드 블록을 정의하기 위해 사용한다.
+ finalize 메서드
    - 가비지 컬렉터가 더 이상의 참조가 존재하지 않는 객체를 메모리에서 삭제하겠다고 결정하는 순간 호출된다.

</details>

-----------------------

<br>

### try with resources 

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

자바 7 이전에는 try-catch-finally에서는 리로스의 생성을 try 구문에서 리소스의 반납은 finally 구문에서 하다보니 실수의 발생 여지가 있었다.  
자바 7 이후에는 try with resources 구문이 나오게 됬는데 try 옆 괄호 안에서 리소스를 생성해주면 따로 반납하지 않아도 리로스를 자동으로 반납해주게 된다.  
아래와 같이 작성한 것이 try with resources 구문이고, 만약 try-catch-finally를 사용했다면 finally 구문에서 scanner을 close하는 내용이 있어야 한다.
```java
public class ResourceClose {
    public static void main(String[] args) {
        try (Scanner scanner = new Scanner(new File("input.txt"))) {
            System.out.println(scanner.nextLine());
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
    }
}
```


</details>

-----------------------

<br>


### 제네릭

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ 클래스나 메서드에서 사용할 내부 데이터 타입을 외부에서 지정하는 기법
+ 잘못된 타입이 들어올 수 있는 것을 컴파일 단계에서 방지할 수 있다.
+ 불필요한 타입 변환을 제거할 수 있다.

</details>

-----------------------

<br>
    
    
### 직렬화와 역직렬화

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ 직렬화
    - __자바 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 바이트 형태로 데이터를 변환하는 기술__
    - 조건
        - 자바 기본 타입
        - Serializable 인터페이스 상속받은 객체
    - ObjectOutputStream 객체를 이용
+ 역직렬화
    - 바이트로 변환된 데이터를 다시 객체로 변환하는 기술
    - ObjectInputStream 객체를 이용

</details>

-----------------------

<br>





### 오버로딩, 오버라이딩

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ 오버로딩
    - 두 메서드가 같은 이름을 갖고 있으나 인자의 수나 자료형이 다른 경우
+ 오버라이딩
    - 하위 클래스에서 상위 클래스의 메서드와 일치하는 함수를 재정의하는 것

</details>

-----------------------

<br>



### 추상 클래스와 인터페이스 차이

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ 추상 메서드
    - abstract 키워드와 함께 원형만 선언되고 코드는 작성하지 않은 메서드
+ 추상 클래스
    - 개념 : abstract 키워드로 선언된 클래스
        - 추상 메서드가 최소 한 개 이상을 가진 abstract 클래스
        - 추상 메서드 이외의 다른 것들도 추가 가능
    - 목적
        - __관련성이 높은 클래스 간의 코드를 공유하고 확장하고 싶은 목적__
+ 인터페이스
    - 개념 : default와 static 을 제외하고는 추상 메서드와 상수만을 포함하여, interface 키워드를 사용하여 선언
        - 모든 메서드는 추상 메서드로, abstract public이 생략되어 있다.
        - 상수 필드는 public static final이 생략되어 있다.
        - 다중상속이 가능하다.
    - 목적
        - __관련성이 없는 클래스들의 논리적으로 같은 기능을 자신에 맞게 구현을 강제하는데 목적__ 

정리하자면, 구조상 차이로 추상 클래스는 abstract 키워드가 붙고 추상 메서드뿐만 아니라 다른 변수, 메서드도 선언이 가능하고, 인터페이스는 추상 메서드와 상수만 선언 가능하다.(자바 8부터는 default 메서드 선언 가능)  
목적의 차이로 추상 클래스는 관련성이 높은 클래스 간의 코드 공유(재사용)와 확장을 목적으로 하고, 인터페이스는 관련성이 없는 클래스들의 같은 기능을 자신에 맞게 구현하는데 목적이 있다.  

</details>

-----------------------

<br>

### Error, Exception



<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

![그림3](https://backtony.github.io/assets/img/post/interview/java-3.PNG)  

목록|Error|Exception
---|---|---
패키지|java.lang.error|java.lang.exception
발생 시점|런타임에서 발생, 컴파일 시점에서 알 수 없다.|Checked Exception은 컴파일 시점에, Unchcked Exception은 런티림 시점에 알 수 있다.
복구|에러는 복구 불가능|try catch 블락을 이용하여 복구 가능
타입|모든 Error는 Unchecked Type|checked Type, Unchecked Type으로 분류
예시|OutOfMemory, StackOverFlow|아래서 설명


</details>

-----------------------

<br>


### Checked Exception, Unchecked Exception


<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


구분|Checked Exception|Unchecked Exception
---|---|---
상속|RuntimeException 상속 X| RuntimeException 상속
확인 시점|컴파일 시점|런타임 시점
처리 여부|반드시 예외처리|명시적으로 하지 않아도 됨
트랜잭션 처리|예외 발생시 롤백 X|예외 발생시 롤백 해야함
종류|IOException,SQLException..|NullPointException,ArrayIndexOutOfBounds...

대부분 Checked Exception보다는 Unchecked Exception 사용을 권장한다.  
Checked Exception의 경우 사용하는 모든 곳에 throws를 남겨야하는데 이 문제는 의존성 문제를 야기한다.  
예를 들어 가장 하위에서 SQLException(Checked Exception)를 던진다고 해보자.  
그럼 상위 서비스, 컨트롤러도 SQLException을 처리하기 위해서 throws SQLException을 붙이게 된다.  
SQLException은 JDBC 기술이므로 service, controller는 JDBC에 의존하게 된다.  
결국 JDBC 기술을 다른 기술로 교체하게 되면 연결된 모든 것들을 전부 교체해야하는 문제가 생긴다.  

</details>

-----------------------

<br>

### Java Collections

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

![그림1](https://backtony.github.io/assets/img/post/interview/java-1.PNG)  
__Set과 List는 Collection 인터페이스를 구현하고 있고 Map은 인터페이스를 구현하고 있지 않다.__
+ Map   
    - Key와 Value의 형태로 이루어진 데이터 집합
    - 순서를 보장하지 않는다.
    - Key는 중복이 허용되지 않고, Value는 중복을 허용한다.
+ Collection을 상속한 것들
    - List
        - 순서가 있는 데이터 집합
        - 데이터를 중복해서 포함시킬 수 있다.
    - Set
        - 데이터의 중복을 허용하지 않는 데이터 집합
        - 순서를 보장하지 않는다.
        - Value의 중복을 허용하지 않는다.


<br>

![그림2](https://backtony.github.io/assets/img/post/interview/java-2.PNG)  
Collection 인터페이스 위에는 Iterable이라는 인터페이스가 있고 이 인터페이스는 iterator 라는 추상 메서드를 갖고 있다. 



</details>

-----------------------

<br>


#### Map

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


+ HashMap    
    - 내부 hash값에 따라 키순서가 정해지므로 특정 규칙없이 출력된다.
    - key와 value에 __null값을 허용__ 한다.
    - 비동기 처리
+ LinkedHashMap    
    - 입력 순서대로 출력된다.
    - 비동기 처리
+ TreeMap
    - 내부적으로 __레드-블랙 트리(균형 이진 탐색 트리)__ 로 저장된다.
    - __Null값 비허용__
    - 키값이 기본적으로 __오름차순 정렬__ 되어 출력된다.
    - Compartor 구현으로 정렬 방법을 지정할 수 있다.
+ ConCurrentHashMap
    - key,value에 null값 비허용
    - __쓰기작업에서만 동기 처리__
+ HashTable
    - key,value에 null값 비허용
    - __모든 작업에 동기 처리__

</details>

-----------------------

<br>


#### Set

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ HashSet
    - 저장 순서를 유지하지 않는 데이터의 집합
    - Null 저장 가능
    - 해시 알고리즘을 사용하여 검색속도가 매우 빠르다.
    - 내부적으로 HashMap 인스턴스를 이용하여 요소를 저장한다.
+ LinkedHashSet
    - 저장 순서를 유지하는 HashSet
+ TreeSet
    - 데이터가 정렬된 상태로 저장되는 이진 탐색 트리의 형태로 요소를 저장한다.
    - __Null 저장 불가능__
    - __레드 블랙 트리(균형 이진 탐색 트리)__ 로 구현되어 있다.
    - Compartor 구현으로 정렬 방법을 지정할 수 있다.

</details>

-----------------------

<br>


#### List


<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ ArrayList
    - 내부적으로 배열을 사용하는 자료구조로 메모리가 연속적으로 배치된다.
    - 배열과 달리 메모리 할당이 동적이다.
    - 데이터 삽입, 삭제 시 해당 데이터 이후 모든 데이터가 복사되므로 빈번한 삭제, 삽입이 일어나는 경우에는 부적합하다.
    - 검색의 경우는 인덱스의 데이터를 가져오면 되므로 빠르다.
    - __재할당 시 크기의 절반씩 증가한다.__
+ LinkedList
    - 양방향 포인터 구조로 각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식으로 데이터를 저장하는 자료 구조
    - 데이터의 삽입, 삭제 시 해당 노드의 주소지만 바꾸면 되므로 삽입, 삭제가 빈번한 데이터에 적합하다.
    - 메모리가 불연속적이다.
    - 데이터 검색 시 처음부터 순회하므로 검색에는 부적합하다.
    - 스택, 큐, 양방향 큐를 만들기 위한 용도로 사용한다.
    - 양옆의 정보만을 갖고 있기 때문에 순차적으로 검색을 진행하여 검색 속도가 느리다.
+ Vector
    - 내부에서 자동으로 동기처리가 일어난다.
    - 성능이 좋지 않아 잘 사용하지 않는다.
    - __재할당 시 크기의 두 배로 증가한다.__
+ Stack
    - new 키워드로 직접 사용 가능
    - Vector를 상속받아 동기 처리


#### cf) 배열과 리스트는 다른 것
+ 배열(Array)은 크기가 고정적이라 선언 시 지정한 크기를 변경할 수 없다.(Immutable)


</details>

-----------------------

<br>


### String, StringBuilder, StringBuffer


<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ String
    - __새로운 값을 할당할 때마다 새로운 클래스에 대한 객체가 생성__
    - String에 저장되는 문자열은 private final char[] 형태이므로 변경할 수 없다.
    - String + String + String..
        - 가비지 컬렉터가 호출되기 전까지 생성된 String 객체들은 Heap에 머물기 때문에 메모리 관리에서 치명적이다.
+ StringBuilder
    - 메모리에 append하는 방식으로 클래스에 대한 객체를 생성하지 않는다.
    - 비동기 처리
+ StringBuffer
    - 메모리에 append하는 방식으로 클래스에 대한 객체를 생성하지 않는다.
    - 동기 처리

</details>

-----------------------

<br>



### String new와 ""의 차이

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

new 는 계속 새로운 객체를 생성해내는 반면에 ""의 경우는 이미 존재하는 String 값이라면 같은 래퍼런스를 참조한다.  

</details>

-----------------------

<br>



### Blocking vs Non-Blocking

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

두 가지의 차이점은 __다른 주체가 작업할 때 자신이 코드를 실행할 제어권이 있는지 없는지로 판단__ 할 수 있다.  

### Blocking
![그림1](https://backtony.github.io/assets/img/post/interview/block-1.PNG)  
Blocking 자신의 작업을 진행하다가 다른 주체의 작업이 시작되면 __제어권을 다른 주체로 넘긴다.__  
따라서 자신은 제어권이 없기 때문에 실행할 수 없고, 다른 주체가 실행을 완료하고 제어권을 돌려줄 때까지 아무 작업도 할 수 없다.  

### Non-Blocking
![그림2](https://backtony.github.io/assets/img/post/interview/block-2.PNG)  
Non-Blocking은 다른 주체의 작업에 __관련없이 자신이 제어권을 갖고 있다.__  
따라서, 자신은 계속 작업을 수행할 수 있다.  

</details>

-----------------------

<br>

### Sync vs Async

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

두 가지의 차이점은 __호출하는 함수가 호출되는 함수의 작업 완료 여부를 신경쓰는지 여부__ 에 차이가 있다.  

+ Sync(동기)
    - 동기는 함수 A가 B를 호출한 뒤, B의 결과값이 나오면 해당 결과값을 가지고 바로 처리하는 방식이다.
+ Async(비동기)
    - 비동기는 함수 A가 B를 호출한 뒤, B의 결과값에 큰 비중을 두지 않고 결과가 나오면 처리를 할 수도 있고 안 할 수도 있다.

</details>

-----------------------

<br>


### 리플렉션


<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


+ __런타임 상황에서 메모리에 올라간 클래스나 메서드등의 정의를 동적으로 찾아서 조작할 수 있는 기술__
+ 컴파일 시간이 아닐 실행 시간에 동적으로 특정 클래스의 정보를 객체화를 통해 분석 및 추출해낼 수 있는 프로그래밍 기법이다.
+ 자바에서 이미 로딩이 완료된 클래스에서 또 다른 클래스를 동적으로 로딩하여 생성자, 필드, 메서드 등을 사용할 수 있는 방식이다.  
+ 장점
    - 런타임 시점에 사용할 instance를 선택하고 동작시킬 수 있는 유연한 기능을 제공한다.
+ 단점
    - __컴파일 시점이 아니라 런타임 시점에서 오류를 잡기 때문에 컴파일 시점에 확인할 수 없다.__
    - 접근 제어자로 캡슐화된 필드, 메서드에 접근 가능해지므로 기존 동작을 무시하고 깨뜨리는 행위가 가능해진다.    
    - 위와 같은 단점 때문에 피할 수 있다면 사용을 자제하는 것이 좋다.
+ 사용처
    + 런타임 시점에 다른 클래스를 동적으로 로딩하여 접근할 때 사용
    + 클래스와 멤버 필드, 메서드 등에 관한 정보를 얻어야 할 때 사용

</details>

-----------------------

<br>


### Stream


<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ java 8 에서 추가된 API
+ 컬렉션 타입의 데이터를 Stream 메서드로 내부 반복을 통해 정렬, 필터링 등이 가능
+ 특징
    - parallel 메서드 제공을 통해 __병렬처리__ 가 가능
        - 각 스레드가 개별 큐를 가지고 있으며, 놀고 있는 스레드가 있으면 일하는 스레드의 작업을 가져와 수행
    - __데이터를 변경하지 않는다(Immutable)__
        - 원본데이터로부터 데이터를 읽기만 할 뿐, 원본데이터 자체를 변경하지 않는다.
    - 작업을 내부 반복으로 처리하므로 불필요한 코딩을 줄일 수 있다.
    - 최종 연산 후 stream이 닫히므로 __일회용__ 이다.
+ 구조
    - Stream 생성
    - 중간 연산
        - __데이터를 가공하는 과정에 해당한다.__
        - 필터링 : filter, distinct
        - 변환 : map, flatMap
        - 제한 : limit, skip
        - 정렬 : sorted
        - 연산결과확인 : peek
    - 최종 연산
        - __Stream 안의 데이터를 모아 반환하는 역할을 한다.__
        - 출력 : foreach
        - 소모 : reduce
        - 검색 : findFirst, findAny
        - 검사 : anyMatch, allMatch, noneMatch
        - 통계 : count, min, max
        - 연산 : sum, savage
        - 수집 : collect
+ __중간 연산 작업은 바로 실행되는 것이 아니라 종결 처리의 실행이 필요할 때서야 비로소 중간 처리가 실행된다.(Lazy Evalutation)__
+ ParallelStream
    - 개발자가 직접 스레드 혹은 스레드 풀을 생성하거나 관리할 필요 없이 parallelStream, parallel()만 사용하면 알아서 내부적으로 common __ForkJoinPool__ 을 사용하여 작접들을 분할하고 병렬적으로 처리한다.
        - __forkJoinPool은 ExecutorService의 구현체로 각 스레드별 개별 큐를 가지고 스레드에 아무런 task가 없으면 다른 스레드의 task를 가져와 처리하여 최적화 성능을 낼 수 있다는 특징이 있다.__
    - __내부적으로 스레드 풀을 만들어서 작업을 병렬화시킨다.__
    - __중요한 점은 parallelStream 각각 스레드 풀을 만드는게 아니라 별도의 설정이 없다면 하나의 스레드 풀을 모든 parallelStream이 공유한다.__
    - ParallelStream은 중간 연산에서 순서가 보장되지 않기 때문에 중간 연산에서 순서에 관계없는 연산의 경우에만 사용한다.
    - Parallel Stream은 작업을 분할하기 위해 Spliterator의 trySplit()을 사용하게 되는데, 이 분할되는 작업의 단위가 균등하게 나누어져야 하며, 나누어지는 작업에 대한 비용이 높지 않아야 순차적 방식보다 효율적으로 이뤄질 수 있다. array, arrayList와 같이 정확한 전체 사이즈를 알 수 있는 경우에는 분할 처리가 빠르고 비용이 적게 들지만, LinkedList의 경우라면 별다른 효과를 찾기 어렵다.


</details>

-----------------------

<br>


### Fork Join Pool

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

![그림4](https://backtony.github.io/assets/img/post/interview/java-4.PNG)  
Java7에서 새로 지원하는 fork-join 풀을 기본적으로 큰 업무를 작은 업무로 나눠 배분하여, 일을 한 후에 일을 취합하는 형태이다.  
분할 정복 알고리즘과 비슷하다고 보면 된다.  
자바에서 풀을 관리하는 ThreadPoolExecutor와 마찬가지로 ForJoinPool도 내부에 inbound queue 라는 편지함이 하나 있다.  
그걸 두고 싸우느라 시간을 낭비하는 것을 방지하기 위해 ForkJoinPool은 스레드 개별 큐를 만들었다.  
<br>


![그림5](https://backtony.github.io/assets/img/post/interview/java-5.PNG)  
왼쪽에서 업무를 submit하면 하나의 inbound queue에 누적되고 그걸 A와 B 스레드가 가져다가 일을 처리한다.  
A와 B는 각자 큐가 있으며, 자신의 큐에 업무가 없으면 상대방의 큐에서 업무를 가져와서 처리한다.  
최대한 노는 스레드가 없게 하기 위한 알고리즘이다.  

</details>

-----------------------

<br>

### 람다식

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ 자바 8에서 등장
+ __메서드를 하나의 식으로 표현하는 익명 함수__
+ 인터페이스 내에 한 개의 추상 메서드만 정의되어있는 함수형(Function) 인터페이스에 사용 가능
+ 장점
    - 기존에 익명함수로 작성하던 코드를 줄일 수 있음
    - 가독성 증가
    - 병렬 프로그래밍이 용이하다.

</details>

-----------------------

<br>



### Optional

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ T orElse(T other)
    - 반환할 값을 그대로 받는다.
    - __무조건 인스턴스화 된다.__
+ T orElseGet(Supplier<? extends T> other)
    - Supplier로 랩핑된 값을 인자로 받는다.
    - 함수를 전달받아 바로 값을 가져오지 않고 필요할 때(Lazy) 값을 가져온다.
    - __Optional 안의 값이 null일 경우에만 함수가 실행되면서 인스턴스화 된다.__

</details>

-----------------------

<br>



### 자바8 추가된 내용

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ optional
+ stream
+ lambda
+ localDateTime
+ default 메서드
    - 인터페이스는 메서드 정의만 가능하고 구현은 불가능했는데 default 메서드 개념이 생기면서 인터페이스에 구현된 메서드도 추가가 가능해졌다.

__cf) 기존 date의 문제점__  
+ 불변 객체가 아님
+ 헷갈리는 월 지정(1월을 0으로 표현)
+ 일관성 없는 요일 상수 (어디서는 일요일이 0 어디서는 1)
+ Date와 Calendar 객체의 역할 분담(Date만으로 부족해서 왔다갔다 해야함)
+ 상수 필드 남용

</details>

-----------------------

<br>



### Java 8 -> Java 11

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------
+ __default GC가 Paralle GC에서 G1GC로 변경__
+ strip(), stripLeading(), stripTrailing(), isBlank(), repeat(n) 과 같은 __String 클래스에 새로운 메서드 추가__
+ writeString, readString, isSameFile 과 같은 __File관련 새로운 메서드 추가__
+ 컬렉션의 toArray() 메서드를 오버로딩하는 메서드가 추가되어 원하는 타입의 배열을 선택하여 반환할 수 있게 되었다.
    - sampleList.toArray(String[]::new)
+ Predicate 인터페이스에 부정을 나타내는 not() 메서드 추가
+ __람다에서 로컬 변수 var이 사용 가능__
+ Javac를 통해 컴파일하지 않고도 바로 java 파일을 실행할 수 있게 되었다.

</details>

-----------------------

<br>


### 함수형 프로그래밍

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

함수형 프로그래밍은 거의 모든 것을 순수 함수로 나누어 문제를 해결하는 기법으로, 작은 문제를 해결하기 위한 함수를 작성하여 가독성을 높이고 유지보수를 용이하게 해준다.  
Robert C.Martin은 __함수형 프로그래밍을 대입문이 없는 프로그래밍__ 이라고 정의하였다.  
명령형 프로그래밍에서는 메소드를 호출하면 상황에 따라 내부의 값이 바뀔 수 있다. 즉, 우리가 개발한 함수 내에서 선언된 변수의 메모리에 할당된 값이 바뀌는 등의 변화가 발생할 수 있다.  
하지만 함수형 프로그래밍에서는 대입문이 없기 때문에 메모리에 한 번 할당된 값은 새로운 값으로 변할 수 없다.  

+ 순수함수 : 같은 인자에 대해서 항상 같은 값을 반환하고 외부의 어떤 상태도 바꾸지 않는 함수
+ 일급객체 : 함수의 인자로 전달할 수 있고, 함수의 반환값으로 사용할 수 있고, 변수에 담을 수 있는 객체
+ 일급함수 : 함수가 일급객체면 일급함수라고 하고 일급함수에 이름이 없다면 람다식이라고 한다.

### 특징
부수 효과가 없는 순수 함수를 __1급 객체__ 로 간주하여 파라미터로 넘기거나 반환값으로 사용할 수 있으며, 참조 투명성을 지킬 수 있다.  

+ 사이드 이팩트가 없다.
    - 함수형 프로그래밍은 함수들의 조합으로 만들어지며, 각 함수들은 인자를 받고 그에 따른 결과를 내놓을 뿐 함수 내부적으로 어떠한 상태도 가지지 않는다. 따라서 함수 내부에서 벌어지는 일에 대해서는 전혀 신경쓸 필요가 없다. 단지, 함수 호출 시 입력하는 값과 그에 대한 결과 값만이 중요할 뿐이다.
+ 동시성 프로그래밍
    - 명령형 프로그래밍에서 교착상태가 발생하는 주된 원인은 스레드 간에 공유되는 데이터나 상태 값이 변경 가능(mutable)하기 때문이다. 하지만 함수형 프로그래밍은 모든 데이터가 변경 불가능하고 함수는 부수 효과를 가지고 있지 않기 때문에 여러 스레드가 동시에 공유 데이터에 접근하더라도 해당 데이터가 변경될 수 없기 때문에 동시성 관련된 문제를 원천적으로 봉쇄한다.
+ 함수를 값처럼 쓸 수 있기 때문에 익명함수처럼 간결한 코드를 구성할 수 있다.

### 단점
+ 순수함수를 구현하기 위해서 코드의 가독성이 좋지 않을 수 있다.
+ 순수함수를 사용하는 것은 쉬울지라도 조합하는 것은 쉽지 않다.


</details>

-----------------------

<br>


### 멀티스레드 프로그래밍

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ 스레드 생성 방법
    - 방법 1: Thread 클래스를 상속받아서 run을 오버라이드해서 정의한다.
    - 방법 2: Runnable 인터페이스를 구현하여 Thread 생성자에 인자로 넘긴다.
    - 방법 3: Callable 인터페이스를 구현하여 FutureTask에 한번 감싸서 Thread의 인자로 넘긴다.
    - __Runnable은 Exception이 없고 리턴값도 없으나 Callable은 리턴값이 있고 Exception을 발생시킬 수 있다.__    
+ 스레드 실행 방법
    - 보통 start() 메서드를 사용해서 호출하는데 start 한다고 해서 바로 실행되는 것은 아니고 실행 대기열에 저장된 후 차례가 오면 실행된다.
    - 정확하게 말하자면, start는 새로운 스레드가 작업을 실행하는데 필요한 새로운 호출 스택을 생성해서 그곳에 run 메서드를 올려둔다. 이후 그곳에서 run 메서드를 호출하고 스레드가 별개의 작업을 수행하게 된다.

__보통 위와 같이 인터페이스를 구현해서 Thread의 인자로 넘기거나, 상속으로 구현하는 방식은 운영환경에서 프로그램 성능에 영향을 미치기 때문에 사용하지 않는다.__  
운영 시에는 __ExecutorService와 Executors를 이용해 스레드풀을 생성__ 하여 병렬처리한다.  
앞선 방식은 각기 다른 Thread를 생성해서 작업 처리하고 처리가 완료되면 Thread를 제거하는 작업을 손수 진행해야 하지만 ExecutorService 클래스를 사용하면 손쉽게 처리할 수 있다.  
ExecutorService에 Task만 지정해주면 알아서 ThreadPool을 이용해 Task를 실행하고 관리한다.  
Executors는 ExecutorService 객체를 생성하며 다음과 같은 메서드를 제공하여 스레드 풀의 개수 및 종류를 정할 수 있다.
```java
// 인자 개수만큼 고정된 스레드를 생성하는 스레드 풀
ExecutorService executor = Executors.newFixedThreadPool(int n);

// 필요할 때 필요한 만큼 스레드를 무한정 생성하고 60초간 작업이 없다면 pool에서 제거하는 스레드풀
ExecutorService executor = Executors.newCachedThreadPool();

// 스레드 1개인 ExecutorService 리턴
ExecutorService executor = Executors.newSingleThreadExecutor();

// 일정 시간 뒤에 실행되는 작업이나, 주기적으로 수행되는 작업이 있다면 사용하는 것
ExecutorService executor = Executors.newScheduledThreadPool(int n);
```
</details>

-----------------------

<br>

### Java 동기화

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

자바에서 동시성 문제를 해결하는데 3가지 방법이 있습니다.  
+ synchronized : 안전하게 동시성을 보장할 수 있습니다. 하지만 비용이 가장 큽니다.
+ volatile : 키워드가 붙은 자원은 하나의 thread만이 write하고 나머지는 스레드는 read만 한다는 전제하에만 동시성을 보장합니다.
    - __volatile 키워드를 붙인 자원은 read, write 작업이 CPU Cache Memory가 아닌 Main Memory에서 이뤄집니다.__
    - 즉, 자원을 저장하는 메모리는 하나가 되기 때문에 같은 공유자원에 대해 각각 메모리별로 다른 값을 가지는 경우가 없습니다. 
    - 하지만 여러 스레드에서 Main Memory에 있는 공유자원에 동시에 접근할 수 있으므로 여러 스레드에서 수정하게 되면, 계산값이 덮어씌워지게 되므로 동시 접근 문제를 해결할 수 없습니다.
    - __정리하면, 가시성 문제는 해결할 수 있지만, 동시 접근 문제는 해결할 수 없습니다.__
+ Atomic 클래스는 CAS(compare-and-swap)를 이용하여 동시성을 하므로 여러 쓰레드에서 데이터를 write해도 문제가 없습니다. synchronized 보다 적은 비용으로 동시성을 보장할 수 있습니다.
    - __CAS 알고리즘이란 현재 스레드가 존재하는 CPU의 CacheMemory와 MainMemory에 저장된 값을 비교하여, 일치하는 경우 새로운 값으로 교체하고, 일치하지 않을 경우 기존 교체가 실패되고, 이에 대해 계속 재시도하는 방식입니다.__
    - __CPU가 MainMemory의 자원을 CPU Cache Memory로 가져와 연산을 수행하는 동안 다른 스레드에서 연산이 수행되어 MainMemory의 자원 값이 바뀌었을 경우 기존 연산을 실패처리하고, 새로 바뀐 MainMemory 값으로 재수행하는 방식입니다.__


</details>

-----------------------

<br>


### Synchronized와 Lock & Condition 동기화

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


[synchronized 동기화](https://backtony.github.io/java/2022-05-04-java-50/)


</details>

-----------------------

<br>

### Atomic 동기화

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

[동시성 이슈와 Atomic 사용법](https://backtony.github.io/java/2022-05-27-java-51/)

</details>

-----------------------

<br>

<details>
  <summary>JVM의 구조와 Java의 실행방식을 설명해주세요.</summary>
  </br>
  <p>자바 가상 머신의 약자를 따서 줄여 부르는 용어로 JVM의 역할은 자바 애플리케이션을 클래스 로더를 통해 읽어 자바 API와 함께 실행하는 것입니다. 메모리 관리(GC)을 수행하며 스택기반의 가상머신입니다.</p>
  <p>JVM의 구조는 Class Loader, Execution engine, Runtime Data Area, JNI, Native Method Library로 이루어져 있습니다.</p>
  <ul>
    <li>클래스 로더: JVM내로 클래스를 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈</li>
    <li>실행 엔진: 바이트 코드를 실행시키는 역할</li>
    <ul>
      <li>인터프리터: 바이트 코드를 한줄 씩 실행합니다.</li>
      <li>JIT 컴파일러: 인터피르터 효율을 높이기 위한 컴파일러로 인터프리터가 반복되는 코드를 발견하면 JIT 컴파일러가 반복되는 코드를 네이티브 코드로 바꿔줍니다. 그 다음부터 인터프리터는 네이티브 코드로 컴파일된 코드를 바로 사용합니다.</li>
      <li>GC(Garbage Collector): 가비지 컬렉터로 힙 영역에서 사용되지 않는 객체들을 제거하는 작업을 의미합니다.</li>
    </ul>
    <li>Runtime Data Areas: 프로그램 실행 중에 사용되는 다양한 영역입니다.</li>
    <ul>
      <li>PC Register: Thread가 시작될 때 생성되며 현재 수행 중인 JVM 명령의 주소를 갖고 있습니다.</li>
      <li>Stack Area: 지역 변수, 파라미터 등이 생성되는 영역. 실제 객체는 Heap에 할당되고 해당 레퍼런스만 Stack에 저장됩니다.</li>
      <li>Heap Area: 동적으로 생성된 오브젝트와 배열이 저장되는 곳으로 GC의 대상 영역입니다.</li>
      <li>Method Area: 클래스 멤버 변수, 메소드 정보, Type 정보, Constant Pool, static, final 변수 등이 생성됩니다. 상수 풀(Constant Pool)은 모든 Symbolic Reference를 포함하고 있습니다.</li>
    </ul>
    <li>JNI(Java Native Interface): 자바 애플리케이션에서 C, C++, 어셈블리어로 작성된 함수를 사용할 수 있는 방법을 제공해줍니다. Native 키워드를 사용하여 메서드를 호출합니다. 대표적인 메서드는 Thread의 currentThread()입니다.</li>
    <li>Native Method Library: C, C++로 작성된 라이브러리 입니다.</li>
  </ul>
  <p>Java의 실행방식
    <ul>
    <li>자바 컴파일러(javac)가 자바 소스코드(.java)를 읽어 자바 바이트코드(.class)로 변환시킵니다.</li>
    <li>Class Loader를 통해 class 파일들을 JVM으로 로딩합니다.</li>
    <li>로딩된 class파일들은 Execution engine을 통해 해석됩니다.</li>
    <li>해석된 바이트코드는 Runtime Data Areas 에 배치되어 실질적인 수행이 이루어집니다.</li>
    </ul>
  </p>
</details>

<details>
  <summary>GC가 무엇인지, 필요한 이유는 무엇인지, 동작방식에 대해 설명해주세요.</summary>
  </br>
  <p>GC는 힙 영역에서 사용하지 않는 객체들을 제거하는 작업을 총칭합니다. 이 객체를 제거하는 작업이 필요한 이유는 자바는 개발자가 메모리를 직접 해제해줄 수 없는 언어이기 때문입니다. 따라서 객체를 사용하고 제거하는 기능이 필요하게 됩니다.</p>
  <p>GC의 동작방식은 가장 간단한 Serial GC 방식으로 설명합니다. 좀 더 진보된 GC는 G1 GC, ZGC가 있으며 여기선 다루지 않습니다.</p>
  <p>GC는 Minor GC, Major GC로 구분할 수 있습니다. Minor GC는 young 영역에서, Major GC는 old 영역에서 일어난다고 정의합니다. (Major GC, Full GC는 명확히 정의된 문서가 없습니다.) GC를 수행할 때는 GC를 수행하는 스레드 이외의 스레드는 모두 정지합니다. 이를 Stop-the-world라고 합니다.</p>
  <p>Minor GC는 Eden 영역이 가득 참에서 부터 시작됩니다. Eden 영역에서 참조가 남아있는 객체를 mark하고 survivor 영역으로 복사합니다. 그리고 Eden 영역을 비웁니다. Survivor 영역도 가득차면 같은 방식으로 다른 Survivor 영역에 복사하고 비웁니다. 이를 반복하다 보면 계속 해서 살아남는 객체는 old 영역으로 이동하게 됩니다.</p>
  <p>Major GC는 old 영역에서 일어납니다. 위와 반대로 삭제되어야 하는 객체를 mark합니다. 그리고 지웁(sweep)니다. 메모리는 단편화 된 상태이므로 이를 한 군데에 모아주는 것을 Compaction이라 하며 compact라고 합니다. 그래서 Mark-Sweep-Compact 알고리즘이라고 합니다.</p>
  <p>이것이 중요한 이유는 GC 수행시 시스템이 멈추기 때문에 의도치 않은 장애의 원인이 될 수 있습니다. 따라서 이를 위해 힙 영역을 조정하는 것을 GC 튜닝이라고 하고 JVM 메모리는 절대 마음대로 조정해선 안됩니다.</p>
</details>

<details>
  <summary>컬렉션 프레임워크에 대해서 설명해주세요.</summary>
  </br>
  <p>Java Collection은 널리 알려져 있는 자료구조를 바탕으로 객체, 데이터들을 효율적으로 관리 할 수 있는 자료구조들이 있는 라이브러리를 컬렉션 프레임워크라고 합니다.</p>
  <p>List, Set은 Collection 인터페이스을 상속받지만, Map 인터페이스는 구조상의 차이라 별도로 정의합니다.</p>
</details>

<details>
  <summary>제네릭에 대해서 설명해주세요.</summary>
  </br>
  <p>제네릭은 자바의 타입 안정성을 맡고 있습니다. 컴파일 과정에서 타입체크를 해주는 기능으로 객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안정성을 높이고 형변환의 번거로움을 줄여줍니다.</p>
</details>

<details>
  <summary>애노테이션에 대해서 설명해주세요.</summary>
  </br>
  <p>애노테이션은 인터페이스를 기반으로 한 문법으로 주석처럼 코드에 달아 클래스에 특별한 의미를 부여하거나 기능을 주입할 수 있습니다. built-in annotation은 상속받아서 메소드를 오버라이드 할 때 나타나는 @Override 애노테이션이 그 대표적인 예입니다.</p>
  <p>메타 애너테이션은 애노테이션을 선언할 때 사용하는 애노테이션입니다.</p>
  <ul>
    <li>@Retention: 애노테이션 유지 범위를 지정합니다. (소스, 클래스, 런타임)</li>
    <li>@Inherit: 애노테이션을 하위 클래스까지 전달여부를 지정합니다. 이 애노테이션이 있으면 하위 클래스까지 상속이 가능합니다.</li>
    <li>@Target: 해당 애노테이션을 어디에 사용할 지 결정합니다. (타입, 필드, 메서드, 파라미터, 생성자, 로컬변수, 애노테이션 타입)</li>
  </ul>
</details>

<details>
  <summary>오버라이딩과 오버로딩이 무엇이며 어떤 차이가 있을까요?</summary>
  </br>
  <p>의외로 굉장히 많은 답을 들을 수 있는 질문입니다.</p>
  <p>오버라이딩은 상위 클래스의 메소드를 재정의 하는 것을 의미합니다. 또, 런타임 다형성이기도 합니다.</p>
  <p>오버로딩은 같은 클래스 내에서 동일한 메소드 이름을 가지지만, 매개변수의 타입, 개수가 다르게 구현할 수 있는 것을 의미하며 컴파일 타임 다형성이기도 합니다. 따라서 오버라이딩 될 수 있습니다.</p>
  <p>추가로 `@Override`를 써야하는 이유를 꼭 생각해보세요. 이 애노테이션은 컴파일 타임에 오버라이딩에 대한 안정성을 부여해주기 때문에 반드시 써주는 것이 좋습니다.</p>
</details>

<details>
  <summary>인터페이스와 추상클래스의 차이점에 대해 설명해주세요.</summary>
  </br>
  <p>추상클래스는 객체의 추상적인 상위 개념으로 공통된 개념을 표현할 때 사용합니다. 단일 상속만 가능합니다. 추상클래스를 상속하는 집합간에는 연관관계가 있습니다.</p>
  <p>인터페이스는 구현 객체가 같은 동작을 한다는 것을 보장하기 위해 사용합니다. 다중 상속이 가능합니다. 인터페이스를 구현하는 집합간에는 관계가 없을 수 있습니다.</p>
</details>

<details>
  <summary>클래스는 무엇이고 객체는 무엇인가요?</summary>
  </br>
  <p>클래스는 객체를 정의하는 틀 또는 설계도와 같은 의미로 사용됩니다.</p>
  <p>객체는 식별 가능한 개체 또는 사물입니다. 객체는 구별 가능한 식별자, 특징적인 행동, 변경 가능한 상태를 가집니다. 인스턴스들을 통칭하는 용도로 사용합니다.</p>
</details>

<details>
  <summary>정적(static)이란 무엇인가요?</summary>
  </br>
  <p>static은 클래스 멤버라고 하며, 클래스 로더가 클래스를 로딩해서 메소드 메모리 영역에 적재할 때 클래스별로 관리됩니다.</p>
  <p>static 키워드를 통해 생성된 정적멤버들은 PermGen 또는 Metaspace에 저장되며 저장된 메모리는 모든 객체가 공유하며 하나의 멤버를 어디서든지 참조할 수 있는 장점이 있습니다.</p>
  <p>그러나, GC의 관리 영역 밖에 존재하기 때문에 프로그램 종료시까지 메모리가 할당된 채로 존재합니다. 너무 남발하게 되면 시스템 성능에 악영향을 줄 수 있습니다.</p>
</details>

<details>
  <summary>자바의 원시타입들은 무엇이 있으며 각각 몇 바이트를 차지하나요?</summary>
  </br>
  <p>실제 면접에서 들었던 질문입니다. 들었을 때 굉장히 당황했던 기억이 나네요.</p>
  <p>boolean(1), char(unsigned 2), byte(1), short(2), int(4), long(8), float(4), double(8)</p>
  <p>사실 JVM에 의존적이기 때문에 정확한 크기라기 보다는 대략적인 크기입니다.</p>
</details>

<details>
  <summary>접근 제어자의 종류와 이에 대해 설명해주세요.</summary>
  </br>
  <p>private, default, protected, public이 있습니다. private은 해당 클래스 내에서만 접근 가능하고, default는 해당 패키지, protected는 상속한 클래스, public은 전체 영역에서 접근 가능합니다.</p>
  <p>접근 제어자를 사용하는 이유는 외부에 보여주고 싶은 정보들을 선택적으로 제공하기 위함이고, 캡슐화와 통하는 면이 있습니다.</p>
</details>

<details>
  <summary>객체지향에 대해서 설명해주세요.</summary>
  </br>
  <p>객체지향을 정의하면, 의존성 관리입니다.</p>
  <p>객체지향으로 의존성을 관리함으로써 변경 영향을 최소화하고 독립적인 배포가 가능해지며 독립적인 개발이 가능해집니다. 따라서 객체지향에서 가장 중요한 것은 DIP(Dependency Inversion Principle)를 통한 고수준 정책(High Level Policy)와 저수준 구현 세부사항(Low Level Details)의 분리라고 할 수 있습니다.</p>
</details>

<details>
  <summary>SOLID(객체지향 5대원칙)에 대해서 설명해주세요.</summary>
  </br>
  <p>SRP(단일책임원칙)은 한 클래스의 하나의 책임만 가져야 합니다.</p>
  <p>OCP(개방-폐쇄 원칙)은 확장에는 열려 있으나 변경에는 닫혀 있어야 하며, 다형성을 활용해야 합니다.</p>
  <p>LSP(리스코프 치환 원칙)은 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야하는 원칙으로 상위 타입을 상속해서 재정의 했을 때 프로그램이 깨지지 않아야 합니다.</p>
  <p>ISP(인터페이스 분리 원칙)은 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안되는 원칙입니다. 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 더 낫습니다. 즉, 비대한 인터페이스보단 더 작고 구체적인 인터페이스로 분리해야합니다.</p>
  <p>DIP(의존관계 역전 원칙)은 추상적인 것은 자신보다 구체적인 것에 의존하지 않고, 변화하기 쉬운 것에 의존해서는 안된다는 원칙입니다. 구체적으론 구현 클래스에 의존하지 말고, 인터페이스에 의존해야 하는 원칙입니다.</p>
</details>

<details>
  <summary>동일성(identity)와 동등성(equality)에 대해 설명해주세요. (equals(), ==)</summary>
  </br>
  <p>동일성은 객체의 주소를 비교하는 것이고, 동등성은 객체의 같음을 비교하는 것입니다.</p>
  <p>기본적으로 자바에서는 Object 클래스에 정의된 equals() 메소드가 동일성 비교를 합니다. 따라서, 개발자는 원한다면 equals() 메소드를 오버라이딩해서 동등성의 판단 기준을 정의해주면 됩니다.</p>
</details>

<details>
  <summary>원시타입과 참조타입의 차이에 대해 설명해주세요.</summary>
  </br>
  <p>원시타입은 Java에서 단 8개 밖에 존재하지 않는 타입입니다. 나머지는 모두 참조타입이라고 볼 수 있고, Object 클래스이거나 이를 상속하는 클래스들로 이루어져 있습니다.</p>
  <p>원시타입은 항상 값이 존재해야 합니다. 반면, Object 타입은 null 포인터를 가질 수 있습니다. 그리고 멤버변수가 초기화될 때, 원시타입은 기본값을 가지지만, 참조타입은 null 포인터를 가지는 차이도 있습니다.</p>
</details>

<details>
  <summary>String, StringBuilder, StringBuffer 각각의 차이에 대해 설명해주세요.</summary>
  </br>
  <p>String은 불변입니다. StringBuilder와 StringBuffer는 이런 String의 특징때문에 사용하는 가변타입이라고 볼 수 있습니다.</p>
  <p>StringBuilder와 StringBuffer는 Thread-safe 여부의 차이가 있습니다. StringBuilder는 Thread-safe하지 않습니다. 따라서 Multi-Thread 환경에서 사용할 때는 StringBuffer를 사용합니다.</p>
</details>

<details>
  <summary>Checked Exception과 Unchecked Exception에 대해 설명해주세요. 스프링 트랜잭션 추상화에서 rollback 대상은 무엇일까요?</summary>
  </br>
  <p>둘의 차이는 RuntimeException을 상속하는가의 여부에 따라 다릅니다. RuntimeException을 상속하면 UncheckedException이 됩니다. 스프링 트랜잭션 추상화에서 rollback 대상은 바로 UncheckedException입니다.</p>
  <p>이 둘을 잘 알기 위해서는 토비의 스프링을 보시는 것을 추천합니다.</p>
</details>

<details>
  <summary>Java8에서 추가된 기능에 대해서 설명해주세요.</summary>
  </br>
  <p>자신이 사용한 경험을 말해주면 더 효과적일 것 같습니다.</p>
  <p>Java8에서는 Lambda식, Stream API, Optional, 날짜 시간 API, StringJoiner 등이 추가되었습니다.</p>
  <p>lambda는 함수형 프로그래밍을 지원하기 위한 기능이고, Stream API는 고차함수를 지원합니다. Optional은 Null-safety를 제공하며, Stream과 사용법이 유사합니다. 날짜 시간 API는 Joda-time등의 라이브러리에서 영향을 받아 괜찮은 API가 되었으며, StringJoiner는 문자열을 간단하게 구분자로 합칠 수 있는 기능을 제공합니다.</p>
</details>

<details>
  <summary>try-with-resource에 대해서 설명해주세요.</summary>
  </br>
  <p>try-with-resources는 자바 버전7에 도입된 문법입니다.</p>
  <p>자바 7 버전 이전에서 하나 이상의 리소스(java.lang.AutoCloseable을 구현한 객체 혹은 java.io.Closeable를 구현한 객체)를 사용할 경우 개발자가 임의로 finally 문에서 ~~.close()를 사용하여 자원 해제를 시켜줘야 했습니다.</p>
  <p>만약 개발자가 사용한 자원을 finally 문에서 해제시켜주지 않고 누락시켰다면 자원이 해제되지 않은 채로 프로그램이 오작동하게 되고, finally 문에서 자원을 해제 시켜주더라도 자원 해제를 위한 중복 코드가 발생하기 때문에 소스 코드의 가독성을 해치는 단점이 있었습니다.</p>
  <p>이를 해결하기 위해 try() 안에 사용할 리소스 객체를 명시적으로 선언하여 사용하면, try 블록 안에서 로직이 정상적으로 완료되었는지, 갑작스럽게 완료되었는지 여부와 관계 없이 JVM에서 자동으로 자원을 반납해주는 기능을 하도록 도입하였습니다.</p>
  <p>추가로, 자바 9 버전에서는 try() 문 안에 명시적으로 객체 선언을 하기 보다는 try 문 바깥에서 객체 선언을 하고 생성된 인스턴스의 변수를 넣어줄 수 있도록 바뀌었습니다.</p>
  <p>
  Java 7 : try(BufferedReader br = new BufferedReader()) <br>
  Java 9 : try(br)
  </p>
</details>

<details>
  <summary>강한 결합과 느슨한 결합이 무엇인지 설명해주세요.</summary>
  </br>
  <p>결합도는 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 정보를 알고 있는지에 대한 척도입니다.</p>
  <p>어떤 모듈이 다른 모듈에 너무 자세한 부분(구현 세부사항)까지 알고 있을 경우에 강한 결합도를 가진다고 합니다.</p>
  <p>어떤 모듈이 다른 모듈에 대해 필요한 정보(인터페이스로 추상화된 고수준 정책)만 알고 있다면 두 모듈은 낮은 결합도를 가진다고 합니다.</p>
  <p>객체지향 관점에서 결합도는 객체 또는 클래스가 협력에 필요한 적절한 수준의 관계만을 유지하고 있는지를 나타냅니다. 이러한 관점에서 강한 결합도는 반드시 지양해야 하며, 개발자는 적절한 결합도를 유지할 수 있도록 고민하고 설계해야 합니다.</p>
</details>

<details>
  <summary>직렬화와 역직렬화에 대해서 설명해주세요.</summary>
  </br>
  <p>직렬화란 자바 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 바이트 형태로 데이터 변환하는 기술과 바이트로 변환된 데이터를 다시 변환하는 기술(역직렬화)을 아울러서 이야기 합니다.</p>
  <p>자바 직렬화는 JVM의 메모리에서만 상주되어있는 객체 데이터를 영속화(Persistence)가 필요할 때 사용됩니다. 시스템이 종료되더라도 없어지지 않는 장점을 가지며 영속화된 데이터이기 때문에 네트워크로 전송이 가능합니다.</p>
</details>

<details>
  <summary>자바의 동시성 이슈(공유자원 접근)에 대해 설명해주세요.</summary>
  </br>
  <p></p>
</details>

<details>
  <summary>Mutable 객체와 Immutable 객체의 차이점에 대해 설명해주세요.</summary>
  </br>
  <p>Mutable 객체는 변경 가능 객체이고, Immutable 객체는 불변 객체라고 흔히들 말합니다.</p>
  <p>Mutable 객체는 도메인 개체(도메인 클래스 혹은 엔터티)로 사용됩니다. Mutable 객체의 변경 메서드는 Command method라고도 부르며, 리턴 타입을 void 로 정의합니다. 또한 void 리턴 타입의 어떠한 상태를 변경하는 메서드는 모두 Command method의 상징입니다.</p>
  <p>
  Immutable 객체는 불변객체이며 값 객체, 서비스 객체 등에 사용됩니다. Immutable 객체의 변경 메서드는 변경한 객체의 복사본을 반환해야 합니다.
  </p>
</details>

<details>
  <summary>자바에서 null을 안전하게 다루는 방법에 대해 설명해주세요.</summary>
  </br>
  <p>공개 메서드가 아닌 곳에는 assert를 사용하여 null을 방어할 수 있습니다. 또한 메서드의 인자를 받을 때 Objects.requireNonNull()을 사용하여 방어할 수 있습니다. 그리고 Optional을 사용해 리턴 타입에서 null을 반환하지 않도록 방어할 수 있습니다. 마지막으로 사전 조건과 사후 조건을 명확히 하여 계약에 의한 설계를 실천해야 합니다.</p>
</details>

#### Spring

### 프레임워크란

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

프레임워크란 응용 프로그램이나 소프트웨어 솔루션 개발을 수월하기 위해 __구조, 틀이 제공된 소프트웨어 환경__ 이다.

</details>

-----------------------

<br>

### Spring이란

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

스프링은 __자바 플랫폼을 위한 오픈 소스 애플리케이션 프레임워크__ 이다.  
동적인 웹 사이트를 개발하기 위한 여러 가지 서비스를 제공하고 있다.  

+ POJO 기반의 구성으로 자바 코드를 이용해서 객체를 구성하는 방식 그대로 스프링에서 사용할 수 있다.
    - 덕분에 높은 생산성과 유연한 테스트를 할 수 있다.
+ DI(의존성 주입)을 통한 객체 관계 구성을 지원한다.
+ AOP(횡단 관심사 분리) 지원
+ MVC 구조로 계층이 분리되어 관리하기 수월하다. 
+ 배치 애플리케이션 스프링 배치가 있다.

</details>

-----------------------

<br>


### DI (Dependency Injection)

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


__DI는 스프링 프레임워크에서 지원하는 IoC의 형태__ 이다.  
__클래스 사이의 의존관계를 빈 설정 정보를 바탕으로 컨테이너가 자동으로 연결해주는 것이다.__  
+ 장점
    - __스프링 자체에서 설정을 통해 연관 관계를 맺어줌으로써 객체간 결합도를 낮춰준다.__
    - __클래스의 재사용성을 높이고, 유지보수가 편리해진다.__
    - 의존성 주입으로 인해 stub, mock 객체를 사용해 unit 테스트의 이점이 생긴다.
+ 단점
    - 의존성 주입을 위한 선행 작업이 필요해 간단한 프로그램에서는 번거롭다.
    - __코드 추적이 어렵다.__


</details>

-----------------------

<br>


### 주입 방식

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


+ 수정자 주입
    - 대부분 의존 관계 주입은 한번 일어나면 종료시점까지 변경할 일이 거의 없다.
    - Setter를 통해 주입하게 되면 변경될 위험이 존재
    - setter을 public으로 열어야함
+ 필드 주입
    - 외부에서 변경이 불가능해서 테스트하기 어렵다.
+ 생성자 주입
    - 생성자 주입을 권장
    - 생성자 호출 시점에 딱 1번만 호출되는 것을 보장
    - final 키워드를 통해 불변하게 설계 가능
    - 의존성 주입이 누락되는 것을 방지할 수 있음(IDE에서 컴파일 오류로 알려줌)


</details>

-----------------------

<br>


### IoC (Inverse of Control 제어의 역전)

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


__객체의 생성부터 생명주기의 관리까지 모든 객체에 대한 제어권이 바뀐 것을 의미__ 한다.  
개발자는 프레임워크에 필요한 부품을 개발하고 조립하는 방식으로 개발을 하고 최종 호출은 개발자가 아니라 프레임워크의 내부에서 결정된 대로 이뤄지게 되는데 이런 현상을 제어의 역전이라고 한다.  

</details>

-----------------------

<br>


### 스프링 컨테이너

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


__스프링 컨테이너는 자바 객체의 생명 주기를 관리하며, 생성된 자바 객체들에게 추가적인 기능을 제공하는 역할을 한다.__  
스프링 컨테이너의 종류에는 BeanFactory와 __ApplicationContext__ 가 있다.  
둘 다 빈을 등록하고 생성하고 조회하고 돌려주는 등 빈을 관리하는 역할을 한다.  
ApplicationContext가 BeanFactory의 빈 관리 기능들을 상속받았고, 그 외에 국제화 등의 추가적인 기능을 갖고 있어 스프링 컨테이너라고 하면 보통 ApplicationContext라고 한다.  

</details>

-----------------------

<br>

### Bean

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


+ __컨테이너 안에 들어있는 객체__
+ 컨테이너에 담겨있으며, 필요할 때 컨테이너에서 가져와서 사용
+ @Bean을 사용해 등록하거나 xml을 사용해 등록하고, Bean으로 등록된 객체는 쉽게 주입하여 사용 가능


</details>

-----------------------

<br>


### Bean 생명주기

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


>스프링 컨테이너 생성 -> 스프링 빈 생성 -> 의존 관계 주입 -> 초기화 콜백 -> 사용 -> 소멸전 콜백 -> 스프링 종료

+ 스프링 컨테이너에 의해 생명주기 관리
+ 스프링 컨테이너 초기화 시 빈 객체 생성, 의존 객체 주입 및 초기화
+ 생성과 의존관계 주입과 초기화 분리
    - 의존관계 주입(생성자 주입)은 필수정보를 받고 메모리 할당을 통해 객채 생성 책임
    - 초기화는 생성된 값들을 활용해 외부 커넥션을 연결하는 등 무거운 작업 수행
    - 명확하게 분리하는 것이 유지보수 관점에서 좋다.
+ 싱글톤 빈들은 컨테이너가 종료되기 직전에 소멸전 콜백이 발생

초기화와 소멸 메서드는 애노테이션으로 __@PostConstruct, @PreDestroy__ 를 사용하는 것이 권장된다.

</details>

-----------------------

<br>



### 빈 스코프


<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


+ 싱글톤
    -  spring 프레임워크의 기본이 되는 스코프
    - 스프링 컨테이너 시작과 종료까지 1개의 객체로 유지
+ 프로토타입
    - 빈의 생성, 의존관계 주입, 초기화까지만 관여하고 이후에는 컨테이너에서 관리하지 않는 스코프
    - 따라서 매번 요청마다 새로 만들어짐
    - 싱글톤은 스프링이 뜰때 생성되는데 반해, 프로토타입은 __요청할때 생성됨__
+ 웹 스코프
    - request : 각 요청이 들어오고 나갈때까지 유지
    - session : 세션이 생성되고 종료될때까지 유지
    - application : 웹의 서블릿 컨텍스트와 동일한 생명주기를 갖는 스코프
        - 서블릿 컨텍스트는 __web application내에 있는 모든 서블릿들을 관리하며 정보공유할 수 있게 도와 주는 역할__ 을 하는데, 톰캣 컨테이너가 실행 시 애플리케이션 하나당 한개의 서블릿컨텍스트가 생성된다.
        - 생명 주기는 보통 톰캣의 시작과 종료와 일치한다.

</details>

-----------------------

<br>


### 싱글톤 vs 스프링 싱글톤


<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

### 싱글톤
```java
public class Person { 

    private static Person instance; 

    private Person() {
         throw new IllegalStateException("Private Constructor"); 
    } 

    public static Person getInstance() {
         if (instance == null) {
              instance = new Person(); 
              } 
              return instance; 
        }     
    }
}

public class Singleton { 
    private Singleton(){} 

    public static Singleton getInstance() { 
        return LazyHolder.INSTANCE; 
    }

    private static class LazyHolder { 
        private static final Singleton INSTANCE = new Singleton(); 
    } 
}
```
위 코드는 자바 언어를 사용해 싱글톤 패턴은 구현하는 전형적인 코드이다.  
싱글톤 패턴은 전역 상태를 이용할 수 있다는 장점이 있지만 다음과 같은 문제점으로 인해 안티 패턴으로도 불린다. 
+ __private 생성자를 갖고 있어 상속이 불가능하다.__
    - 싱글톤은 자신만이 객체를 생성할 수 있도록 private으로 제한한다. 하지만 상속을 통해 다형성을 적용하기 위해서는 기본 생성자가 필요하므로 private으로 인해 객체지향의 장점을 적용할 수 없다. 또한 싱글톤을 구현하기 위해서는 객체지향적이지 못한 static 필드와 static 메서드를 사용해야 한다.
+ __테스트하기 힘들다.__
    - 싱글톤은 생성 방식이 제한적이기 때문에 Mock 객체로 대체하기 어려우며, 동적으로 객체를 주입하기도 힘들다.
+ __서버 환경에서는 싱글톤이 1개만 생성됨을 보장하지 못한다.__
    - 서버에서 __클래스 로더__ 를 어떻게 구성하느냐에 따라 싱글톤 클래스임에도 불구하고 1개 이상의 객체가 만들어질 수 있다. 따라서 자바 언어를 이용한 싱글톤 기법은 서버 환경에서 싱글톤이 꼭 보장된다고 볼 수 없다. 또한 여러 개의 JVM에 분산돼서 설치되는 경우 독립적으로 객체가 생성된다.
+ __전역 상태를 만들 수 있기 때문에 바람직하지 못하다.__
    - 싱글톤의 정적 메서드를 사용하면 언제든지 해당 객체를 사용할 수 있고, 전역 상태로 사용되기 쉽다. 아무 객체나 자유롭게 접근하고 수정하며 공유되는 전역 상태는 객체지향 프로그래밍에서 권장하지 않는다.  


### 스프링 싱글톤
__객체의 생성을 스프링에 위임함으로써 스프링 컨테이너가 관리하여 자바 언어 레벨에서 직접 구현하기 위한 내용들이 모두 제거되어 앞선 싱글톤의 모든 단점들이 제거된다.__
+ private 생성자가 필요 없어 상속이 가능해진다.
+ 테스트하기 편하다.
+ 프레임워크를 통해 1개의 객체 생성을 보장받을 수 있다.
+ 객체지향적으로 개발할 수 있다.

</details>

-----------------------

<br>


### Annotation

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


Annotation은 프로그램에게 추가적인 정보를 제공하는 메타데이터이다.
+ __자바 코드에 특별한 의미를 부여한 주석으로 컴파일러를 위한 정보를 제공하기 위한 용도__
+ 동작 순서
    - 애노테이션 정의
    - 원하는 위치에 배치
    - 코드가 실행되는 중에 Reflection을 이용하여 추가 정보를 획득하여 기능 실시
+ Reflection
    - Reflection을 사용하면 컴파일 타임에 인터페이스, 필드, 메소드의 이름을 알지 못해도 실행 중에 클래스, 인터페이스, 필드 및 메소드에 접근할 수 있다. 또한 새로운 객체의 인스턴스화 및 메소드 호출을 허용한다.
    - __Annotation 자체는 아무런 동작을 가지지 않는 단순한 표식일 뿐이지만, Reflection을 이용하면 Annotation의 적용 여부와 엘리먼트 값을 읽고 처리할 수 있다.__
    - __Spring 컨테이너(BeanFactory)에서 객체가 호출되면 객체의 인스턴스를 생성하게 되는데 이 때 필요하게 된다. 즉, 프레임워크에서 유연성있는 동작을 위해 쓰인다.__
    - Reflection을 이용하면 Annotation 지정만으로도 원하는 클래스를 주입할 수 있다.

</details>

-----------------------

<br>




### Spring Annotation

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------



+ __@ComponentScan__
    - @Component, @Service, @Repository, @Controller, @Configuration이 붙은 클래스 Bean들을 찾아서 Context에 bean을 등록해주는 애노테이션
    - 전부 다 @Component를 사용하지 않고 @Repository 등으로 분리해서 사용하는 이유는, 예를 들어 @Repository는 DAO에서 발생할 수 있는 unchecked exception들을 스프링의 DataAccessException으로 처리할 수 있기 때문이다.
    - 또한 가독성에서도 해당 애노테이션을 갖는 클래스가 무엇을 하는지 단 번에 알 수 있다.
+ __@EnableAutoConfiguration__
    - autoConfiguration도 Configuration중 하나에 해당한다.
    - spring.factories 내부에 여러 Configuration들이 있고 조건에 따라 Bean이 등록되게 되는데 메인 클래스 @SpringBootApplication을 실행하면 @EnableAutoConfiguration에 의해 spring.factories 안에 있는 수많은 자동 설정들이 조건에 따라 적용되어 수 많은 Bean들이 생성된다.
    - 간단하게 정리하면, __Application Context를 만들 때 자동으로 빈설정이 되도록 하는 기능이다.__
+ @Component
    - 개발자가 직접 작성한 class를 Bean으로 등록하기 위한 애노테이션
+ @Bean
    - 개발자가 직접 제어가 불가능한 외부 라이브러리등을 bean으로 만들려할 때 사용되는 애노테이션
+ @Configuration
    - @Configuration을 클래스에 적용하고 @Bean을 해당 class의 메서드에 적용하면 @autowired로 Bean을 부를 수 있다.
+ @Autowired
    - 스프링이 Type에 따라 알아서 Bean을 주입해준다.
    - Type을 먼저 확인한 후 못 찾으면 Name에 따라 주입한다.
    - 강제로 주입하고자 하는 경우 @Qulifier을 같이 명시
+ @Qualifier
    - 같은 타입의 빈이 두 개 이상 존재하는 경우 스프링이 어떤 빈을 주입해야할 지 알 수 없어서 스프링 컨테이너를 초기화하는 과정에서 예외가 발생한다.
    - @Qualifier는 @Autowired와 함께 사용하여 정확히 어떤 bean을 사용할지 지정하여 특정 의존 객체를 주입할 수 있다.
+ __@Resource__
    - __@Autowired와 마찬가지로 Bean 객체를 주입해주는데 차이점은 Autowired는 타입으로, Resource는 이름으로 연결해준다.__
    - __애노테이션 사용으로 인해 특정 Framework에 종속적인 애플리케이션을 구성하지 않기 위해서 @Resource 사용을 권장한다.__
+ @Controller
    - API와 view를 동시에 사용하는 경우에 사용
    - 보통 view 화면 return을 목적으로 사용한다.
+ @RestController
    - view가 필요 없이 API만 지원하는 서비스에서 사용
+ @SpringBootApplication
    - @Configuration, @EnableAutoConfiguration, @ComponentScan 3가지를 하나로 합친 애노테이션


</details>

-----------------------

<br>




### 웹 서버와 웹 애플리케이션 서버


<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


![그림3](https://backtony.github.io/assets/img/post/spring/mvc/3-3.PNG)  
+ 웹 서버
    - 정적 리소스 파일을 제공하는 서버
+ 웹 애플리케이션 서버(WAS)
    - 웹 서버가 하는 일 + 애플리케이션 로직(DB 연결, 동작 수행, 데이터 제공)까지 제공하여 동적인 처리를 하는 서버
    - 자바 진영에서는 서블릿 컨테이너 기능을 제공하면 WAS 라고 한다.
    - 위 그림에는 없지만 WAS 안에도 웹 서버가 따로 존재한다.

</details>

-----------------------

<br>




### 서블릿


<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

![그림1](https://backtony.github.io/assets/img/post/interview/servlet-1.PNG)  
서블릿은 WAS 안에서 __동적인 페이지를 만드는데 사용되는 서버 프로그램__ 이다.  
서블릿이 존재하기 전에는 요청이 들어오면 HTTP 요청 메시지를 파싱하는 것부터 여러 부가 작업을 개발자가 수행해야 했다. 하지만 서블릿이 나오면서 부가적인 작업을 대신해주게 되었고, 개발자는 실직적인 메인 로직에만 집중 할 수 있게 되었다.

</details>

-----------------------

<br>


### 서블릿 컨테이너

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

앞서 스프링 컨테이너와 비슷하게 서블릿 컨테이너는 __서블릿의 생명주기__ 를 관리한다.  
+ init : 서블릿 초기화
+ service : HTTP 요청 유형을 확인하고 맞게 doGet, doPost, doPut 등 메서드를 호출하여 요청 처리
+ destroy : 서블릿 제거

서블릿 객체도 __싱글톤__ 으로 관리되기 때문에 최초 요청 시점에 서블릿 객체를 초기화해서 서블릿 컨테이너에 보관하고 이후에는 같은 서블릿을 공유해서 사용한다.

### 요청 시 동작 과정

![그림3](https://backtony.github.io/assets/img/post/interview/spring-3.PNG)  
1. 사용자가 URL을 클릭하면 HTTP Request를 Servlet Container로 보낸다.
2. __Servlet Container는 쓰레드 풀에서 쓰레드를 꺼내 할당__ 해주고 HttpServletRequest, HttpServletResponse 두 객체를 생성한다.
3. 사용자가 요청한 URL을 분석하여 어느 서블릿에 대한 요청인지 찾는다.
4. 서블릿 컨테이너에 존재하지 않으면 초기화하고 있다면 가져와서 service() 메서드를 호출한다.
    - Spring MVC의 경우 DispatcherServlet이 초기화되고 호출된다.
5. service 메서드가 수행이 끝나면 HttpServletResponse 객체에 응답을 보낸다.
6. 응답이 완료되면 HttpServletRequest, HttpServletResponse 객체를 소멸시킨다.

</details>

-----------------------

<br>




### 특정 서블릿에 접근하는 n명의 사용자가 있는 경우 이 서블릿은 첫번째 사용자가 처음 엑세스 했을때만 인스턴스화 되는건가요, 아니면 모든 사용자에게 개별적으로 인스턴스화 되는건가요?

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


웹 애플리케이션이 로드되면 서블릿 컨테이너(아파치 톰캣 같은)는 ServletContext를 __한번 생성하여__ 메모리에 보관한다.  
이후 servlet, filter, listener가 발견되면 해당 클래스들은 __한번 인스턴스 생성하고__ 서버의 메모리에 보관한다.  
다른 것들은 처음으로 HTTP request가 올때 init 메서드로 생성하여 보관한다.(이 이유로 첫 사용자의 경우 응답속도가 늦다.)  


</details>

-----------------------

<br>




### MVC 패턴

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

![그림6](https://backtony.github.io/assets/img/post/interview/servlet-6.PNG)  
1. 핸들러 조회
    - 핸들러 매핑을 통해 요청 URL에 매핑된 핸들러(컨트롤러)를 조회한다.
2. 핸들러 어댑터 조회
    - 핸들러를 실행할 수 있는 핸들러 어댑터를 조회한다.
3. 핸들러 어댑터 실행
    - 조회한 핸들러(컨트롤러)를 인자로 핸들러 어댑터에 넘겨서 핸들러를 실행시킨다.
4. ModelAndView 반환
    - 핸들러(컨트롤러)가 로직을 수행하고 반환하는 정보로 ModelAndView로 변환해서 반환한다.
5. viewResolver 호출
    - 적절한 viewResolver를 찾고 해당 viewResolver를 호출한다.
    - RestController라면 이 과정과 이후 과정 없이 컨버터를 이용해 바로 결과값을 리턴한다.
6. View 반환
    - viewResolver는 뷰의 논리 이름을 물리 이름으로 바꾸고, 랜더링 역할을 담당하는 뷰 객체를 반환한다.
7. 뷰 랜더링
    - 뷰를 통해서 뷰를 랜더링한다.

### MVC 패턴 장단점
+ 정의
    - Model, View, Controller로 분리하는 아키텍처
+ 장점
    - 과거에는 Controller에 다 담아두고 처리했다.
    - 기능 별로 코드를 분리하여, 가독성을 높이고 재사용성을 증가시킨다.
+ 단점
    - __view와 model 사이에 의존성이 높아서 애플리케이션이 커질수록 복잡해지고 유지보수가 어렵다.__
    - __대규모의 프로그램에서 Controller에 다수의 Model과 View가 복잡하게 연결되어 코드 분석과 테스트가 어려워 질 수 있다.__
    - 이런 의존성 문제를 해결하기 위해 MVVM, MVP 구조가 등장했다.  

</details>

-----------------------

<br>




### 어떻게 하나의 컨트롤러로 여러 요청을 받을까?

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

컨트롤러는 기본적으로 컴포넌트 스캔되면서 스프링 빈 컨테이너에 올라가있고 싱글톤 패턴으로 구현되어있기 때문에 여러 스레드의 요청이 들어와도 하나의 컨트롤러 객체를 공유하면서 처리한다.  
여기서 주의할 점은 싱글톤 패턴으로 구현되어 있어 있다는 것은 Thread-Safe하지 않다는 의미이므로 상태를 공유하거나 저장하는 코드가 없도록 Stateless하게 정의해야 한다.  
__결과적으로 내부에는 상태가 존재하지 않으니 메서드에 대한 정보만 같이 공유해서 쓰는 것이다.__

</details>

-----------------------

<br>



### 싱글톤 패턴은 멀티스레드 환경에 어떤 문제가 생길까?

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

멀티스레드 환경에서 스프링 싱글톤에서 문제가 생겼다면 메서드를 호출하는 환경이 스레드 세이프하게 구현되지 않았다던가, 싱글톤 패턴으로 생성되는 객체가 전역변수를 가졌기 때문이다.  
싱글톤 패턴은 하나의 객체를 공유하기 때문에 전역변수 같은 것은 되도록이면 사용하지 않아야 한다.  
이를 해결하는 방법은 다음과 같다.
+ 지역 변수 사용
+ Atomic 자료형 사용
+ ThreadLocal 사용
+ Synchronized 사용

</details>

-----------------------

<br>

### AOP(Aspect Oriented Programming)

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


관점 지향 프로그래밍으로 __공통 관심 사항과 핵심 관심 사항을 분리__ 하는 것을 의미한다.  
소스 코드에서 여러 번 반복해서 사용하는 코드(흩어진 관심사)를 Aspect로 모듈화하여 핵심 로직에서 분리해 재사용하는 것이라고 볼 수 있다.  
여러 객체에 공통으로 적용할 수 있는 기능을 구분함으로써 재사용성을 높여주는 프로그래밍 기법이다.  
특정 로직(로그, 성능테스트, 권한)을 모든 메서드에 적용하고 싶을 때, 일일이 추가하는 것이 아니라 로직을 만들어서 적용할 수 있다.  
따라서, 비즈니스 로직 앞/뒤에 공통 관심 사항을 수행해 중복 코드를 줄인다.  
__주요 용어__  
+ Aspect
    - 흩어진 관심사를 모듈화 한 것
        - 모듈 : 외부에서 재사용할 수 있는 패키지들을 묶은 것
    - advice + pointcut을 모듈화 한 것
+ Target
    - advice의 대상이 되는 객체
    - Pointcut으로 결정
+ Advice
    - 실질적인 부가 기능 로직을 정의하는 곳
    - 특정 조인 포인트에서 Aspect에 의해 취해지는 조치
+ Join point
    - __추상적인 개념__ 으로 advice가 적용될 수 있는 모든 위치
    - ex) 메서드 실행 시점, 생성자 호출 시점, 필드 값 접근 시점 등등..
    - __스프링 AOP는 프록시 방식을 사용하므로 조인 포인트는 항상 메서드 실행 지점__
+ Pointcut
    - 조인 포인트 중에서 advice가 적용될 위치를 선별하는 기능
    - __스프링 AOP는 프록시 기반이기 때문에 조인 포인트가 메서드 실행 시점 뿐이 없고 포인트컷도 메서드 실행 시점만 가능__
+ Advisor
    - 스프링 AOP에서만 사용되는 용어로 advice + pointcut 한 쌍
+ Weaving
    - pointcut으로 결장한 타겟의 join point에 advice를 적용하는 것
+ AOP 프록시
    - AOP 기능을 구현하기 위해 만든 프록시 객체
    - 스프링에서 AOP 프록시는 JDK 동적 프록시 또는 CGLIB 프록시


### AOP 적용 방식
+ 컴파일 시점
    - .java 파일을 컴파일러를 통해 .class를 만드는 시점에 부가 기능 로직을 추가
    - 모든 지점에 적용 가능
    - AspectJ가 제공하는 특별한 컴파일러를 사용해야 하기 때문에 특별할 컴파일러가 필요한 점과 복잡하다는 단점이 있다.
+ 클래스 로딩 시점
    - .class 파일을 JVM 내부의 클래스 로더에 보관하기 전에 조작하여 부가 기능 로직 추가
    - 모든 지점에 적용 가능
    - 특별한 옵션과 클래스 로더 조작기를 지정해야하므로 운영하기 어렵다.
+ __런타임 시점__
    - __스프링이 사용하는 방식__
    - 컴파일이 끝나고 클래스 로더에 이미 다 올라가 자바가 실행된 다음에 동작하는 런타임 방식
    - 실제 대상 코드는 그대로 유지되고 프록시를 통해 부가 기능이 적용
    - __프록시는 메서드 오버라이딩 개념으로 동작하기 때문에 메서드에만 적용 가능__ -> __스프링 빈에만 AOP를 적용 가능__
    - 특별한 컴파일러나, 복잡한 옵션, 클래스 로더 조작기를 사용하지 않아도 스프링만 있으면 AOP를 적용할 수 있기 때문에 스프링 AOP는 런타임 방식을 사용

</details>

-----------------------

<br>

### POJO


<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

평범한 구식 자바 객체로, __프레임워크 인터페이스나 클래스를 구현하거나 확장하지 않은 단순 클래스__ 를 의미한다.  
JAVA에서 제공하는 API외에는 종속되지 않아 __코드가 간결하고 테스트 자동화에 유리__ 하다.  
Spring에서는 __도메인과 비즈니스 로직을 수행하는 대상__ 이 POJO 대상이 될 수 있다.

</details>

-----------------------

<br>


### DAO, DTO

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ DAO
    - DB 데이터를 조회하거나 조작하는 기능을 전담하는 객체
    - DB 접근 로직과 비즈니스 로직을 분리하기 위해서 사용
+ DTO
    - 계층간의 데이터 교환을 위한 객체
    - 로직을 갖지 않는 순수 데이터 객체로 getter, setter만 포함
    - VO
        - DTO와 동일한 개념
        - Read Only로 수정 불가
        - getter, setter 이외의 추가 로직 포함 가능


</details>

-----------------------

<br>


### Filter, Interceptor

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

![그림2](https://backtony.github.io/assets/img/post/interview/spring-2.PNG)  
+ Filter
    - __Dispatcher Servlet에 요청이 전달되기 전/후에 url 패턴에 맞는 모든 요청에 대해 부가작업을 처리하는 기능을 제공하는 것__
    - __톰캣과 같은 웹 컨테이너(웹 애플리케이션 WAS 단)에서 동작__ 하기 때문에 Spring과 무관한 자원에 대해 동작
    - Spring Context 외부에서 동작하므로 __ErrorController__ 에서 예외 처리
    - init
        - 필터 객체를 초기화하고 서비스에 추가하기위한 메서드
        - 웹 컨테이너(WAS 단)에서 1회 init 메서드를 호출하여 필터 객체를 초기화하면 이후 요청들은 doFilter를 통해 전/후 처리가 된다.
    - doFilter
        - url-pattern에 맞는 모든 HTTP 요청이 디스패처 서블릿으로 전달되기 전/후에 웹 컨테이너에 의해 실행되는 메서드
        - doFilter의 파라미터로 FilterChain이 있는데, FilterChain의 doFilter 를 통해 다음 대상으로 요청을 전달한다.
    - destroy
        - 필터 객체를 서비스에서 제거하고 사용하는 자원을 반환하는 메서드
        - 웹 컨테이너에 의해 1번 호출된다.
    - 참고로 필터를 추가하기 위해서는 javax.servlet의 Filter 인터페이스를 구현하면 된다.
+ Interceptor
    - __Spring이 제공하는 기술로, Dispatcher Servlet이 컨트롤러를 호출하기 전과 후에 요청과 응답을 참조하거나 가공할 수 있는 기능을 제공하는 것__
    - __스프링 컨텍스트에서 동작__
    - Spring Context 내부에서 동작하므로 __@ControllerAdvice__ 을 사용하여 예외 처리
    - preHandle
        - 컨트롤러가 호출되기 전에 실행되어 컨트롤러 이전에 처리해야 하는 전처리 작업이나 요청 정보를 가공하거나 추가하는 경우에 사용할 수 있다.
    - postHandle
        - 컨트롤러 호출된 후에 실행되어 컨트롤러 이후에 처리해야하는 후처리 작업이 있을 때 사용할 수 있다.
        - 보통 컨트롤러가 반환하는 ModelAndView 타입의 정보가 제공되는데, 최근에는 Json 형태로 데이터를 제공하는 REST API 기반의 컨트롤러가 사용되면서 잘 사용하지 않는다.
    - afterCompletion
        - 모든 뷰에서 최종 결과를 생성하는 일을 포함해 모든 작업이 완료된 후에 실행된다.
        - 요청 처리 중에 사용한 리소스를 반환할 때 사용하기 적합하다.    
    - 참고로 인터셉터를 추가하기 위해서는 org.springframework.web.servlet의 HandlerInterceptor 인터페이스를 구현하면 된다.

### 실행 과정
1. 서버 실행 시 Servlet이 올라오는 동안 init 후 doFilter 실행
2. Dispatcher Servlet을 지나쳐 Interceptor의 PreHandler 실행
3. 컨트롤러를 거쳐 내부 로직 수행 후, Interceptor의 PostHandler 실행
4. doFilter 실행
5. Servlet 종료 시 destory


### 둘의 차이

대상|필터(Filter)|인터셉터(Interceptor)
---|---|---
관리 컨테이너|웹 컨테이너|스프링 컨테이너
Rqeust/Response 조작 여부|가능|불가능
용도| + 보안 관련 공통 작업<br>+ 이미지/데이터 압축 및 문자열 인코딩<br>+ 모든 요청에 대한 로깅 또는 감사|+ 인증/인가 등과 같은 공통 작업<br>+ Controller로 넘겨주는 정보의 가공<br>+ API 호출에 대한 로깅 또는 감사

인터셉터가 조작 여부가 불가능하다는 것은 HttpServletRequest, HttpServletResponse 객체를 제공받으므로 객체 자체는 조작할 수 없다는 의미이고, 내부 값들은 조작할 수 있다.

</details>

-----------------------

<br>


### AOP, Interceptor


<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

AOP와 Interceptor가 비슷한 기능을 수행한다고 할 수 있는데 이들의 사용을 구분 짓는 방법은 __파라미터__ 이다.  
모든 메서드의 파라미터와 타입은 제각각이기 때문에 이에 대해 AOP를 적용하게 되면 부가 작업들이 생기게 된다.  
반면에 Interceptor의 경우 HttpServletRequest, HttpServletResponse를 파라미터로 사용하여 부가 작업이 필요하지 않다.  
또한, 인터셉터는 Conotroller 앞에서 동작하고 AOP는 Service 앞에서 동작한다.  

</details>

-----------------------

<br>



### 레이어드 아키텍처

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


![그림5](https://backtony.github.io/assets/img/post/interview/spring-5.PNG)  
Spring은 레이어드 아키텍처로 이루어져있다.  
하나의 레이어는 자신의 고유 역할을 수행하고, 인접한 다른 레이어에 무언가를 요청하거나 응답한다.  
그밖의 다른 레이어는 신경 쓸 필요가 없기 때문에 각 레이어는 자신의 역할에 충실할 수 있다.  
따라서 시스템 전체를 수정하지 않고 특정한 레이어의 기능을 개선하거나 교체할 수 있기 때문에 재사용성이 좋고 유지 보수하기에도 유리하다.  
또한, 레이어별로 테스트 구현이 편해지고 코드 가독성도 높아진다.

+ Presentation Layer
    - view를 담당하는 부분으로, 클라이언트와 직접적으로 맞닿는 부분
+ Application Layer 
    - 비즈니스 핵심 로직을 처리하는 부분
    - Service 객체라는 것은 하나의 트랜잭션으로 구성되어 작동
+ Persistence Layer
    - 데이터 관련 처리를 담당하는 부분

</details>

-----------------------

<br>


### OSIV

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


OSIV는 Open Session In View의 약자로 __영속성 컨텍스트를 뷰단까지 열어준다__ 는 뜻이다.  
스프링의 OSIV는 프레센테이션 계층에는 트랜잭션이 없기 때문에 엔티티를 수정할 수 없지만 영속성 컨텍스트가 살아있기 때문에 지연로딩이 가능합니다.  
언뜻보면 만능처럼 보이지만 단점이 있다.
+ 같은 영속성 컨텍스트를 여러 트랜잭션이 공유할 수 있다.
+ 프레젠테이션 계층에서 엔티티를 수정하고 트랜잭션(서비스계층)으로 들어오면 엔티티가 수정된다.
+ 프레젠테이션 계층에서 지연로딩에 의한 SQL이 실행되기 때문에 성능 튜닝시 확인해야할 부분이 넓어진다.

</details>

-----------------------

<br>


### 커넥션 풀

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

애플리케이션이 데이터베이스를 사용하기 위해서는 커넥션을 맺어야 한다.  
커넥션을 생성하고 소멸시키는 비용이 크기 때문에 커넥션 풀을 세팅해두고(기본 10) 애플리케이션이 시작하는 시점에 커넥션을 미리 다 만들어 놓고 이를 재활용하면서 사용한다.  
스프링 부트 2.0부터는 hikariCP를 기본 커넥션 풀로 사용한다.  

</details>

-----------------------

<br>

### DataSource

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

커넥션 관련 기술이 여러 개 등장하면서 코드레벨에서는 서로 다르지만 논리적으로는 커넥션을 획득하는 역할을 하기 때문에 이를 추상화 시킨 것이 DataSource이다.  
실질적인 로직은 DataSource에 의존하도록 하고 구현 기술이 바뀔때 마다 DataSource의 구현체만 바꾸면 되므로 재사용성과 확장성을 높일 수 있다.  
커넥션 관련 기술은 커넥션을 계속 신규 생성하는 DriverManager, DBCP2 커넥션 풀, HikariCP 커넥션 풀 등이 있다.  
DriverManager는 DataSource를 구현하지 않아서 스프링에서 DriverManagerDataSource라는 구현 클래스를 제공한다.  

</details>

-----------------------

<br>

### 트랜잭션을 추상화하는 이유

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


DataSource와 같은 맥락이다.  
다양한 데이터 접근 기술이 등장하면서 코드레벨에서는 서로 다르지만 논리적으로는 같은 기능을 수행하기 때문에 트랜잭션을 추상화했다.  
스프링 트랜잭션 추상화 클래스는 __PlatformTransactionManager__ 이다. 보통 __트랜잭션 매니저__ 라고 부른다.  
다양한 접근 기술로는 JDBC, JPA, 하이버네이트 등이 있다.  

</details>

-----------------------

<br>

### 트랜잭션 동기화 매니저


<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


보통 서비스 단에서 트랜잭션을 시작하고 끝낸다.  
그렇다면 __하나의 트랜잭션 내에서는 같은 커넥션을 사용__ 해야 하는데 과정이 다음과 같다.  
1. 서비스단에서 트랜잭션이 시작하면 트랜잭션 매니저가 커넥션을 생성하고(풀을 사용하면 풀에서 가져오고) autoCommit을 false로 세팅한 뒤 트랜잭션 동기화 매니저의 스레드 로컬에 커넥션을 보관한다.  
2. 이후 리포지토리 계층에서는 트랜잭션 동기화 매니저의 스레드 로컬에서 해당 커넥션을 가져와서 사용한다.  
3. 서비스 단에서 트랜잭션을 종료할 때는 트랜잭션 동기화 매니저에서 해당 커넥션을 가져와 커밋 또는 롤백을 수행하고 리소스를 정리하고 커넥션을 커넥션 풀에 반환한다.  

__하나의 트랜잭션에서 같은 커넥션을 사용하도록 도움을 주는 기능을 제공한다고 보면 된다.__  

</details>

-----------------------

<br>


### 선언적 트랜잭션 vs 프로그래밍 방식 트랜잭션

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


선언적 트랜잭션은 @Transactional을 의미한다.  
프로그래밍 방식 트랜잭션은 트랜잭션 매니저나 트랜잭션 템플릿 등을 직접 사용해서 프로그래밍 코드를 작성하는 방식이다.  
@Transactional을 사용하면 프록시(메서드 오버라이딩 개념)를 사용하기 때문에 추가적인 코드를 작성할 필요 없이 간편하게 사용할 수 있으므로 대부분 선언적 트랜잭션을 사용한다.  

</details>

-----------------------

<br>



### @Transactional

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

@Transactional AOP로 구성되어 있다.  
즉, 프록시로 동작하므로 오버라이딩 개념으로 동작한다.  
메서드에 @Transactional을 붙이면 해당 클래스가 빈으로 등록될 때 @Transactional이 붙은 메서드만 트랜잭션 처리되는 메서드로 오버라이딩 한 프록시 객체가 빈으로 등록된다.  
__클래스에 붙으면 클래스의 전체 public 메서드에 트랜잭션 처리가 된 프록시가 빈으로 등록된다.__  
__public이 아닌 다른 접근제한자가 붙은 메서드의 경우는 트랜잭션처리가 되지 않는데 이유는 프록시가 오버라이딩 개념이기 때문에 public으로 열려있지 않고 private 메서드 같은 경우에는 적용이 불가능하다.__  


### 내부 호출 문제
@Transactional이 붙은 클래스는 프록시로 빈으로 등록된다.  
따라서 주입받은 객체를 사용할 경우 프록시가 들어오게 되고 접근 시 프록시 객체를 통한 호출이 이뤄진다.  
```java
public class UserService {

    @Transactional
    public void createUserListWithTrans(){
        for (int i = 0; i < 10; i++) {
            createUser(i);
        }
            
        throw new RuntimeException(); 
    }

    @Transactional
    public User createUser(int index){
        User user = User.builder()
                .name("testname::"+index)
                .email("testemail::"+index)
                .build();
        
        userRepository.save(user);
        return user;
    }
}
```
createUserListWithTrans에서 createUser를 호출한다.  
둘다 @Transactional이 붙어있다.  
서로 트랜잭션이 붙어있기에 createUser에서 save 처리를 했으므로 예외가 발생하더라도 다 저장되었을 것이라고 생각할 수 있지만 틀렸다.  
이유는 트랜잭션이 붙은 상태로 동작하려면 프록시를 통해 접근해야 하는데 위는 실제 코드 자체를 호출한 것이기 때문이다.  
즉, 프록시를 사용하려면 userService.XXX 형식으로 호출해야된다는 뜻이다.  
따라서 createUserListWithTrans를 호출할 경우 아래와 프록시 객체로 동작한다.
```java
public void createUserListWithTrans(){
    EntityTransaction tx = em.getTransaction();
    tx.begin();
    
    super.createUserListWithTrans();
    
    tx.commit();
}
```
createUserListWithTrans에 붙은 @Transactional만 동작하게 된다.  
즉, 하나의 트랜잭션 안에서 동작하게 되는 것이다.  
만약 트랜잭션이 붙은 프록시를 호출해서 사용하다가 다른 트랜잭션이 붙은 프록시 클래스를 호출할 경우 이때부터는 트랜잭션 전파 속성에 따라 트랜잭션이 동작한다.  
<br>

앞서 다 설명했지만 한번 더 집고 넘어가자.  
진입점에 Trasactional이 없고 안에서 호출되는 메서드에만 Transactional이 있는 경우다. 
```java
public class UserService {

    public void createUserListWithTrans(){
        for (int i = 0; i < 10; i++) {
            createUser(i);
        }
            
        throw new RuntimeException(); 
    }

    @Transactional
    public User createUser(int index){
        User user = User.builder()
                .name("testname::"+index)
                .email("testemail::"+index)
                .build();
        
        userRepository.save(user);
        return user;
    }
}


// AopApplication.java
userService.createUserListWithoutTrans();
```
Userservice는 createUser에 붙은 @Transactional 때문에 프록시가 빈으로 등록된다.  
userService는 프록시이지만 createUserListWithTrans는 트랜잭션이 붙어있지 않으므로 트랜잭션이 처리되지 않는 것을 호출하게 되고 내부적으로 createUser을 호출하게 되어 트랜잭션 없이 호출하게 된다.  
실행결과를 보면 user가 10개 생성되게 되는데 이는 @Transactional이 없기 때문에 createUser가 각각 insert하면서 DB의 기본 설정대로 auto commit이 true로 인한 동작 결과이다.(@Transactional은 auto commit을 false로 하고 마지막에 commit한다.)  


</details>

-----------------------

<br>


### Propagation 전파단계

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


전파 단계는 트랜잭션 동작 도중 다른 트랜잭션을 호출하는 상황에서 선택할 수 있는 옵션이다.  
디폴트는 required로 트랜잭션이 없으면 새로 생성하고, 부모 트랜잭션 내에 실행하면 부모 트랜잭션 내에서 수행한다.  
자세한 내용은 [여기](https://backtony.github.io/interview/2021-11-24-interview-9/#transaction-%EC%A0%84%ED%8C%8C-%ED%83%80%EC%9E%85)를 참고하자.  

</details>

-----------------------

<br>

### ORM

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------



+ JDBC API
    - JAVA 진영 Database 연결 표준 인터페이스
+ Spring JDBC
    - template을 통해 데이터를 꺼내면서 한단계 더 추상화
+ MyBatis
    - SQL 분리를 목적으로 XML로 관리하는 방식
+ ORM(Object Relational Mapping)
    - 객체지향 코드와 데이터 중심 데이터베이스의 패러다임 불일치를 해결하기 위해 나온 기술
    - 객체와 관계형 데이터베이스를 맵핑하는 기술
+ JPA
    - 자바 ORM의 표준 API 명세를 JPA 인터페이스라고 한다.
+ Hibernate
    - JPA 인터페이스의 구현체
+ Spring Data JPA
    - JPA에 Repository를 추가하여 한단계 더 추상화한 것

</details>

-----------------------

<br>


### 영속성 컨텍스트

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

영속성 컨텍스트란 __엔티티를 영구 저장하는 환경을 의미__ 한다.  
생명 주기
+ 영속
    - 영속성 컨텍스트에 저장된 상태
+ 준영속
    - 영속성 컨텍스트에 저장되었다가 분리된 상태
+ 비영속
    - 영속성 컨텍스트와 전혀 관계없는 상태
+ 삭제
    - 삭제된 상태

### 영속성 컨텍스트의 이점
+ 1차 캐시
    - 조회가 가능하며 1차 캐시에 없으면 DB에서 조회하여 1차 캐시로 가져온다.
+ 동일성 보장
    - == 비교가 가능하다.
+ 쓰기 지연
    - 트랜잭션 커밋 전까지 SQL을 바로 보내지 않고 모아서 보낼 수 있다.
+ 변경 감지(더티 체킹)
    - 1차 캐시에 들어온 데이터를 스탭샷 찍어두고 커밋시점에 비교하여 update SQL을 생성한다.
+ 지연 로딩
    - 엔티티안에서 엔티티를 불러올 때 사용 시점에 쿼리를 날려 가져올 수 있다.

</details>

-----------------------

<br>



### N+1 문제

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------
N+1 문제는 하위 엔티티들을 첫 쿼리 실행 시 한 번에 가져오지 않고, 지연 로딩으로 프록시가 들어온 상태에서 후에 이것을 사용하면서 조회 쿼리가 다시 나가게 되어 발생하는 문제이다.  
예를 들어, 학생(N)과 팀(1)에서 양방향관계를 갖고 DB에서 팀을 10개를 꺼낸다고 가정해보자.  
첫 쿼리는 팀 10개를 꺼내는 쿼리가 하나의 쿼리가 나가게 되고 이때, 팀 기준 OneToMany이므로 Lazy로 동작하여 학생은 프록시로 들어오게 된다.  
이게 가져온 각각의 팀에 대해 학생들에게 접근하는 로직이 있다면 각 팀마다 학생들을 조회하는 쿼리가 1개씩 더 나가게 된다. 즉, 10개의 쿼리가 더 나가게된다.  
그래서 1개의 쿼리가 나가고 이후에 N개의 쿼리가 더 나간다고 해서 N+1 문제라고 한다.  
이에 대한 해결책은 Fetch Join과 Batch Size가 있다.  
Fetch Join을 사용하면 Lazy로딩으로 프록시로 들어오던 것을 join으로 한 번에 땡겨올 수 있다.  
Batch Size는 N+1문제가 발생하던 것 처럼 프록시로 가져오고 학생들 가져오게 될 때 쿼리가 한번 더 나가게 되는데 이때 in쿼리로 Batch size 개수만큼 가져온다.  
가져온 팀이 10개이고 Batch size가 5라면, 최초에 학생을 가져오는 쿼리에서 where 조건문 in 쿼리로 5개의 team id값을 넣어서 쿼리를 날린다. 이렇게 되면 결과적으로 학생을 가져오는 쿼리는 2번 나가게 되어 총 쿼리는 3(팀 가져오는 쿼리 + 학생 가져오는 쿼리)개의 쿼리가 나가게 된다.  
참고로 @EntityGraph를 사용해도 Fetch join으로 가져올 수 있다.  

</details>

-----------------------

<br>



### fetch join 한계


<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ fetch join 대상에는 별칭을 줄 수 없다.
    - 하이버네이트는 허용하지만 가급적이면 사용하지 않는게 좋다.
    - fetch join은 나의 연관된 것들을 다 끌고오겠다는 의미로 설계된 것이기 때문에 대상을 where문과 on에서 사용하게 되면 필터링이 되므로 의도된 설계와 맞지 않는다.
+ __둘 이상의 컬렉션은 fetch join 할 수 없다.__ 
    - 둘 이상 컬렉션과 진행시 카테시안 곱이 되어 정합성이 맞지 않는다.
+ OneToMany의 경우 페이징 쿼리 성능 이슈

</details>

-----------------------

<br>



### OneToMany fetch join 페이징 쿼리 성능 이슈

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

ManyToOne의 경우 애초에 Many에 One을 끼워넣기 때문에 최대 Many의 데이터 개수만큼만 조회된다.  
반면에 OneToMany의 경우 One에 Many를 끼워넣기 때문에 기존 One의 개수 만큼의 데이터가 아니라 더 많은 데이터가 조회된다.(뻥튀기 된다.)  
![그림1](https://backtony.github.io/assets/img/post/jpa/start/10-1.PNG)  

팀A에 학생1, 학생2가 연관된 데이터가 DB에 있다고 했을 때, 개발자의 의도는 팀A에 연결된 모든 Member를 모두 꺼내오는 식으로 페이징을 1로 주고 쿼리를 oneToMany에서 fetch Join을 날리게 되면 DB단에서는 OneToMany이므로 Team쪽 데이터가 뻥튀기되면서 (팀A, 회원1), (팀A, 회원2)로 구성되고 여기서 페이징하게 되면 (팀A, 회원1)의 데이터만 나오게 된다.  
따라서 JPA는 이를 판단할 수 없기 때문에 애초에 나가는 쿼리를 살펴보면 페이징 쿼리가 제거되서 나가고 연관된 데이터를 전부다 끌고오는 쿼리가 나가게 된다.  
그리고 해당 데이터를 메모리에 적재해서 페이징을 시작한다.  
만약 테이블에 100만개의 데이터가 있다는 그걸 다 땡겨온 상태에서 페이징을 진행한다는 의미다.  
결과적으로는 의도대로 동작할 지라도 엄청난 성능에 악영향을 주기 때문에 사용해서는 안된다.  
이러한 성능 이슈 때문에 이를 경고하는 메시지가 콘솔에 찍힌다.  
따라서 OneToMany에서 페이징 쿼리를 날리고 싶다면 batch size를 사용해야 한다.  
<br>

페이징 쿼리를 사용하지 않고 OneToMany를 사용할 때 주의할 점도 있다.  
앞서 설명했듯이 OneToMany에서 fetch Join을 하면 DB에서는 데이터가 뻥튀기 된 상태로 넘어온다.  
이걸 애플리케이션 단에서 받으면 당연히 아무처리 없이 뻥튀기 된 상태로 받게 된다.  
즉, (팀A, 회원1), (팀A, 회원2) 이렇게 받게 되는 문제가 발생하는 것이다.  
이를 해결하기 위해서는 쿼리에 distinct를 명시하면 된다.  
DB단에서는 당연히 행 데이터가 서로 다르기 때문에 distinct가 동작하지 않지만 애플리케이션 단으로 데이터가 넘어오면 JPA에서 distinct로 식별자가 같은 것을 걸러서 컬렉션으로 꽂아주는 기능을 제공해준다.  
따라서 OneToMany 관계에서 fetch join을 사용한다면 반드시 distinct를 명시해야 한다.  

</details>

-----------------------

<br>



### MultipleBagFetchException


<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

XXToOne과 같이 단일 관계의 자식 테이블에는 Fetch Join 여러 번 사용해도 된다.  
하지만 XXToMany의 경우 2개 이상의 OneToMany 자식 테이블에 Fetch Join을 선언했을때 MultipleBagFetchException이 발생한다.  
쉽게 말하면, 2개 이상의 컬렉션을 Fetch join으로 땡겨오면 데이터 정합성 문제가 발생한다.  
해결책은 Batch Size를 이용하는 것이다.  
자주 사용하는 컬렉션 쪽에는 Fetch join을 걸어주고, 나머지는 Lazy Loading으로 땡겨온다.  
Lazy Loading으로 인해 프록시로 땡겨온 부분을 접근할 때 Batch Size로 인해 in쿼리로 땡겨오는 식으로 해결해야 한다.  

</details>

-----------------------

<br>



### OneToOne 양방향 관계 Lazy 로딩 주의

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

OneToOne 양방향 관계에서는 연관관계 주인이 호출할 때는 Lazy가 동작하지만, 주인이 아닌 곳에서 호출하게 되면 Lazy가 먹히지 않는다.  
이유는 프록시는 null을 감쌀 수 없기 때문에 프록시의 한계로 나타나는 문제이다.  
![그림4](https://backtony.github.io/assets/img/post/interview/spring-4.PNG)  
User과 Cart가 일대일 양방향관계이고 연관관계 주인은 User라고 가정해보자.  
Cart 테이블을 보면 Cart는 User_Id 값을 알지 못한다. 알기 위해서는 User 테이블을 조회해야하는데 이렇게 되면 User 테이블을 조회해야하기 때문에 Lazy의 의미가 없어진다. 그래서 Lazy로 설정해도 Eager로 동작하는 것이다.  
<Br>

그렇다면 OneToMany의 경우에도 마찬가지가 아닐까 라고 생각할 수 있지만 OneToMany는 Lazy가 정상 동작한다.  
이유는 컬렉션의 경우는 비어있다고 isEmpty로 표현이 가능하지만, OneToOne은 없다면 Null값이 들어가기 때문이다.  
</details>

-----------------------

<br>


### 상속관계 매핑

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


+ 상속관계 매핑
  - 객체간의 상속관계를 DB에 적용시키기 위한 작업
  - 부모 클래스에 __@Inheritance__ 애노테이션 붙여서 상속관계 명시
  - JOINED 전략이 제일 합리적, 매우 간단하면 SINGLE_TABLE 전략 사용
  - 부모, 자식 클래스 모두 @Entity
  - 전략에 따라 부모테이블이 생성될 수도, 안될 수도 있다.
+ __@MappedSuperclass__
  - 객체끼리 __공통되는 속성(프로퍼티)__ 를 뽑아서 만든 클래스(BaseEntity 처럼 시간 뽑을 때)
  - Item을 부모로 book, album 같이 포함되는 상속관계가 아니라 createDate같이 객체끼리 공통되는 필드가 겹칠 때 사용
  - 자바에서는 상속으로 사용하나 상속관계 매핑과 다르게 __엔티티가 아니라 DB상에 올라가지 않음__
+ 임베디드 타입
    - MappedSuperclass와 유사하게 공통되는 속성을 뽑아서 만든 클래스로 @Embeddable 애노테이션을 붙인다.
    - 사용하는 곳에서는 상속이 아니라 필드로 선언하고 위에 @Embedded 애노테이션을 붙이다.
    - 테이블로 올라가지 않는다.

MappedSuperclass와 임베디드 타입은 거의 똑같다고 보면 되는데 임베디드 타입은 위임이고, MappedSuperclass는 상속이다.  
보통 상속보다는 위임이 좋기 때문에 위임을 선택하지만 편의상 경우에 따라 상속이 좋은 선택이 될 수도 있다.
```sql
-- 임베디드 타입
select m from Member m where m.traceDate.createdDate > ?

-- 상속
select m from Member m where m.createdDate > ?
```
위임의 경우 한 번 더 접근해야하는데 상속은 바로 접근할 수 있다.  
__또한 임베디드 타입은 서로 다른 엔티티가 공유하게 되면 SideEffect가 발생할 수 있다.(한 쪽에서 고치면 다른쪽에서도 바뀐다.)__  

</details>

-----------------------

<br>


### QueryDsl을 사용하는 이유


<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


+ QueryDsl을 사용하면 컴파일 타임에 오류를 잡을 수 있고, 동적 쿼리를 쉽게 작성할 수 있다.  
+ 원하는 필드만 뽑아서 DTO로 만드는 기능도 지원한다.
+ where 조건절을 함수로 추상화하여 재활용할 수 있다.

</details>

-----------------------

<br>



### Spring batch

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

단발성으로 대용량 데이터를 처리하는 애플리케이션을 배치 애플리케이션이라고 하고 스프링 진영에는 스프링 배치가 있다.  
스프링 배치는 레이저 구조 3개로 구분된다.

+ 애플리케이션 레이어
    - 개발자가 작성한 모든 배치 작업과 사용자 정의 코드를 포함한다.
+ 코어 레이어
    - 배치 작업을 시작하고 제어하는데 필요한 핵심 런타임 클래스들을 포함(jobLauncher, job, step, flow 등)한다.
+ 인프라 레이어
    - 잡을 실행의 흐름과 처리를 위한 틀을 제공
    - 애플리케이션과 코어 모두 인프라 위에서 빌드된다.


</details>

-----------------------

<br>



### 청크기반 방식

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ itemReader, itemProcessor, itemWriter로 구성된다.
    - itemReader
        - Custor 기반 처리 
            - 데이터를 호출하면 다음 커서로 이동하는 스트리밍 방식으로 데이터를 한 건씩 처리
            - 모든 결과를 메모리에 할당하기 때문에 메모리 사용량 증가
            - 모든 데이터를 처리할 때까지 커넥션 유지
            - 멀티스레드 환경에서 동시성 이슈 발생하므로 동기화 처리가 필요
        - 페이징 기반 처리
            - 페이지 사이즈 만큼 데이터를 한 번에 처리
            - 페이지 사이즈 만큼 커넥션을 맺고 끊음
            - 페이징 결과만 메모리에 할당
            - 멀티 스레드 환경에서 스레드 안정성을 보장하기에 별도 동기화 처리 불필요
        - __페이지 사이즈와 청크 사이즈를 일치시켜야 하는 이유__
            - 청크 사이즈가 50이고 페이지 사이즈가 10이면 5번의 read가 발생하면서 한 번의 트랜잭션 처리를 위해서 5번의 조회 쿼리를 날리는 성능 이슈가 발생할 수 있다.
            - JPA를 사용하는 경우 영속성 컨텍스트가 깨지는 문제가 발생한다. JpaPagingItemReader의 경우 페이지를 읽을때, 이전 트랜잭션을 flush, clear로 초기화 시켜버린다. 그러다 보니 마지막에 읽은 페이지를 제외한 이전에 조회한 결과들의 트랜잭션 세션이 전부 종료되어 버리면서 processor에서 Lazy 로딩이 불가능하게 되는 현상이 발생한다.
    - itemWriter
        - jpaItemWriter
            - JPA 엔티티 기반으로 데이터를 처리하고 엔티티를 하나씩 insert한다.
        - JdbcBatchItemWriter
            - Jpa처럼 단건 처리가 아닌 일괄 bulk insert 처리한다.
        - __ChunkSize 만큼 데이터를 커밋하기 때문에 Chunk size가 곧 Commit Interval(커밋 간격)이 된다.__

+ chunkSize 만큼 데이터를 한 번에 처리하고 다음 chunkSize는 새로운 트랜잭션으로 동작한다.
+ repeat, retry, skip을 통해서 반복 및 오류 제어를 할 수 있다.

</details>

-----------------------

<br>



### HibernateItemReader vs JpaPaingReader의 차이

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

일반적인 경우에는 차이가 없으나 2개 이상의 컬렉션을 땡겨와야 하는 경우 차이가 발생한다.  
2개 이상의 컬렉션을 땡겨오는 경우 MultipleBagFetchException을 피하기 위해 fetch join을 먹이고 다른 쪽에는 batchSize 옵션을 먹이게 된다.  
다른 PagingItemReader의 경우 문제가 없으나 JpaPagingItemReader의 경우만 batchSize 옵션이 적용되지 않는다.  
이유는 다른 PagingItemReader는 트랜잭션을 Chunk에 맡기지만 JpaPagingItemReader의 경우 트랜잭션이 doReadPage 메서드 안에서 읽기에 관한 트랜잭션을 먼저 처리해버리기 때문이다.  
doReadPage 메서드를 까보면 트랜잭션을 가져와서 flush, clear 해버리고 데이터를 읽어온 뒤 마지막에 트랜잭션 커밋을 해버리면서 데이터를 읽은 트랜잭션이 종료되버린다.  
processor 부분에서 지연 로딩의 N+1문제를 막기 위해서 BatchSize 옵션을 걸어버린 것인데 processor에 오기 전에 해당 트랜잭션이 종료되어 버리므로 processor에서는 batchSize 옵션이 적용되지 않고 N+1 문제가 발생해버린다.  
__정리하면, 일반적인 경우에는 상관 없으나 컬렉션 2개 이상의 조인을 해야하는 경우 JpaPagingItemReader의 N+1 이슈가 있으니 잘 알고 사용해야 한다.__  
[참고](https://jojoldu.tistory.com/414)

</details>

-----------------------

<br>



### MSA vs Monolithic(모놀리식)

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------

+ Monolithic(모놀리식)
    - 장점
        - 개발 환경이 같아서 복잡하지 않다.
        - End-To-End 테스트가 용이하다.(MSA의 경우 필요한 서비스들을 모두 동작시켜야함)
    - 단점
        - 프로젝트가 커지면 __빌드, 배포 시간이 오래걸린다.__
        - 작은 수정사항이 있어도 전체를 다시 빒드하고 배포해야 한다.
        - 많은 양의 코드가 몰려있어 개발자가 모두를 이해하는데 어렵고 유지보수하기도 어렵다.
        - __일부분의 오류가 전체에 영향을 미친다.__
+ MSA
    - 장점
        - 서비스 단위로 개발을 진행하기에 해당 부분을 온전히 이해하기 쉽다.
        - __새로 추가되는 부분은 빠르게 수정 및 배포가 가능하다.__
        - 해당 기능에 맞는 기술, 언어 등을 선택하여 사용할 수 있다.
        - __문제가 생기면 해당 기능에만 문제가 생긴다.__
    - 단점
        - __서비스가 분산되어 있어 관리하기 어렵다.__
        - 통신오류가 잦을 수 있다.
        - __테스트가 불편하다.__

</details>

-----------------------

<br>



## DDD 구조

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

-----------------------


+ DDD란 비즈니스 도메인 별로 나눠서 설계하는 방식으로 여러 도메인들이 서로 상호작용하도록 도메인을 중심으로 설계하는 것을 말한다.
+ DDD의 핵심 목표는 모듈간의 의존성을 최소화하고 응집성은 최대화하는 것이다.
+ Presentation, application, domain, infrastructure 계층으로 구분되어 있다.
    - presentation -> application -> domain -> infrastructure
    - 하위 계층으로만 의존함으로서 구조가 복잡하여 발생할 수 있는 순환참조를 막을 수 있다.
    - 단방향으로 구성되어있기에 각 계층별 로직을 쉽게 이해할 수 있다.
    - infrastructure는 domain의 추상화를 구현하는 계층으로 DIP의 활용을 극대화할 수 있다.

</details>

-----------------------

<br>


<details>
  <summary>Spring DI/IoC는 어떻게 동작하나요?</summary>
  </br>
  <p>IoC(제어의 역전)은 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것으로 코드의 최종호출은 개발자가 제어하는 것이 아닌 프레임워크의 내부에서 결정된 대로 이루어집니다.</p>
  <p>DI(의존관계 주입)은 Spring 프레임워크에서 지원하는 IoC의 형태로 클래스 사이의 의존관계를 빈 설정 정보를 바탕으로 컨테이너가 자동으로 연결해줍니다.</p>
  <p>스프링에서는 스프링 컨테이너 ApplicationContext를 이용하여 설정 정보를 생성, 등록하고 필요한 객체를 생성자 혹은 setter를 통해 주입합니다.</p>
</details>

<details>
  <summary>Spring Bean이란 무엇인가요?</summary>
  </br>
  <p>IoC 컨테이너 안에 들어있는 객체로 필요할 때 IoC컨테이너에서 가져와서 사용합니다. @Bean 을 사용하거나 xml설정을 통해 일반 객체를 Bean으로 등록할 수 있습니다.</p>
</details>

<details>
  <summary>스프링 Bean의 생성 과정을 설명해주세요.</summary>
  </br>
  <p>객체 생성 → 의존 설정 → 초기화 → 사용 → 소멸 과정의 생명주기를 가지고 있습니다. Bean은 스프링 컨테이너에 의해 생명주기를 관리하며 빈 초기화방법은 @PostConstruct 를 빈 소멸에서는 @PreDestroy 를 사용합니다.</p>
  <p>생성한 스프링 빈을 등록할 때는 ComponentScan을 이용하거나 @Configuration 의 @Bean 을 사용하여 빈 설정파일에 직접 빈을 등록할 수 있습니다.</p>
</details>

<details>
  <summary>스프링 Bean의 Scope에 대해서 설명해주세요.</summary>
  </br>
  <p>빈 스코프는 빈이 존재할 수 있는 범위를 뜻하며 싱글톤, 프로토타입, request, session, application 등이 있습니다.</p>
  <p>싱글톤은 기본 스코프로 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프입니다.</p>
  <p>프로토타입은 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 매우 짧은 범위의 스코프입니다.</p>
  <p>request는 웹 요청이 들어오고 나갈때까지 유지하는 스코프, session은 웹 세션이 생성, 종료할때까지, application은 웹 서블릿 컨텍스트와 같은 범위로 유지하는 스코프입니다.</p>
</details>

<details>
  <summary>IoC 컨테이너의 역할은 무엇이 있을까요?</summary>
  </br>
  <p>애플리케이션 실행시점에 빈 오브젝트를 인스턴스화하고 DI 한 후에 최초로 애플리케이션을 기동할 빈 하나를 제공해준다</p>
</details>

<details>
  <summary>DI 종류는 어떤것이 있고, 이들의 차이는 무엇인가요?</summary>
  </br>
  <p>DI는 세가지 방법이 있습니다. 생성자 삽입, Setter를 이용한 메소드 매개 변수 삽입, 필드 주입이 있습니다.</p>
  <p>생성자 주입은 생성자 호출시점에 딱 1번만 호출되는 것을 보장하며 불변, 필수 의존관계에 사용합니다.</p>
  <p>Setter주입은 선택, 변경 가능성이 있는 의존관계에 사용되며 스프링빈을 선택적으로 등록이 가능합니다.</p>
  <p>필드 주입은 `@Autowired` 를 사용하는데 외부에서 변경이 불가능하여 테스트 하기 힘듭니다. DI 프레임워크 없이는 작동하기 힘들며, 주로 애플리케이션과 관계없는 테스트코드나 `@Configuration` 같은 스프링 설정 목적으로 사용합니다. </p>
</details>

<details>
  <summary>Autowiring 과정에 대해서 설명해주세요.</summary>
  </br>
  <p>컨테이너에서 타입(인터페이스 또는 오브젝트)을 이용해 의존 대상 객체를 검색하고 할당할 수 있는 빈 객체를 찾아 주입한다</p>
</details>

<details>
  <summary>Spring Web MVC의 Dispatcher Servlet의 동작 원리에 대해서 간단히 설명해주세요.</summary>
  </br>
  <p></p>
</details>

<details>
  <summary>프론트 컨트롤러 패턴이란 무엇인가요?</summary>
  </br>
  <p>클라이언트의 다양한 요청마다 서블릿을 만들어서 사용한다고 하면 개발과 유지보수의 효율이 떨어질 수 밖에 없습니다. 프론트 컨트롤러 패턴을 사용함으로써 각 요청을 적절한 곳으로 위임해줌으로써 개발과 유지보수의 효율성이 증가하고 모든 요청에 대해 보안, 국제화, 라우팅 및 로그와 같은 일반적인 기능을 한 곳에서 캡슐화할 수 있습니다. Spring에서는 DispatcherServlet이 프론트 컨트롤러 패턴을 사용한 예이며, DispatcherServlet이 Bean으로 등록되어 package를 scan하고 @Controller, @RestController 애노테이션을 확인하여 어떠한 요청이 들어왔을 때 적절한 Handler Method에 위임해줍니다.</p>
</details>

<details>
  <summary>Servlet Filter와 Spring Interceptor의 차이는 무엇인가요?</summary>
  </br>
  <p>Filter는 Servlet Filter로써 javax.servlet 스펙에 포함되는 클래스입니다.</p>
  <p>Interceptor는 Spring MVC 스펙에 포함되어 있는 클래스입니다.</p>
  <p>Filter는 Servlet에서 전후처리를 담당하며, Interceptor는 Spring에서 Handler를 실행하기 전후나, ViewResolver를 통해 컨트롤러에서 리턴한 View Name으로부터 렌더링을 담당할 View 오브젝트를 준비해 돌려준 후 실제 View를 렌더링한 후에 어떠한 처리를 담당합니다.</p>
  <p>Filter는 Web Application(Tomcat을 사용할 경우 web.xml)에 등록하며, Interceptor는 Spring의 Application Context에 등록합니다.</p>
  <p>Filter는 Method Signature에 있는 Argument인 HttpServletRequest 혹은 HttpServeltResponse를 ServletRequest, ServletResponse 등으로 교체할 때 사용하거나, 데이터 변환(다운로드 파일의 압축 및 데이터 암호화 등), XSL/T를 이용한 XML 문서 변경, 사용자 인증, 자원 접근에 대한 로깅 등에 사용합니다.</p>
  <p>Interceptor의 경우 AOP를 흉내내거나, Spring 애플리케이션에서 전역적으로 전후처리 로직에서 예외를 사용하도록 하거나, Handler Method에서 사용자의 권한을 체크해서 다른 동작을 시켜준다거나 할 때 사용합니다.</p>
  <p></p>
</details>

<details>
  <summary>Spring에서 CORS 에러를 해결하기 위한 방법을 설명해주세요.</summary>
  </br>
  <p>Servlet Filter를 사용하여 커스텀한 Cors 설정하거나, WebMvcConfiguer를 구현한 Configuration 클래스를 만들어서 addCorsMappings()를 재정의할 수도 있고, 마지막으로 Spring Security에서 CorsConfigurationSource를 Bean으로 등록하고 config에 추가해줌으로써 해결할 수 있습니다.</p>
  <p>Controller 클래스에 @Crossorigin 어노테이션을 통해 해결할 수 있습니다.</p>
</details>

<details>
  <summary>Bean/Component 어노테이션에 대해서 설명해주시고, 둘의 차이점에 대해 설명해주세요.</summary>
  </br>
  <p>두 어노테이션 모두 IoC 컨테이너에 Bean을 등록하기 위해 사용합니다</p>
  <p>@Component : 개발자가 작성한 class를 기반으로 실행시점에 인스턴스 객체를 1회(싱글톤) 생성합니다</p>
  <p>@Controller, @Service, @Repository 는 모두 @Component 이며 실행시점에 자동으로 의존성을 주입합니다</p>
  <p>@Bean : 개발자가 작성한 method를 기반으로 메서드에서 반환하는 객체를 인스턴스 객체로 1회(싱글톤) 생성합니다</p>
</details>

<details>
  <summary>POJO란 무엇인가요? Spring Framework에서 POJO는 무엇이 될 수 있을까요?</summary>
  </br>
  <p>POJO는 프레임워크 인터페이스, 클래스를 구현하거나 확장하지 않은 단순한 클래스로 Java에서 제공하는 API 외에 종속되지 않습니다. 특정 환경에 종속되지 않아 코드가 간결하고 테스트 자동화에 유리합니다. 스프링에서는 도메인과 비즈니스 로직을 수행하는 대상이 POJO대상이 될 수 있습니다.</p>
</details>

<details>
  <summary>Spring Web MVC에서 요청 마다 Thread가 생성되어 Controller를 통해 요청을 수행할텐데, 어떻게 1개의 Controller만 생성될 수 있을까요?</summary>
  </br>
  <p></p>
</details>

<details>
  <summary>Filter는 Servlet의 스펙이고, Interceptor는 Spring MVC의 스펙입니다. Spring Application에서 Filter와 Interceptor를 통해 예외를 처리할 경우 어떻게 해야 할까요?</summary>
  </br>
  <p>Filter는 DispatcherServlet 외부에 존재하기 때문에 예외가 발생했을 때 ErrorController에서 처리해야 합니다. 하지만 Interceptor는 DispatcherServlet 내부에 존재하기 때문에 @ControllerAdvice를 적용해서 처리할 수 있습니다.</p>
</details>

<details>
  <summary>Spring Application을 구동할 때 메서드를 실행시키는 방법에 대해 설명해주세요.</summary>
  </br>
  <p>CommandLineRunner, ApplicationRunner를 구현한 클래스를 만들어서 실행시키는 2가지 방법이 있습니다. 또한 Spring의 ApplicationEvent를 사용한 방법, @Postconstruct를 사용한 방법, InitializingBean 인터페이스를 구현하는 방법, @Bean의 initMethod를 사용한 방법이 있습니다.</p>
</details>

<details>
  <summary>의존성과 설정값을 생성자 인자로 주입해야 하는 이유에 대해 설명해주세요.</summary>
  </br>
  <p>모든 의존성을 생성자를 통해 주입하면, 인스턴스 생성 시 즉시 어떠한 동작을 실행할 수 있습니다. 또한 추가적인 설정은 필요하지 않으며, 뜻하지 않게 의존성과 설정값을 빠뜨리는 일이 발생하지 않고 테스트에도 용이합니다.</p>
</details>

#### JPA

<details>
  <summary>JPA 영속성 컨텍스트의 이점(5가지)을 설명해주세요.</summary>
  </br>
  <p>영속성 컨텍스트는 엔티티를 영구 저장하는 환경을 의미합니다.</p>
  <p>영속성 컨텍스트를 쓰는 이유는 1차 캐시, 동일성 보장, 쓰기 지연, 변경감지(Dirty checking), 지연로딩이 있습니다.</p>
  <ul>
    <li>1차 캐시: 조회가 가능하며 1차 캐시에 없으면 DB에서 조회하여 1차 캐시에 올려 놓습니다.</li>
    <li>동일성 보장: 동일성 비교가 가능합니다.(==)</li>
    <li>쓰기 지연: 트랜잭션을 지원하는 쓰기 지연이 가능하며 트랜잭션 커밋하기 전까지 SQL을 바로 보내지 않고 모아서 보낼 수 있습니다.</li>
    <li>변경 감지(Dirty checking): 스냅샷을 1차 캐시에 들어온 데이터를 찍습니다. commit 되는 시점에 Entity와 스냅샷과 비교하여 update SQL을 생성합니다.</li>
    <li>지연 로딩: 엔티티에서 해당 엔티티를 불러올 때 그 때 SQL을 날려 해당 데이터를 가져옵니다.</li>
  </ul>
</details>

<details>
  <summary>JPA Propagation 전파단계를 설명해주세요.</summary>
  </br>
  <p>대기업면접에서 나왔던 질문으로 트랜잭션 고립단계와 같이 질문할 가능성이 있습니다.</p>
  <p>JPA Propagation은 트랜잭션 동작 도중 다른 트랜잭션을 호출(실행)하는 상황에 선택할 수 있는 옵션입니다.</p>
  <p>@Transactional의 propagation 속성을 통해 피호출 트랜잭션의 입장에서는 호출한 쪽의 트랜잭션을 그대로 사용할 수도 있고, 새롭게 트랜잭션을 생성할 수도 있습니다.</p>
  <p>REQUIRED(디폴트): 부모 트랜잭션 내에서 실행하며 부모 트랜잭션이 없을 경우 새로운 트랜잭션을 생성합니다.</p>
  <p>이 외에도 종류가 REQUIRES_NEW, SUPPORTS, MANDATORY, NOT_SUPPORT, NEVER, NESTED 가 있지만 신입이 실제로 다뤄본 경험이 적기 때문에 REQUIRED(디폴트)값만 답변했습니다.</p>
</details>

<details>
  <summary>JPA를 쓴다면 그 이유에 대해서 설명해주세요.</summary>
  </br>
  <p>사실 면접관이 의도한 바를 파악하는게 중요합니다. 각기 다른 조건에서 같은 질문을 들었을 때 대답을 다르게 했던 기억이 납니다.</p>
  <p>제가 JPA를 사용하는 이유는 객체지향 프레임워크이기 때문입니다. JPA를 사용하면 비즈니스 로직이 RDBMS에 의존하는 것이 아니라, 자바 코드로 표현될 수 있기 때문입니다. 그로 인해서 생산성이 높아진다고 볼 수 있습니다.(이는 JPA에 익숙하다는 것을 전제로 합니다.)</p>
  <p>또, JPA는 JPQL로 SQL을 추상화하기 때문에 RDBMS Vendor에 관계없이 동일한 쿼리를 작성해서 같은 동작을 기대할 수 있다는 장점도 가지고 있습니다. 이는 database dialect를 지원하기 때문에 가지는 장점입니다.</p>
</details>

<details>
  <summary>N + 1 문제는 무엇이고 이것이 발생하는 이유와 이를 해결하는 방법을 설명해주세요.</summary>
  </br>
  <p>JPA와 관련된 단골문제입니다. 꼭 학습해둡시다.</p>
  <p>N + 1 쿼리 문제는 즉시 로딩과 지연 로딩 전략 각각의 상황에서 발생할 수 있습니다. 하위 엔티티들이 존재하는 경우 한 쿼리에서 모두 가져오는 것이 아닌, 필요한 곳에서 각각 쿼리가 발생하는 경우를 이릅니다.</p>
  <p>즉시 로딩에서 발생하는 이유는 JPQL을 사용하는 경우 전체 조회를 했을 때, 영속성 컨텍스트가 아닌 데이터베이스에서 직접 데이터를 조회한 다음 즉시로딩 전략이 동작하기 때문입니다.<br>
  지연 로딩에서 발생하는 이유는 지연로딩 전략을 사용한 하위 엔티티를 로드할 때, JPA에서 프록시 엔티티를 unproxy 할 때 해당 엔티티를 조회하기 위한 추가적인 쿼리가 실행되어 발생합니다.</p>
  <p>해결 방법으로는 Fetch Join이라고 불리는 JPQL의 join fetch를 사용하는 방법이 있으며, 또 다른 방법으로는 <code>@EntityGraph</code>를 사용하는 방법, <code>@Fetch(FetchMode.SUBSELECT)</code>를 사용하는 방법, <code>@BatchSize</code>를 사용해 조절하거나 전역적인 batch-size를 설정하는 방법이 있습니다.</p>
  <p>각 해결방안에 대한 유의점은 작성하지 않습니다.</p>
</details>
 
## 기타

### 트러블 슈팅

<details>
  <summary>대용량 트래픽에서 장애가 발생하면 어떻게 대응할 것인가요?</summary>
  </br>
  <p>캐쉬에서 트래픽이 감당이 안되거나 오류가 나면 DB에서 조회하게끔 서킷브레이커를 걸어서 다른 방법으로 우회하도록 제공할 것입니다.</p>
</details>

### 디자인 패턴

<details>
  <summary>싱글톤 패턴에 대해서 설명해주세요.(생각보다 어려움)</summary>
  </br>
  <p>전역 변수를 사용하지 않고 객체를 하나만 생성하도록 하며, 생성된 객체를 어디에서든지 참조할 수 있도록 하는 패턴입니다.</p>
  <p>하나의 인스턴스만을 생성하며 getInstance메서드로 모든 클라이언트에게 동일한 인스턴스를 반환합니다.</p>
  <p>private 생성자를 가지는 특징을 가지며, 생성된 싱글톤 오브젝트는 저장할 수 있는 자신과 같은 타입의 스태틱 필드를 정의합니다.</p>
  <p>싱글톤 패턴의 문제점은 다음과 같습니다.</p>
  <ul>
    <li>의존 관계상 클라이언트가 구체 클래스에 의존합니다.</li>
    <li>private 생성자 때문에 테스트가 어렵습니다.</li>
    <li>객체 인스턴스를 하나만 생성해서 공유하는 방식 때문에 싱글톤 객체를 stateful하게 설계 했을 경우 큰 장애 발생요인이 됩니다.</li>
  </ul>
  <p>싱글톤의 단점을 해결하기 위해 무상태(stateless)로 설계해야 합니다.</p>
  <ul>
    <li>특정 클라이언트에 의존적인 필드가 있으면 안됩니다.</li>
    <li>특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안됩니다.</li>
    <li>가급적 읽기 전용으로 만들고, 필드 대신에 자바에서 공유되지 않는 지역변수, 파라미터, ThreadLocal 등을 사용합니다.</li>
  </ul>
</details>

<details>
  <summary>가교 패턴(브릿지 패턴)에 대해서 설명해주세요.</summary>
  </br>
  <p>가교 패턴은 추상부와 구현부를 분리하는 디자인 패턴입니다. 해당 패턴에서 기능은 인터페이스를 통해 정의 및 이용되고 해당 인터페이스를 따르는 클래스를 통해 구현됩니다. 해당 패턴을 통해서 사용자는 추상부와 구현부를 독립적으로 수정 및 확장할 수 있습니다. 가교 패턴은 객체지향 설계의 SOLID 원칙 중 단일 책임 원칙(SRP)과 개방 폐쇄 원칙(OCP)에 부합한 패턴입니다.</p>
</details>

<details>
  <summary>전략 패턴에 대해서 설명해주세요.</summary>
  </br>
  <p>전략 패턴은 알고리즘을 객체 단위로 캡슐화하는 디자인 패턴입니다. 해당 패턴에서 알고리즘은 인터페이스를 통해 정의 및 이용되고 해당 인터페이스를 따르는 클래스를 통해 구현됩니다. 해당 패턴을 통해서 사용자는 알고리즘을 필요에 따라 바꿔서 사용할 수 있게 됩니다. 전략 패턴은 객체지향 설계의 SOLID 원칙 중 개방 폐쇄 원칙(OCP)에 부합한 패턴입니다.</p>
  <p>전략 패턴은 가교 패턴과 구조가 비슷하지만 목적에 차이가 있습니다. 가교 패턴이 추상과 구현의 분리를 통한 독립적 개발의 용이성에 중점을 둔다면 전략 패턴은 알고리즘의 캡슐화를 통한 알고리즘 변경의 유연성에 중점을 둡니다.</p>
</details>

<details>
  <summary>빌더 패턴에 대해서 설명해주세요.</summary>
  </br>
  <p></p>
</details>

<details>
  <summary>팩토리 메서드 패턴에 대해서 설명해주세요.</summary>
  </br>
  <p></p>
</details>

<details>
  <summary>퍼사드 패턴에 대한 예를 들어주세요.</summary>
  </br>
  <p>바운디드 컨텍스트로 구분된 각각의 독립적인 애플리케이션을 UI 서버를 통해 파사드 역할을 담당하도록 두고 각 바운디드 컨텍스트에서 UI 서버와 통신하기 위해 HTTP, Protobuf, Thrift와 같은 방식을 이용할 수 있습니다.</p>
</details>

### 테스트

<details>
  <summary>테스트 코드에 대해서 어떻게 생각하고, 작성하나요?</summary>
  </br>
  <p></p>
</details>

<details>
  <summary>TDD를 알고 있나요? TDD에 대해서 어떻게 생각하나요?</summary>
  </br>
  <p></p>
</details>

<details>
  <summary>테스트 커버리지에 대해서 어떻게 생각하나요?</summary>
  </br>
  <p>라인 커버리지, 브랜치 커버리지를 높은 수치로 달성하는 것은 바람직하지 않다고 생각합니다. 핵심 비즈니스 로직의 패스 커버리지를 갖는 것이 라인 커버리지, 브랜치 커버리지를 높은 수치로 유지하는 것보다 낫다고 생각합니다. 또한 무의미한 테스트 코드를 작성함으로써 유지보수 비용을 발생시키거나 읽기 좋은 코드를 테스트 커버리지를 채우기 위해 수정하는 등의 일은 반드시 피해야 한다고 생각합니다.</p>
</details>

### 인프라/클라우드

<details>
  <summary>AWS 인프라를 구축해보았다면 설명해주세요.</summary>
  </br>
  <p></p>
</details>

<details>
  <summary>로드 밸런서에 대해서 설명해주세요.</summary>
  </br>
  <p></p>
</details>

<details>
  <summary>리버스 프록시에 대해서 설명해주세요.</summary>
  </br>
  <p></p>
</details>

<details>
  <summary>Fault-tolerant(무정지) 시스템으로 가기 위해 필요한 방법에 대한 생각을 말해주세요. </summary>
  </br>
  <p>다운 타임이 발생하지 않도록 두 대 이상의 서버를 서비스해야 하고 비용 절감을 위해 배포할 때에만 새롭게 서비스를 띄우고, 배포가 완료된 후에는 기존 서버는 셧다운 시키면 됩니다.</p>
  <p>무정지 배포 방법 Rolling </br>
  로드 밸런서에서 서버를 빼고, 배포하고 다시 넣는 작업이 각 서버마다 이루어지도록 합니다. </br>
  Rolling 배포의 단점은 배포할 서버가 너무 많다면, n대 단위로 배포하기도 하는데 배포가 모두 끝나기 전까지 클라이언트 중 누구는 이전 서비스를 제공 받고 누구는 신규 서비스를 제공 받게 되는 문제가 발생합니다. 또한 1대에 배포하는 것보다 최소 2배 이상 느립니다.
  </p>
  <p>무정지 배포 방법 Canary </br>
  소수의 유저(혹은 사내)만 사용하는 환경(Canary 환경)에 신규 버전을 배포하고 문제가 없다고 판단됐을 때 다른 모든 서버에 배포합니다.
  </p>
  <p>무정지 배포 방법 Blue/Green </br>
  실제로 서비스 중인 환경(Blue)과 새롭게 배포할 환경(Green)을 세트로 준비해서 배포하는 형식입니다. </br>
  새롭게 배포할 환경에만 배포하면 되기 때문에 배포 속도가 매우 빠르며, 언제나 Green 환경이 실행 중이기 때문에 만약 잘못된 버전으로 배포 했을 경우 신속하게 롤백이 가능합니다. </br>
  Blue/Green 배포의 단점은 Green 환경이 항상 실행 중이어야 하기 때문에 비용이 많이 발생합니다.
  </p>
</details>

### 컨테이너

제가 아직 도커, 쿠버네티스에 익숙하지 않아 공부가 좀 더 필요합니다.  
관련해서 질문을 받아본적은 없으나, 일반적인 질문을 담아보았습니다.

<details>
  <summary>Docker란 무엇이고 컨테이너 가상화를 왜 사용할까요?</summary>
  </br>
  <p></p>
</details>

<details>
  <summary>컨테이너 환경에서의 디버깅은 어떤식으로 하며 상대적으로 어려운 점은 무엇인가요?</summary>
  </br>
  <p></p>
</details>

### DevOps

DevOps는 어쩌면 신입에겐 물어보지 않을 수도 있습니다. 하지만 DevOps가 무엇인지 정도는 알아두는게 좋을 것 같습니다.

<details>
  <summary>CI/CD가 무엇인가요? 왜 CI/CD가 장점이 될까요?</summary>
  </br>
  <p>보통 이 질문을 하는 동시에 어떤 CI/CD를 써봤는지 질문을 할 것입니다. 그때 썼던 CI/CD툴을 설명하고, 그 툴의 장단점을 설명하면 좋습니다.</p>
  <p>코드 버전 관리를 하는 VCS 시스템에 push가 되면 테스트와 빌드가 수행되어 안정적인 배포파일을 만드는 과정을 CI(지속적 통합, continuous integration)이라고 하며, 이 빌드 결과를 자동으로 운영 서버에 배포까지 되는 과정을 CD(지속적 배포, continuous delivery or continuous deployment)라고 합니다.</p>
  <p>푸시가 될 때마다 코드를 병합하고, 테스트 코드와 빌드를 수행하면서 자동으로 코드가 통합되어 더는 수동으로 코드를 통합할 필요가 없어져 개발에만 신경을 쓸 수 있습니다.</p>
  <p>이 CI / CD의 중요한 것은 테스트 자동화입니다. 프로젝트의 완전한 상태임을 보장하기 위해 테스트 코드가 구현되어 있어야 합니다.</p>
</details>

<details>
  <summary>DevOps가 무엇인지 설명해주세요.</summary>
  </br>
  <p>DevOps는 애플리케이션과 서비스를 빠른 속도로 제공할 수 있도록 조직의 역량을 향상시키는 문화와 방식이며 자동화, 측정, 공유를 수행하고 이 모든 것들을 축적해나가는 것입니다.</p>
  <p>DevOps를 수행하면, 기존의 개발 및 인프라 관리 프로세스를 사용하는 조직보다 제품을 더 빠르게 혁신하고 개선할 수 있습니다. 이를 통해서 고객 친화적이고, 시장에 효과적으로 대응할 수 있는 유연성을 얻을 수 있습니다.</p>
</details>

### 커뮤니케이션

정답이 없는 질문입니다. 면접관마다 의도하는 답이 다 다를테니 자신만의 방법을 한 번 쯤 생각해보고 답변에 막힘이 없도록 준비합시다.

<details>
  <summary>어떤 기술이나 방법론이 좋아보일 때, 이를 어떻게 설득할 것인가요?</summary>
  </br>
  <p></p>
</details>

<details>
  <summary>일정이 예상보다 지연될 것 같습니다. 어떻게 해결하실 것인가요?</summary>
  </br>
  <p></p>
</details>

<details>
  <summary>팀원과의 갈등이 있었나요? 있었다면 어떻게 대처했나요?</summary>
  </br>
  <p></p>
</details>

### 개인의 역량

<details>
  <summary>본인이 수행한 프로젝트 중 상용화 가능한 프로젝트가 있나요?</summary>
  </br>
  <p></p>
</details>

<details>
  <summary>기술을 습득할 때 어떤 식으로 습득하나요?</summary>
  </br>
  <p></p>
</details>

### 최신기술에 관심이 있는지

최신기술에 관심이 있는지 정도를 확인하고자 함입니다. 너무 정확하게 말하지 않아도 관심이 있다는 인상정도를 줄 수 있다면 좋겠습니다.  
그 회사의 기술 스택을 찾아보고 관심을 가져봤다 정도의 느낌을 줄 수 있어야합니다.  
사용까지 해보면 더더욱 좋을 것 같습니다.

<details>
  <summary>protobuf에 대해서 알고계신가요? 이것은 왜 사용할까요?</summary>
  </br>
  <p>JSON이 가진 문제점을 보완하기 위한 하기위한 직렬화 방법</p>
  <p>JSON은 문자열 형식이기 때문에 바이트를 많이 사용한다. 하지만 프로토버프는 속성값을 숫자로 대체해서 바이트 스트림으로 만들기 때문에 훨씬 용량을 적게 소모한다.</p>
  <p>장점으로는 데이터 크기가 작아 데이터 통신이 빠르다. 또한 파싱을 할 필요가 없다.</p>
  <p>단점으로는 사람이 읽기 어렵고, 학습비용이 조금 있다.(proto의 문법을 알아야 한다.)</p>
</details>

<details>
  <summary>gRPC는 무엇이며, RPC는 무엇인가요? 왜 쓸까요?</summary>
  </br>
  <p>gRPC는 HTML/JSON 방식의 비효율성을 개선하기 위해 나온 것입니다.</p>
  <p>RPC는 원격에 있는 프로시져(함수)를 로컬에 있는 것처럼 호출할 수 있도록 해주는 기술로 학습비용이 있기에 잘 사용되지 않았습니다.</p>
  <p>최근의 아키텍쳐 트렌드는 MSA를 기반으로 한 분산시스템으로 구성됩니다. MSA는 결국 각 서비스의 API를 호출하는 식으로 네트워크 통신을 하게 되는데, HTML/JSON보다는 gRPC/protobuf가 더 빠른 속도를 보이게 됩니다. 그로인해 서비스의 응답속도도 빨라질 수 있게됩니다.</p>
</details>

<details>
  <summary>쿠버네티스가 무엇인가요? 왜 쿠버네티스를 쓸까요?</summary>
  </br>
  <p></p>
</details>

### 웹서버의 동작과정

## 면접 꿀팁

회사의 기술스택에 관심을 가져보세요. 학습능력이 좋음을 어떤식으로 보여줄 수 있을까요?

본인이 수행한 프로젝트를 유의미한 트래픽이 나올정도로 해본 경험을 높게 평가하는 회사가 많습니다.

두괄식으로 답변하도록 합시다. (사실 힘듭니다. 그렇게 될 수 있게끔 연습 또 연습!)

프로젝트를 수행할 때, 내가 이 기술을 단순히 좋아보여서 사용한 것이 아니라, 많은 고민을 했음을 보여주도록 하세요. 가장 간단한 질문으로는 '왜 그 기술을 사용했나요?', '그 기술 말고 다른 기술은 왜 사용하지 않았나요?', '대체할만한 기술이 있나요?' 등이 있습니다.
