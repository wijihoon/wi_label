프로세스
•  동작을 시작하게 된 프로그램을 프로세스라 하며, 프로세스는 실핼 중인 프로그램 을 의미한다.
•  프로그램이 프로세스가 되는 과정에서는 크게 2가지 일이 일어난다.
•  운영체제는 프로세스가 필요로 하는 재료를 메모리의 code, data, heap, stack 영역에 올려준다.
•  프로세스의 정보를 담은 PCB (Process Control Block) 블록이 메모리에 올라간다.

프로세스 메모리 공간
• Text: CPU에서 수행되는 명령어를 저장하는 곳이다. Code 영역이라고도 하며, 코드 자체를 구성하는 메모리 영역으로 Hex 파일이나 Bin 파일을 저장하는 메모리다.
• Data: 정적 변수. 배열, 구조체 등이 저장되는 곳이다. 초기화된 데이터는 Data 영역에 저장되고, 초기화 되지 않은 데이터는 BSS(Block Stated Symbol) 영역에 저장되며, 프로그램 종료시 시스템에 반환된다.
• Heap: 동적 데이터가 저장되는 곳이다.
• Stack: 지역 변수와 인자, 함수의 리턴 주소가 저장되는 곳이다. 함수 호출 시 생성되고, 함수가 끝나면 반환된다. Stack 사이즈는 각 프로세스마다 할당되지만, 프로세스가 메모리에 로드될 때 Stack 사이즈가 고정되어 있기 때문에 런타임 시에 Stack 사이즈를 바꿀 수는 없다.

PCB 블록
운영 체제가 프로세스에 대한 중요한 정보를 저장해 놓는 곳으로, Task Control Block 또는 Job Control Block이라고도 한다. 각 프로세스가 생성될 때마다 고유의 PCB가 생성되며 프로세스가 완료되면 PCB는 제거된다. PCB 블록은 메모리 중에서도 커널 스택과 같이 보호받을 수 있는 메모리에 저장된다.

스레드
• 프로세스 내에서 실행되는 여러 흐름의 단위
• 스레드는 프로세스 내에서 레지스터와 Stack만 따로 할당 받고 Code, Data, Heap 영역은 스레드끼리 공유한다.

프로세스와 스레드의 차이
• 프로세스는 운영체제로부터 자원을 할당 받는 작업의 단위이지만, 스레드는 할당 받은 자원을 이용하는 실행의 단위다.
• 프로세스는 자신만의 고유 공간과 자원을 할당 받아 사용하는데 반해, 스레드는 다른 스레드와 공간 자원을 공유하면서 사용한다.
• 하나의 프로세스 내에 1개 이상의 스레드를 가질 수 있다.

멀티 프로세스
장점
• 각 프로세스가 독립된 영역(Code, Data, Heap, Stack)을 가지고 있기 때문에 여러 자식 프로세스 중 하나에 문제가 발생하여도 해당 프로세스에만 영향을 미친다.
• 메모리 침범 문제를 OS 차원에서 해결하므로 안전하다.
단점
• 작업량이 많아지면 Context Switching시 오버헤드가 발생한다.
• 프로세스 간의 복잡한 통신(IPC)가 필요하다.

멀티 스레드
장점
• 메모리 공간, 시스템 자원의 효율성이 증가한다.
• Context Switching시 교환해야 할 대상이 적으므로 비용이 적다.
• Data, Heap 영역을 이용해 데이터를 주고 받으므로 스레드 간 통신이 간단하다.
단점
• 서로 다른 스레드가 Stack을 제외한 메모리 공간을 공유하기 때문에 동기화 문제가 발생할 수 있다.
• 스레드 간의 자원 공유는 전역 변수(데이터 세그먼트)를 이용하므로 다른 스레드가 동시에 사용할 때 충돌이 발생할 수 있다.
• 하나의 스레드에 문제가 생기면 전체 스레드가 영향을 받는다.
• 주의 깊은 설계가 필요하며 디버깅이 까다롭다.
• 멀티 스레드의 단점은 Critical Section 기법을 통해 대비할 수 있다.

멀티 프로세싱
• 두 개 이상의 CPU가 협력적으로 하나 이상의 작업을 동시에 처리하는 것이다.
• 레지스터와 캐시를 독립적으로 가진 여러 개의 CPU가 1개의 메모리에 연결된 구조다.

멀티 코어
• CPU 칩 내부에 레지스터와 캐시를 갖고 있는 코어만 따로 회로를 구성한 구조다.
• 해당 코어가 2개 이상이면서 동시에 한 개 이상의 작업을 처리하는 것이다.

Context Switching
수행 중인 Task(Process/Thread)가 변경될 때, CPU의 레지스터 정보가 변경되는 것을 뜻한다. 즉, 이전 프로세스의 상태를 PCB에 보관하고, 다른 프로세스의 정보를 PCB에서 읽어와 CPU 레지스터에 적재하는 과정이다.

OSI 7 계층
네트워크에서 통신이 일어나는 과정을 7단계로 나눈 것을 말한다.
Application(응용) 계층 : 최종 목적지로 응용 프로그램과 연관하여 서비스를 수행하는 계층
o  ex) HTTP, FTP, DNS
Presentation(표현) 계층 : 데이터 압축, 변환이 이뤄지는 계층
o  ex) JPEG, MPEG
Session(세션) 계층 : 데이터가 통신하기 위한 논리적 연결을 담당하는 계층
o  ex) API, Socket
Transport(전송) 계층 : 종단 간의 사용자들에게 신뢰성 있는 데이터를 전달하는 계층
o  흐름 제어 : 송신측과 수신측 사이의 데이터 처리 속도 차이를 제어
o  혼잡 제어 : 네트워크 혼잡을 피하기 위해 데이터의 전송 속도 제어
o  오류 제어 : 오류 검출과 재전송
Network(네트워크) 계층 : IP를 지정하고 라우터로 경로를 선택해 네트워크를 통해 패킷을 전달하는 계층
Data Link(데이터링크) 계층 : 신뢰성 있는 전송을 보장하기 위한 계층
o  오류 제어, 흐름 제어, 회선 제어
Physical(물리) 계층 : 전기적, 물리적 세부 사항을 정의하는 계층

TCP/IP란?
TCP/IP는 패킷 통신 방식의 인터넷 프로토콜인 IP와 전송 조절 프로토콜인 TCP를 합쳐서 부르는 말이다. HTTP, FTP, SMTP 등 TCP를 기반으로 한 많은 수의 애플리케이션 프로토콜들이 IP 위에서 동작하기 때문에, 묶어서 TCP/IP라 부른다.

TCP란?
TCP는 클라이언트와 서버가 연결된 상태에서 데이터를 주고 받는 연결 지향적 프로토콜이다. 

TCP의 특징은?
연결형 서비스로 가상 회선 방식을 제공하며, 3-way handshaking 과정을 통해 연결을 설정하고, 4-way handshaking 과정을 통해 연결을 해제하기 때문에 정확하고 안정적으로 데이터를 전달할 수 있다는 특징이 있다.

TCP/IP 4계층이란?
TCP/IP는 애플리케이션 계층, 트랜스포트 계층, 네트워크 계층, 링크 계층으로 이루어져 있다. 애플리케이션 계층은 애플리케이션끼리 주고 받을 데이터를 생성하고, 트랜스포트 계층은 수신 측 애플리케이션으로 전달하는 것을 도와주며, 네트워크 계층은 IP 주소를 바탕으로 수신 측까지 데이터를 전달하는 것을 도와준다. 마지막으로 링크 계층은 물리적 주소인 MAC 주소를 바탕으로 네트워크에 직접 연결된 기기 간의 데이터 전송을 도와준다.

TCP/IP 통신의 흐름을 설명하라. (ex. 웹 브라우저에 'www.google.com'을 입력한 경우
1. www.google.com을 브라우저 주소창에 입력한다.
2. 브라우저는 캐싱된 DNS 기록을 통해 www.google.com에 대응되는 IP 주소가 있는지 확인한다.
o  브라우저 캐시 확인
o  OS 캐시 확인
o  라우터 캐시 확인
o  ISP 캐시 확인
3. 요청한 URL이 캐시에 없으면 ISP(인터넷 서비스 제공자, kt 등)의 DNS 서버가 www.google.com을 호스팅하고 있는 서버의 IP 주소를 찾기 위해 DNS query를 날려서 찾는다.
4. 브라우저는 IP주소를 받아 서버와 TCP 연결을 한다. (3 way handshaking)
o  클라이언트가 서버로 접속 요청 SYN 패킷을 보낸다.
o  서버에서는 수락하는 ACK와 SYN 패킷을 보낸다.
o  클라이언트는 서버에게 확인 응답으로 ACK 패킷을 보낸다.
5. TCP 연결이 완료되면 브라우저가 웹 서버에 HTTP 요청을 보낸다.
6. 서버는 요청을 처리하고 response를 생성하고 보낸다.
7. 브라우저가 HTML content를 사용자에게 보여준다.

3-way handshaking이란?
. 클라이언트는 서버에게 접속을 요청하는 SYN 플래그가 설정된 패킷을 보낸다.
. 이때 서버는 Listen 상태로 포트 서비스가 가능한 상태이어야 한다. 서버는 SYN 요청을 받고 클라이언트에게 요청을 수락한다는 ACK과 SYN 플래그가 설정된 패킷을 발송하고 응답을 기다린다.
. 클라이언트는 서버로부터 ACK과 SYN 플래그가 설정된 패킷을 받고 ACK 플래그가 설정된 패킷을 발송한다.
. 연결이 이루어지고 데이터가 오가게 된다.
4-way handshaking이란?
. 클라이언트가 서버에게 연결을 종료하겠다는 FIN 플래그가 설정된 패킷을 보낸다.
. 서버는 확인했다고 알려주기 위해 ACK 플래그가 설정된 패킷을 보낸 후, 자신의 통신이 끝날 때까지 기다린다. (TIME_WAIT) 이때 자신이 전송할 패킷이 남아있다면 이어서 전송한다.
. 서버의 통신이 끝났으면 연결 종료 요청에 합의한다는 의미로 클라이언트에게 FIN 플래그가 설정된 패킷을 보낸다.
. 클라이언트는 확인했다는 의미로 ACK 플래그가 설정된 패킷을 보낸다.
. 연결이 종료된다.

HTTP란?
HTTP(Hyper Text Transfer Protoco)는 텍스트 기반의 통신 규약으로, 인터넷 상에서 데이터를 주고 받기 위해 서버/클라이언트 모델을 따르는 프로토콜이다. 

Request Method를 아는 대로 설명해 보시오.
•  Get: 자료를 요청할 때 사용
•  Post: 자료의 생성을 요청할 때 사용
•  Put: 자료의 모든 부분에 대해 수정을 요청할 때 사용
•  Patch: 자료의 일부분에 대해 수정을 요청할 때 사용
•  Delete: 자료의 삭제를 요청할 때 사용
•  Options: preflight 요청할 때 사용 (CORS와 관련이 있음.)

HTTP의 특징은?
•  TCP/IP를 위에서 동작하는 응용 프로토콜이다.
•  연결 상태를 유지하지 않는 비연결성 프로토콜이다.
•  상태가 없는 무상태 프로토콜이다.
•  요청/응답 방식으로 동작한다.

HTTP의 특성 중 비연결성 프로토콜이 무엇인가?
클라이언트와 서버가 한 번 연결을 맺은 후, 클라이언트 요청에 대해 서버가 응답을 마치면 맺었던 연결을 끊어 버리는 프로토콜이다. 수십 만 명이 웹 서비스를 사용하더라도 접속 유지는 최소한으로 할 수 있기 때문에 더 많은 유저의 요청을 처리할 수 있지만, 클라이언트의 이전 상태를 알 수 없어서 Stateless하다는 특징이 있다.

HTTP의 특성 중 무상태가 무엇인가?
비연결적인 특성으로 연결이 해제됨과 동시에 서버와 클라이언트가 이전에 요청한 결과에 대해서 잊어버리게 된다. 즉, 클라이언트가 이전 요청과 같은 데이터를 원한다고 하더라도 다시 서버에 연결을 하여 동일한 요청을 시도해야 한다. HTTP는 이러한 무상태 특성으로 인해 독립적인 쌍의 요청과 응답을 처리하기 때문에, 단순하고 상태를 저장해야 하는 서버의 부담을 줄일 수 있다. 

HTTP는 무상태인데 로그인과 같은 인증을 어떻게 구현하는가?
최초의 로그인 요청에서 응답으로 받은 아이디와 비밀 번호를 쿠키에 담으면 이전 결과를 저장해 둘 수 있다. 

쿠키에 바로 아이디와 비밀 번호를 담으면 탈취될 시 위험하지 않은가?
그래서 쿠키에 아이디와 비밀 번호를 바로 담기보다는 세션 ID나 토큰을 담아서 보안을 강화한다.(이후 세션, 토큰 질문이 나올텐데 인증 주제가 아니므로 자세한 내용은 생략.) HTTPS
 HTTPS는 Hypertext Transfer Protocol Secure의 약자로 보안이 강화된 HTTP 프로토콜이다. HTTP 프로토콜만으로 통신을 수행하면, 다음과 같이 평문 데이터가 모두 노출이 된다. 즉, 암호화되지 않은 데이터를 전송하기 때문에 서버와 클라이언트가 주고 받는 메시지를 외부에서 볼 수 있기 때문에 보안에 취약하다. 이러한 취약점을 보완하고자 만들어진 것이 바로 HTTPS다. 
와이어 샤크를 이용하면 위와 같이 HTTP 패킷을 확인할 수 있는데, 유저의 민감한 데이터가 그대로 노출되는 것을 확인할 수 있다. 

HTTPS의 동작 과정
HTTPS는 SSL이라는 보안 프로토콜 위에서 동작하는 HTTP다. 그렇다면, SSL과 TLS가 무엇일까?  SSL은 Secure Socket Layer의 약어로, 응용 계층과 전송 계층 사이에서 동작하는 보안 소켓 계층을 뜻한다. 인터넷 상에서 데이터를 안전하게 전송하기 위한 인터넷 암호화 통신 프로토콜이라고 생각하면 된다. SSL은 전자상거래 등의 보안을 위해 넷스케이프 사에서 처음 개발하였고, 시간이 지나 TLS로 표준화하였다.

TCP/IP 통신에서 흐름 제어 기법이 왜 사용되는가?
송 수신자 간의 TCP 버퍼의 크기 차이로 인해 생기는 데이터 처리 속도 차이를 해결하기 위해 사용된다.

TCP/IP 흐름 제어 기법은 무엇이 있는가?
Stop and Wait과 Sliding Window 기법이 있다. Stop and Wait은 전송한 패킷에 대해 확인 응답(ACK)을 받으면 다음 패킷을 전송하는 제어 기법이고, Sliding Window는 수신 측에서 설정한 윈도우 크기만큼 송신 측에서 확인 응답(ACK) 없이 패킷을 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 제어 기법이다.

TCP/IP 혼잡 제어 기법이 왜 사용되는가?
송신 측에서 보내는 데이터의 양이 라우터가 처리할 수 있는 양을 초과하면 초과된 데이터는 라우터가 처리하지 못한다. 송신 측은 초과된 데이터를 손실 데이터로 간주하고 계속 재전송하여 네트워크를 혼잡하게 한다. 이런 상황을 예방하기 위해 송신 측의 전송 속도를 적절히 조절하는 혼잡 제어 기법이 사용된다. 대표적으로 AIMD, Slow Start, 빠른 재전송, 빠른 회복 등이 있다. 

TCP/IP 혼잡 제어 정책은 무엇이 있는가?
대표적으로 TCP Tahoe와 TCP Reno가 있다. TCP Tahoe는 처음에는 Slow Start를 사용하여 자신의 윈도우 크기를 지수적으로 빠르게 증가시키다가 ssthresh를 만난 이후부터는 AIMD을 사용하여 선형적으로 윈도우 크기를 증가시킨다. 반면, TCP Reno는 Tahoe와 마찬가지로 Slow Start로 시작하여 임계점을 넘어서면 AIMD을 사용하되, Tahoe와 다르게 3 ACK Duplicated와 Timeout 혼잡 상황을 구분한다.

IPC란 무엇인가?Á
IPC는 프로세스들 사이에 서로 데이터를 주고 받는 방식, 즉 프로세스 간의 통신을 의미한다. 각 프로세스는 독립적인 실행 객체이기 때문에 프로세스 간 통신을 하려면 커널이 제공하는 IPC 모델 방식을 사용해서 통신을 해야 한다. 

IPC의 예시는 무엇이 있는가?
IPC는 크게 두 가지 모델로 나눌 수 있다. 첫 째는 주소 공간의 일부를 공유하며 공유한 메모리 영역에 읽기/쓰기를 통해 통신하는 공유 메모리 모델이 있으며, 공유 메모리 모델의 예시로는 공유 메모리와 POSIX가 있다. 두 번째로는 메시지 전송 모델이다. 커널 메모리 영역에 메시지 전달을 위한 채널을 만들어서 송수신자 간에 전송/수신을 통해 통신하는 방식이다. 예시로는 파이프, 메시지 큐, 소켓 등이 있다. 

위에서 말한 두 모델의 장단점을 설명하라.
• 공유 메모리 모델의 경우, 커널의 관여 없이 메모리를 직접 사용하여 통신하기 때문에 통신 속도가 빠른 장점이 있지만, 별도의 동기화 과정이 필요하며 동시에 메모리 위치를 접근하는 문제가 발생할 수 있다는 단점이 있다. 따라서 별도의 접근 제어 방법이 필요하며, 접근 제어 방식은 locking이나 세마포어(semaphore) 등이 있다.
• 메시지 전달 모델의 경우, 커널을 통해서 데이터를 주고 받기 때문에 통신 속도가 느리다는 단점이 있지만, 커널에서 데이터를 주고 받는 과정을 컨트롤할 수 있어 안전하며 send/receive 연산에 대해 커널이 동기화를 제공해준다는 장점이 있다.

SSL Handshake란?
Handshake는 악수를 의미하는데, 통신을 하는 브라우저와 웹 서버가 서로 암호화 통신을 시작할 수 있도록 신분을 확인하고 필요한 정보를 클라이언트와 서버가 주거니 받거니 하는 과정이 악수와 비슷하여 붙여진 이름이다.

대칭 키란?
하나의 키로 데이터를 암호화하고 복호화하는 것을 의미한다. 암호화 및 복호화에 드는 비용이 적지만, 대칭 키가 유출되면 암호의 내용이 쉽게 노출된다는 단점이 있다.

비대칭 키란?
비대칭 키는 공개 키와 개인 키로 암호화 및 복호화를 수행한다. 즉, 공개 키로 데이터를 암호화하면 반드시 개인 키로만 복호화 가능하고, 개인 키로 데이터를 암호화하면 공개 키로만 복호화 할 수 있다. 보안성이 뛰어나다는 장점이 있지만, 구현하기가 어렵고 암호화 및 복호화 속도가 느리다는 단점이 있다.

SSL Handshake 과정을 손으로 그려 보세요.
실제 면접에서 나왔었는데 매우 당황했었음. 위에서 설명한 "대칭 키와 비대칭 키를 혼합하여 사용" 챕터를 기본적으로 확실하게 이해하여 설명하는 것을 기본으로 두고, 인증 기관까지 질문이 나오면 "그림으로 보는 SSL Handshake" 챕터 부분을 설명하면서 그림을 그리면 된다.

SSL Handshake의 과정을 설명해 보세요.
서버는 CA에 사이트 정보와 공개 키를 전달하여 인증서를 받음 → 클라이언트는 브라우저에 CA 공개 키가 내장되어 있다고 가정 → ClientHello(암호화 알고리즘 나열 및 전달) → Serverhello(암호화 알고리즘 선택) → Server Certificate(인증서 전달) → Client Key Exchange(데이터를 암호화 할 대칭 키 전달) → Client / ServerHello done (정보 전달 완료) → Finished(SSL Handshake 종료)

TCP란?
TCP는 네트워크 계층 중 전송 계층에서 사용하는 프로토콜로서, 장치들 사이에 논리적인 접속을 성립하기 위해 연결을 설정하여 신뢰성을 보장하는 연결형 서비스다. TCP는 네트워크에 연결된 컴퓨터에서 실행되는 프로그램 간에 패킷을 안정적으로 순서대로 에러 없이 교환할 수 있게 된다. 

TCP의 특징은?
연결형 서비스로 가상 회선을 제공하고, 흐름 제어 및 혼잡 제어 역할을 한다. 또한, 신뢰성이 높은 전송을 하며 점이중, 점대점 방식을 지원한다.

TCP의 단점은?
데이터로 보내기 전에 반드시 연결이 형성되어야 하며, 1:1 통신만 가능하다. 또한, 고정된 통신 선로가 최단선(네트워크 길이)이 아닐 경우 상대적으로 UDP보다 데이터 전송 속도가 느리다. 

UDP란?
UDP는 전송 계층의 비 연결 지향적 프로토콜이다. 비연결 지향적이란 연결을 위해 할당되는 논리적인 경로가 없고 각각의 패킷은 다른 경로로 전송되어 독립적인 관계를 지니게 되는 것을 말한다. 이렇게 데이터를 서로 다른 경로로, 독립적으로 처리하는 프로토콜을 UDP라고 한다. 

UDP가 어디에 사용되고, 왜 사용되는가?
UDP는 비연결형 서비스이기 때문에, 연결을 설정하고 해제하는 과정이 존재하지 않는다. 서로 다른 경로로 독립적으로 처리함에도 패킷에 순서를 부여하여 재조립을 하거나 흐름 제어 또는 혼잡 제어와 같은 기능도 처리하지 않기에 TCP보다 속도가 빠르며 네트워크 부하가 적다는 장점이 있다. 다만 신뢰성 있는 데이터의 전송을 보장하지는 못하므로 신뢰성보다는 연속성이 중요한 실시간 스트리밍 서비스에 자주 사용된다.

UDP의 단점은?
데이터의 신뢰성이 없고, TCP와는 다르게 데이터를 쪼개주지 않아 애플리케이션 단에서 직접 패킷을 쪼개 일일이 관리해야 하는 단점이 있다.

세마포어와 뮤텍스의 차이
• 가장 큰 차이점은 뮤텍스는 동기화 대상이 자원의 하나라면, 세마포어는 하나 이상의 자원에서 사용 가능하다. Mutex는 상태가 0과 1인 이진 세마포어라고 볼 수 있다.
• 세마포어는 소유할 수 없는 반면, 뮤텍스는 소유가 가능하며 소유주가 이에 대한 책임을 진다. (뮤텍스의 경우 상태가 두 개뿐인 lock이므로 lock을 가질 수 있다.)
• 뮤텍스는 Locking 메커니즘으로 locking을 걸은 쓰레드만이 임계 영역을 나갈 때 락을 해제할 수 있다. 하지만, 세마포어는 Signaling 메커니즘으로 lock을 걸지 않은 쓰레드도 signal을 사용해 락을 해제할 수 있다.
• 세마포어는 시스템 범위에 걸쳐 있고 파일 시스템 상의 파일 형태로 존재하지만, 뮤텍스는 프로세스 범위를 가지며 프로세스가 종료될 때 자동으로 해제된다.

이진 세마포어와 뮤텍스의 차이
뮤텍스와 이진 세마포어의 핵심 차이는 뮤텍스와 의 경우 lock을 설정한(값을 0으로 설정한) 프로세스만이 lock을 해제할 수 있다. 반면, 이진 세마포어의 경우 lock을 설정한 프로세스와 해제하는 프로세스가 서로 다를 수 있다.

데드락이란 무엇인가?
데드락은 교착 상태라고도 불리며, 프로세스가 자원을 얻지 못해서 다음 처리를 하지 못하는 상태를 뜻한다. 흔히 다중 프로그래밍에서 발생하는 문제로, 두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태가 된다. 

데드락이 발생하는 조건은 무엇인가?
데드락이 발생하기 위해서는 조건 상호 배제, 점유 대기, 비선점, 그리고 순환 대기. 총 4가지 조건이 만족되어야 하며, 하나라도 만족되지 못하면 교착 상태가 발생하지 않는다.상호 배제는 자원은 한번에 한 프로세스만 사용할 수 있다는 조건, 점유 대기는 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다리고 있다는 조건, 비선점은 다른 프로세스에 할당된 자원은 사용이 끝날 때 까지 강제로 빼앗을 수 없다는 조건, 순환 대기는 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있다는 조건이다.

데드락을 해결할 수 있는 방법에는 어떤 것이 있는가
예방
• 교착 상태의 4가지 조건 부정
회피
• 자원 할당 그래프 알고리즘
• 은행원 알고리즘
• 탐지
• 대기 그래프
• Shoshani & Coffman 알고리즘
회복
• 프로세스 종료법
• 자원 선점법

은행원 알고리즘을 설명해보아라
은행원 알고리즘이란 다중 프로그래밍 환경에서 교착 상태가 발생했을 때 해결하는 회피 알고리즘 중 하나이다. 은행원 알고리즘은 프로세스가 자원을 요청했을 때, 자원을 주게 된다면 교착 상태가 발생할 수 있는 상태가 되는지 예측한 후, 그렇지 않은 경우에만 요청에 응하는 방식으로 교착 상태를 회피한다.따라서 프로세스가 자원을 요청하는 자원 요청 알고리즘과 해당 요청을 응했을 때 교착 상태가 발생할 수 있는 상태가 되는지, 즉, 안전 상태가 유지되는지 판별하는 안전 알고리즘을 이용하여 은행원 알고리즘을 구현할 수 있다. 

은행원 알고리즘의 문제(단점)는 무엇인가
• 할당할 수 있는 자원의 수가 일정해야 한다.
• 사용자 수가 일정해야 한다.
• 항상 불안전 상태를 방지해야 하기 때문에 자원 이용도가 낮다.
• 최대 자원 요구량(Max)를 미리 알아야 한다.
• 프로세스들은 유한한 시간 안에 자원을 반납해야 한다.
결국 은행원 알고리즘은 구현이 복잡하고, 프로세스의 최대 자원 요구량을 미리 알아야 한다는 점에서 실질적으로 사용하기에는 어렵다.

IP란?
IP는 인터넷 프로토콜의 약자로, 송신 호스트와 수신 호스트가 패킷 교환 네트워크에서 정보를 주고받는 데 사용하는 정보 위주의 규약이며, OSI 네트워크 계층에서 호스트의 주소 지정과 패킷 분할 및 조립 기능을 담당한다. 비신뢰성과 비연결성이 특징이다. 

IP 주소란?
IP 주소는 네트워크 환경에서 컴퓨터(노드) 간 통신하기 위해 각 컴퓨터에 부여된 네트워크 상 주소이다. 전 세계의 IP 주소는 미국의 'Inter NIC'에서 총괄적으로 관리하며 분배하고 있다. 우리나라의 경우 '한국 인터넷 정보 센터(KRNIC)'에서 'Inter NIC'로부터 할당 받은 IP를 다시 각 인터넷 사업체를 통해 해당 서비스의 사용자에게 IP 주소를 할당하고 있다. 

IPv6 주소가 생겨난 이유는?
IP 주소라는 개념이 처음 생겼을 당시에는 지금처럼 네트워킹이 가능한 장비의 종류가 다양하지 않았지만, 기술이 발전하고 한 사람이 가지는 네트워킹 단말기가 증가하면서 IPv4 주소의 수가 부족해졌다. 이를 해결하기 위해 주소 길이를 128 비트로 늘려 사용 가능한 주소의 개수를 2의 128제곱 개 늘린 IPv6 주소가 등장했다.

MAC 주소란?
MAC 주소는 데이터 링크 계층에서 통신을 위한 네트워크 인터페이스(보통 NIC)에 할당된 고유 식별자이다. 이더넷 하드웨어 주소, 물리적 주소, 하드웨어 주소라고도 불리며, 다른 MAC 주소와 겹치지 않는 특징이 있다.

통신할 때 IP 주소 외에 MAC 주소가 필요한 이유는?
우리가 미국에서 서울에 살고 있는 상우의 컴퓨터와 통신을 하고 싶다고 가정하자. 이때 상우가 알려준 IP 주소가 상우의 컴퓨터라는 사실을 보증할 수가 없다. 위에서 말한 유동 IP의 특징으로 인해 IP 자체가 변동될 수 있기 때문이다. 결국 절대 변하지 않는 하드웨어의 고유 주소 번호가 필요한데, 그것이 바로 MAC 주소다.

통신할 때 MAC 주소 외에 IP 주소가 필요한 이유는?
MAC 주소는 데이터 링크 계층 프로토콜이므로 통신할 상대방이 나와 가까운 곳에 있다면 괜찮지만, 한국에서 미국에 있는 A 컴퓨터에 데이터가 가기 위해서는 나와 연결된 어떤 컴퓨터에게 데이터를 넘겨야 하는지 MAC 주소로 판단하기 어렵다. 이를 해결하기 위해 IP 주소가 필요하다. IP 주소는 전체적인 맵을 보고 방향성을 알려주는 역할을 한다고 생각하면 된다. IP 주소는 네트워크 주소와 호스트 주소로 나뉘므로 실생활에서 우편물이나 택배를 보낼 때 사용하는 계층형 주소 원리와 유사하기 때문이다.

IP 주소와 MAC 주소의 차이점
MAC 주소•  데이터 링크 계층에서 사용되는 주소이다.
• 거리가 가까운 주변 장치끼리 통신할 수 있다.
• 총 48비트(6 bytes)로 구성되어 있으며 : 으로 구분한다. ex) 11:32:FF:2C:4B:AB
• 변하지 않는 값이다.
• 물리적 주소라고도 부른다.
• 제조할 때 장치에 입력된다.
IP 주소
• 네트워크 계층에서 사용되는 주소이다.
• 글로벌 단위에서 장치 간의 통신이 가능하도록 도와준다.
• IPv4, IPv6 방식 중 하나를 채택하여 사용한다.
• 때때로 변할 수 있는 값이다.
• 논리적 주소라고도 부른다.
• 소프트웨어 설정을 통해 장치에 할당된다.

DNS란?
TCP/IP 네트워크 상에서 사람이 기억하기 쉽게 문자로 만들어진 도메인을 숫자로 된 IP 주소로 바꾸는 서버를 DNS라고 한다. 

DNS 서버에게 IP 주소를 요청할 때 UDP를 사용하는 이유는?
DNS는 신뢰성보다 속도가 더 중요하고, 많은 클라이언트를 수용하는 것을 필요로 한다. 따라서 속도가 빠르고, 연결 상태를 유지하지 않고 정보 기록을 최소화하여 많은 클라이언트 수용이 가능한 UDP를 사용한다.

DNS 서버의 종류에 대해 설명하라.
Root DNS Server, TLD DNS Server, Authoritative DNS Server, Recursive DNS Server로 나누어진다. 

DNS 서버를 여러 종류로 나누는 이유는?
존재하는 도메인 수가 많기 때문에 하나의 DNS 서버만 사용한다면 성능, 유지 관리 등 많은 문제가 생긴다. 따라서 DNS 서버 종류를 계층화해 단계적으로 처리하여 트래픽을 분산하고 유지 및 관리를 안정적으로 하기 위해 나누었다.

DNS의 동작 과정을 설명하라.
. 브라우저에서 Nesite.com을 검색한 뒤, 사용하고 있는 통신사인 KT DNS 서버에게 도메인 주소에 해당하는 IP 주소를 요청한다. (브라우저 기본 DNS 설정은 통신사 DNS 서버이다.)
. ISP 서버에서는 캐시 데이터가 없다는 것을 확인하고 Root DNS 서버에게 어디로 가야 하는지 요청한다. (만약 캐시가 있다면 8번 단계로 건너뛴다.)
. Root DNS 서버는 TLD DNS 서버 주소만 관리하므로 ***.com 도메인을 보고, com 최상위 도메인을 관리하는 TLD DNS 서버 주소를 안내한다.
. ISP 서버는 com 서버에게 어디로 가야 하는지 다시 요청한다.
. com 서버는 가비아 DNS 서버가 해당 도메인이 관리되고 있다는 사실을 확인하고, 가비아 DNS 서버 주소를 안내한다.
. ISP 서버는 가비아 서버에게 다시 요청한다.
. 가비아 서버는 요청 받은 도메인 주소의 IP 주소를 확인하고 알려준다. 동시에 ISP 서버는 해당 정보를 캐시로 기록한다.
. ISP 서버는 브라우저에게 알아 낸 IP 주소를 안내한다.

페이징 또는 세그멘테이션을 사용하는 이유는?
프로그램을 실행하기 위해 코드를 디스크에서 메인 메모리로 적재하는 과정에서 단편화가 생길 수 밖에 없다. 이렇게 단편화가 많이 발생하면 사용하지 못하는 메모리 공간이 많아져 낭비가 되므로 최대한 피해야 한다. 최초 적합, 최적 적합, 압축 등의 방식을 통해 단편화를 해결할 수도 있지만, 메모리 계산의 비용이 적은 페이징 또는 세그멘테이션을 주로 사용한다.

페이징의 특징은?
페이징은 프로그램을 실행할 때, 코드를 메모리에 적재하기 위해 사용하는 기법이며, 불연속 메모리 관리 기법이라는 특징이 있다. 다시 말해 프로그램 전체가 메모리에 연속적으로 올라가 있는 것이 아니라 페이지라는 고정된 크기로 분할되어 올라가 있다. 또한, 페이징은 외부 단편화 문제를 해결할 수 있다.

페이징과 세그멘테이션의 차이는?
페이징과 세그멘테이션 모두 프로그램을 실행하기 위해 디스크에 있는 내용을 분할하여 메모리에 적재하는 불연속 메모리 관리 기법이다. 둘의 차이는 프로그램을 분할하는 방식이다. 페이징의 경우 프로그램을 같은 크기의 페이지로 분할하는 데에 비해, 세그멘테이션은 논리적 의미를 기준으로 세그먼트를 분할한다.

라우팅이란?
라우팅은 경로 정보를 기반으로 현재의 네트워크에서 다른 네트워크로 최적의 경로를 통해 데이터를 전송하는 기법이다.

라우팅 테이블이란?
라우팅 테이블은 패킷을 목적지로 전달하기 위해 참조하는 테이블이다. 토폴로지, 트래픽 부하 여부, 링크 비용, 메시지 등과 같은 라우팅 계산에 필요한 요소를 기반으로 라우팅 프로토콜을 통해 계산된 라우팅 정보를 저장한다.

정적 라우팅 방식에 대해 설명하라.
• 네트워크 관리자가 패킷의 경로를 임의로 결정하여 수동으로 구성하는 라우팅 방식이다.
장점
• 라우터의 부하를 경감할 수 있다.
• 복잡한 계산이 필요 없으므로 빠른 라우팅이 가능하다.
단점
• 관리자가 관리해야 할 부분이 많아진다.
• 네트워크 환경 변화를 고려하지 않는다.
• 정해진 경로 상에서 장애가 발생할 경우, 네트워크 전체 이용에 장애가 발생할 수 있다.
• 네트워크의 규모가 커지면 수동으로 추가하기 위해 시간이 많이 든다.
 
동적 라우팅 방식에 대해 설명하라.
• 라우터가 라우팅 프로토콜에 의한 계산에 따라 스스로 라우팅 경로를 결정하는 방식이다.
장점
• 작업 부담이 없고, 항상 최신 라우팅 정보를 유지할 수 있다.
• 네트워크 환경 변화를 고려한다.
단점
• 라우터의 부하가 크다.
 이해를 돕기 위한 예시현우가 마트에서 장을 보고 싶다. 이때 A마트는 비싸고 멀고, B마트는 싼데 멀고, C마트는 싸고 가깝다. C마트에 가서 장을 보려고 하였으나, C마트가 하필 휴점일이었다. 그래서 철수는 고민 끝에 B마트에서 장을 보았다.
동적 라우팅 방식은 위 예시처럼 C마트가 휴점일이라는 환경 변화를 고려할 수 있고, 그에 따라 동적으로 경로를 결정한다. 상황에 따라 A마트가 될 수 있고, B마트가 될 수 있는데 이것은 라우팅 프로토콜에 따라 다르게 계산된다.

라우팅 프로토콜에 대해 아는 대로 설명하라.
라우팅 프로토콜은 정적 프로토콜과 동적 프로토콜로 나눌 수 있다.여기서 동적 프로토콜은 자율 시스템 (AS) 내부에서만 사용하면 IGP 프로토콜, AS 간의 외부 통신이 필요하면 EGP 프로토콜로 다시 나뉜다.IGP 프로토콜은 거리 벡터 프로토콜과 링크 상태 프로토콜로 나눌 수 있으며, 소규모 네트워크는 경로 벡터 프로토콜을 사용하고 중/대규모 네트워크는 링크 상태 프로토콜을 사용한다.EGP 프로토콜은 경로 벡터 프로토콜을 주로 사용하며, 대표적으로 이를 활용한 BGP 프로토콜이 있다.

거리 벡터 프로토콜이란?
• 이웃 라우터의 주기적 갱신 정보로 라우팅 테이블을 반영하여 경로를 결정하는 프로토콜
• 목적지까지 도달하는 데 필요한 거리와 방향만 라우팅 테이블에 기록
• 분산 벨만 포드 알고리즘으로 구현이 가능

링크 상태 프로토콜이란?
• 각 라우터마다 갈 수 있는 모든 라우터의 최단 경로를 라우팅 테이블에 기록
• 다익스트라 알고리즘으로 구현이 가능
• 홉 수가 많은 중/대형 네트워크에서 사용이 용이함
 
거리 벡터 프로토콜과 링크 상태 프로토콜의 차이


Synchronous & Asynchronous와 Blocking & Nonblocking의 차이
Synchronous와 Asynchronous는 순서와 결과의 관점이라면, Blocking과 Nonblocking은 제어의 관점이라 볼 수 있다.

Synchronous & Asynchronous & Blocking & Nonblocking 차이
동기란, 요청이 들어온 순서에 맞게 하나씩 처리하는 방식이다.
비동기란, 하나의 요청이 끝나기도 전에, 다른 요청을 동시에 처리를 할 수 있는 방식이다. 
블로킹이란, 커널과 같이 제어할 수 없는 대상의 작업이 끝날 때까지 기다려야 하는 방식이다.
ex) I/O 작업이 다 끝날 때까지 해당 애플리케이션은 기다려야 한다.
논블로킹이란, 커널과 같이 제어할 수 없는 대상의 작업이 완료되기 전에, 제어권을 넘겨 받을 수 있는 방식이다.
ex) I/O 작업이 끝나기도 전에 해당 애플리케이션이 수행하던 로직을 추가로 수행할 수 있게 됩니다.

대규모 트래픽에 대처할 수 있는 방법
서버의 성능을 높이는 Scale-up과 분산 처리를 위해 여러 대의 서버를 두는 Scale-out이 있다. Scale-up 방식의 경우 한계가 있으므로 주로 Scale-out 방식을 사용한다. Scale-out 방식에서 분산 처리를 하기 위해 로드 밸런싱 기술을 사용한다.

로드 밸런서의 기본 기능은?
서버의 이상 유무를 파악하는 상태 확인(Health Check), 패킷을 캡슐화해서 연결된 상호 간에만 패킷을 구별할 수 있게 해주는 터널링(Tunneling), IP 주소를 변환해주는 NAT 기능이 있다.

로드 밸런서의 종류?
로드 밸런서는 OSI 7계층을 기준으로 어떻게 부하를 분산하는 지에 따라 종류가 나뉜다. 그 중 L4 로드 밸런서와 L7 로드 밸런서가 가장 많이 활용된다.

L4 로드 밸런서에 대해 설명
L4 로드 밸런서는 L4 계층에서 동작하며, 네트워크 계층이나 트랜스포트 계층의 정보를 바탕으로 트래픽을 분산한다. IP 주소, 포트 번호, MAC 주소, 전송 프로토콜에 따라 트래픽을 분산 처리하는 것이 가능하다.

L7 로드 밸런서에 대해 설명
L7 로드 밸런서는 L4 로드밸런서의 기능을 포함하며 애플리케이션 계층의 정보를 바탕으로도 분산 처리가 가능하다. HTTP 헤더, 쿠키 등과 같은 사용자의 요청을 기반으로 특정 서버에 트래픽을 분산할 수 있다.

로드 밸런싱에 사용되는 알고리즘에 대해 설명
L4 로드 밸런서에는 라운드 로빈, 가중치 할당 방식, 최소 연결, 응답 시간, 해시 가반, 대역폭 기반으로 특정 서버에 요청을 분배할 수 있다. L7 로드 밸런서의 경우 L4 로드 밸런서에 사용되는 방식 뿐만 아니라 URL 스위칭 방식, 컨텍스트 스위치 방식, 쿠키 지속성 방식이 있다. 

로드 밸런서가 장애를 대비하는 방법
로드 밸런서는 갑작스러운 장애에 대비해 이중화를 기본으로 구성한다. 이중화된 로드 밸런서들은 서로의 상태를 확인하며 장애가 발생하면 정상적으로 작동하는 로드 밸런서로 교체된다.

인덱스란?
인덱스는 DBMS의 저장 성능을 희생하고 검색 성능을 높이기 위해 만들어진 자료 구조이다. 

인덱스의 장점과 단점에 대해 설명하라.
장점
• 테이블을 조회하는 속도와 그에 따른 성능을 향상할 수 있다.
• 전반적인 시스템의 부하를 줄일 수 있다.
단점
• 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장 공간이 필요하다.
• 인덱스를 관리하기 위해 추가 작업이 필요하다.
• 인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과가 발생할 수 있다.

인덱스는 언제 사용하는가?
• 규모가 작지 않은 테이블
• INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
• JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼
• 데이터의 중복도가 낮은 컬럼 (카디널리티가 높은 컬럼)

트랜잭션이란 무엇인가?
트랜잭션은 하나의 작업을 수행하기 위해 필요한 데이터베이스의 연산들을 모아놓은 것으로, 데이터베이스에서 논리적인 작업의 단위이며 장애가 발생했을 때 데이터를 복구하는 작업의 단위이다.

트랜잭션의 특성에 대해 설명
원자성(Atomicity)
• 트랜잭션을 구성하는 연산들이 모두 정상적으로 실행되거나 하나도 실행되지 않아야 한다는 all-or-nothing 방식을 의미한다.
일관성(Consistency)
• 트랜잭션이 제약조건, cascade , triggers 를 포함한 정의된 모든 조건에 맞게 데이터의 값이 변경되야 함을 뜻한다.
격리성(Isolation)
• 현재 수행 중인 트랜잭션이 완료될 때까지 트랜잭션이 생성한 중간 연산 결과에 다른 트랜잭션들이 접근할 수 없음을 의미한다.
지속성(Durability)
• 트랜잭션이 성공적으로 완료된 후 데이터베이스에 반영한 수행 결과는 어떠한 경우에도 손실되지 않고 영구적이여야 함을 의미한다.

트랜잭션의 연산에 대해 설명
commit 연산트랜잭션이 성공적으로 수행되었을 때 선언하며, commit 연산이 실행된 후에야 트랜잭션의 수행 결과가 데이터베이스에 반영된다. rollback 연산트랜잭션이 수행을 실패했을 때 선언하며, rollback 연산이 실행되면 트랜잭션이 지금까지 실행한 연산의 결과를 취소하고 수행 전의 상태로 돌아간다.

MyISAM 스토리지 엔진에 대해 설명
MyISAM 스토리지 엔진은 트랜잭션에 안전하지 않은 테이블을 제공하는 스토리지 엔진이다. 장점으로는 항상 테이블에 ROW COUNT를 갖고 있기 때문에 SELECT count(*) 명령시 빠르고, SELECT 명령시에도 빠른 속도를 지원한다. 그러나 트랜잭션을 지원하지 않는다는 점과 레코드 락을 지원하지 않아 쿼리 실행 시 테이블 전체에 락이 걸린다는 단점이 있다.

InnoDB 스토리지 엔진에 대해 설명
InnoDB 스토리지 엔진은 트랜잭션에 안전한 테이블을 제공하는 스토리지 엔진이다. 트랜잭션과 레코드 락을 지원하기 때문에 대용량의 데이터를 처리하는데 있어 유리한 점이 있다. 따라서 CRUD가 많은 서비스에 유리하다.

트랜잭션을 적용할 때 주의해야할 점
데이터베이스 커넥션을 가지고 있는 범위와 트랜잭션이 활성화돼 있는 프로그램의 범위를 최소화해야 하며, 네트워크 작업이 있는 경우에는 반드시 트랜잭션에서 배제해야 한다

B-Tree 구조에 대해 설명하라.
트리의 노드가 한 방향으로 쏠리지 않게 재정렬을 통해, 각 노드 수의 밸런스를 유지하는 트리 형태의 자료구조이다.

B-Tree의 장점과 단점에 대해 설명하라.
장점노드가 균형 있게 구성되어 있어서, 최악의 경우이더라도 일관된 탐색 시간(O(logN))을 가질 수 있다. 단점재정렬을 해야 하는 작업으로 인해, 노드를 삽입 하거나 삭제 할 때 일반적인 트리보다 성능이 떨어진다.

인덱스는 어떻게 작동하는가?
일반적으로 B-Tree 자료 구조를 사용하여 검색해야 할 값을 루트 노드에서부터 비교를 시작해 브랜치 노드를 거치고 최종적으로 리프 노드까지 찾아 들어간다. 그리고 리프 노드의 레코드 주소를 사용하여 실제 데이터 파일에 존재하는 레코드를 읽는다.

멀티 컬럼 인덱스는 언제 사용하는가?
데이터를 조회할 때 단일 인덱스를 여러 개를 사용해야 하는 경우가 많다면 다중 컬럼 인덱스를 고려해 본다. 예를 들어 A, B 컬럼을 바탕으로 데이터 탐색을 자주 할 경우 A, B에 단일 인덱스에 걸려 있는 상태에서 조회하는 성능보다 A, B에 다중 컬럼 인덱스가 걸려 있는 경우에 데이터 액세스가 줄어들어 성능이 더 좋기 때문이다.

멀티 컬럼 인덱스를 사용할 때 주의할 점은?
• 다중 컬럼 인덱스에서 중요한 것은 인덱스의 두 번째 컬럼은 첫 번째 컬럼에 의존해서 정렬되어 있다는 것이다. 즉, 두 번째 컬럼은 첫 번째 컬럼이 똑같은 레코드에서만 의미가 있다. 그래서 컬럼의 순서를 신중하게 결정해야 한다. 가령, = 조건과 같이 개수가 적은 데이터를 조회하는 컬럼을 다중 컬럼 인덱스 앞 쪽에 설정하고, 범위 검색과 같이 개수가 많은 데이터를 조회하는 컬럼을 다중 컬럼 인덱스 뒤쪽에 설정하는 것이 좋다.
• 단일 컬럼 인덱스보다 더 비효율적으로 Insert/Update/Delete를 수행하므로 가급적 업데이트가 안 되는 값을 선정해서 사용하는 것이 좋다.

잠금이란?
잠금은 트랜잭션 처리의 순차성을 보장하기 위한 방법이다.

블로킹이란?
블로킹은 잠금들의 경합(Race Condition)이 발생하여 특정 세션이 작업을 진행하지 못하고 멈춰 선 상태를 의미한다. 블로킹은 공유 잠금 - 배타 잠금 , 배타 잠금 - 배타 잠금 끼리 발생할 수 있다.

블로킹을 최소화할 수 있는 방법은?
• SQL문이 가장 빠르게 실행되도록 리팩터링하는 것이 가장 기본적이고 효과적인 방법이다.
• 트랜잭션을 가능한 짧게 정의하면 블로킹을 줄일 수 있다.
• 동일한 데이터를 변경하는 트랜잭션이 동시에 수행되지 않도록 해야 한다.
• 트랜잭션이 활발한 주간에는 대용량 갱신 작업을 수행하면 안 된다.
• 대용량 작업이 불가피한 경우, 작업 단위를 쪼개거나 lock_timeout 을 설정하여 해당 잠금의 치대 시간을 설정해야 한다.

교착 상태(데드락)란?
교착 상태는 두 트랜잭션이 각각 잠금을 설정하고 서로의 잠금에 접근하려고 할 때, 이미 각각의 트랜잭션에 의해 잠금이 설정되어 있기 때문에 양쪽 트랜잭션 모두 처리가 되지 않는 상태를 말한다.

교착 상태(데드락)을 해결할 수 있는 방법은?
• 트랜잭션 진행 방향을 같은 방향으로 설계한다.
• 트랜잭션 A의 테이블 접근 순서를 game_master → game_detail , 트랜잭션의 B의 테이블 접근 순서도 game_master → game_detail 로 설정해서 교착 상태 발생 가능성을 줄인다. 이 방식은 블로킹을 발생하지만 교착 상태만큼의 큰 문제는 아니다.
• 트랜잭션 처리 속도를 최소화한다.
• update문이 빠르게 처리되면, 교착 상태가 발생할 가능성이 줄어든다.
• set_lock_timeout 문을 사용하여 잠금 해제 시간을 조절한다.
• 잠금 시간을 설정하면 교착 상태가 발생했을 때 무기한 대기하지 않고 중간에 잠금이 풀리게 된다.

NoSQL은 무엇인가?
NoSQL은 관계형 데이터베이스의 한계를 보완하기 위해 고안된 데이터베이스 모델로, 느슨한 스키마를 제공하여 분산 컴퓨팅에서의 유연성, 확장성, 고성능성, 고기능성을 보장한다.

NoSQL 데이터베이스 모델을 분류하라.
NoSQL은 다양한 모델을 기반으로 데이터베이스를 설계할 수 있는데, 크게 4가지로 분류할 수 있다
.• Key-Value
• Document
• Column
• Graph

JDBC란,
자바 애플리케이션이 데이터베이스에 접근할 수 있도록 만든 JAVA에서 제공하는 API이다. 하나의 JDBC로 어떤 DBMS든 각 벤더마다 제공되는 JDBC 드라이버를 통해 연결 할 수 있다.

커넥션 풀이란
JDBC 실행 과정 중에서 생성되어야 할 Connection 객체를 미리 만들어서 pool 이란 곳에서 저장을 해두는 기법이다. 장점은 불필요한 과정(Connection객체를 생성,삭제)을 줄여서 성능을 높일 수 있다. WAS에서 커넥션 풀을 크게 설정하면 메모리 소모가 큰 대신 많은 사용자가 대기 시간이 줄어들고, 반대로 커넥션 풀을 적게 설정하면 그 만큼 대기 시간이 길어진다. 따라서 사용량에 따라 적정량의 커넥션(Connection)객체를 생성해두어야 한다.

클러스터링 인덱스란?
• 테이블의 PK에 대해 적용되는 인덱스이다.
• PK 값에 의해 해당 레코드의 물리적인 저장 위치가 결정된다.
• MySQL에서 클러스터링 인덱스는 InnoDB 스토리지 엔진에서만 지원한다.
• 항상 PK 값을 기준으로 정렬 상태를 유지되며, 이 특징으로 인해 물리적으로 행이 재배열된다.

넌클러스터링 인덱스란? (= 세컨더리 인덱스란?)
• 테이블의 PK 외에 대해 적용되는 인덱스이다.

InnoDB 스토리지 엔진에서 클러스터링 인덱스와 세컨더리 인덱스가 동작하는 과정을 설명하라.
클러스터링 인덱스
• 클러스터링 인덱스의 리프 노드에는 레코드의 모든 컬럼이 같이 저장되어 있다. 그래서 일반적인 레인지 인덱스 스캔 방식으로 탐색하다가 리프 노드에 도달하면, 해당 클러스터링 인덱스 키에 해당하는 레코드의 모든 정보를 가져온다.
세컨더리 인덱스
• 세컨더리 인덱스의 리프 노드에는 클러스터링 인덱스의 리프 노드와는 달리 PK가 존재한다. 그래서 일반적인 레인지 인덱스 스캔 방식으로 탐색하다가 리프 노드에 도달하면, 해당 세컨더리 인덱스 키에 해당하는 레코드의 PK를 이용하여 데이터 파일을 탐색한다. 이때 데이터 파일은 클러스터링 인덱스이므로 이 데이터 파일의 리프 노드에는 해당 PK에 해당하는 레코드의 모든 정보를 가져온다.

MyISAM이나 Memory 스토리지 엔진에서 클러스터링 인덱스를 지원하는가?
지원하지 않는다. 그래서 해당 엔진을 사용하는 인덱스의 리프 노드에는 인덱스 키와 찾으려는 레코드의 물리적 주소를 담고 있고, 이 물리적 주소를 사용하여 물리적 파일의 최종 레코드를 가져오게 된다.

클러스터링 인덱스의 장점과 단점을 설명하라.
장점
• PK로 검색할 때 검색할 때 처리 성능이 매우 빠르다.
• 테이블의 모든 세컨더리 인덱스가 PK를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많다.
단점
• 테이블의 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키 값의 크기가 클 경우 전체적으로 인덱스의 크기가 커진다.
• 세컨더리 인덱스를 통해 검색할 때 PK로 다시 한 번 검색해야 하므로 처리 성능이 느리다.
• INSERT할 때 PK에 의해 레코드의 저장 위치가 결정되므로 처리 성능이 느리다.
• PK를 변경할 때 레코드를 DELETE하고 INSERT하는 작업이 필요하므로 처리 성능이 느리다.
정리하자면, 클러스터링 인덱스의 장점은 빠른 읽기이고 단점은 느린 쓰기이다.

유니크 인덱스란?
• 테이블이나 인덱스에 같은 값이 2개 이상 저장될 수 없는 것을 뜻한다.

유니크 인덱스와 세컨더리 인덱스의 성능적 차이를 설명하라.
• 읽기 성능은 차이가 없지만. 쓰기 성능은 중복 체크를 위한 읽기 잠금 때문에 유니크 인덱스가 더 느리다.

Elasticsearch란?Á
Elasticsearch는 Apache Lucene(아파치 루씬) 기반의 Java 오픈 소스 분산 검색 엔진이다. Elasticsearch를 통해 루씬 라이브러리(Java에서 개발한 정보 검색용 라이브러리)를 단독으로 사용할 수 있으며, 방대한 양의 데이터를 신속하게(거의 실시간) 저장, 검색, 분석을 수행할 수 있다.

Elasticsearch는 언제 사용하는가?
Elasticsearch는 검색을 위해 단독으로 사용되기도 하며, ELK(Elasticsearch / Logstash / Kibana) 스택으로 사용되기도 한다.

ELK를 왜 사용하는가?
주로 ELK는 로드밸런싱되어 있는 WAS의 흩어져 있는 로그를 한 곳으로 모으고, 원하는 데이터를 빠르게 검색한 뒤 시각화하여 모니터링하기 위해 사용한다

Elasticsearch의 구조를 설명하라.
Elasticsearch는 클러스터로 구성되며, 클러스터 안에 노드, 노드 안에 인덱스, 인덱스 안에 샤드, 샤드 안에 세그먼트로 구성된다.각각의 특징은 본문을 참조할 것.

Elasticsearch는 왜 검색 속도가 빠른가?
역색인 자료 구조로 인해 빠르다.

Elasticsearch의 장점은?
• Scale out
• 샤드를 통해 규모가 수평적으로 늘어날 수 있음
• 고가용성
• Replica를 통해 데이터의 안전성을 보장
• Schema Free
• Json 문서를 통해 데이터 검색을 수행하므로 스키마 개념이 없음
• Restful
• 데이터 CRUD 작업은 HTTP Restful API를 통해 수행한다.
• SELECT = GET
• INSERT = PUT
• UPDATE = POST
• DELETE = DELETE
• Restful API를 사용한다는 것은 다양한 플랫폼에서 응용이 가능하다는 장점이 있다.
• 역색인

Elasticsearch의 단점은?
• 실시간 처리가 불가능하다.
• elasticsearch는 인메모리 버퍼를 사용하므로 쓰기와 동시에 읽기 작업을 할 경우, 세그먼트가 생성되기 전까지는 해당 데이터를 검색할 수 없다.
• 트랜잭션을 지원하지 않는다.
• 분산 시스템 구성의 특징 때문에 시스템적으로 비용 소모가 큰 트랜잭션 및 롤백을 지원하지 않는다.
• 진정한 의미의 업데이트를 지원하지 않는다.
• 세그먼트에서 데이터가 삭제될 경우 Soft-Delete를 한다. (삭제 flag = true)
• 세그먼트에서 데이터가 수정될 경우 Soft-Delete를 하고, 수정된 데이터를 새로운 세그먼트로 생성한다.
• RDBMS의 Index와 유사한 동작.

Elasticsearch와 RDBMS의 차이는?
Elasticsearch는 Json 문서를 통해 검색을 수행하므로 스키마가 없지만, RDBMS는 엄격한 스키마가 존재한다.Elasticsearch는 역색인 자료 구조로 검색을 수행하지만, RDBMS는 인덱스 자료 구조로 검색을 수행한다.Elasticsearch는 저장소보다는 검색 엔진에 가깝다.

Elasticsearch와 NoSQL의 차이는?
Elasticsearch는 실시간 처리가 불가능하지만, NoSQL은 실시간 처리가 가능하다. Elasticsearch는 역색인 자료 구조가 있지만, NoSQL은 없다. Elasticsearch는 저장소보다는 검색 엔진에 가깝다.

역색인이란?
• 키워드를 통해 문서를 찾아내는 방식이다.
• 책에서 맨 뒤에 나와 있는 찾아 보기를 떠올리면 된다.

색인을 사용한 검색은 왜 느린가?
• 전통적인 RDBMS에서는 like 검색을 사용하기 때문에 데이터가 늘어날수록 검색해야 할 대상이 늘어나 시간도 오래 걸리고, row 안의 내용을 모두 읽어야 하기 때문에 기본적으로 속도가 느리다. 특히 row 안의 내용이 길다면 하나의 row를 읽더라도 시간이 오래 걸린다.

역색인을 사용한 검색은 왜 빠른가?
• 역색인을 사용하면 데이터가 늘어나도 찾아가야 할 행이 늘어나는 것이 아니라 역색인이 가리키는 id의 배열 값이 추가되는 것이므로 큰 속도의 저하 없이 여전히 빠른 속도로 검색이 가능하다

Redis란?
Redis는 고성능 키-값 저장소로서 String, list, hash, set, sorted set 등의 자료 구조를 지원하는 NoSQL이다.

Redis는 언제 사용하는가
DB, Cache, Message Queue, Shared Memory 용도로 사용될 수 있다. 주로 Cache 서버를 구현할 때 많이 쓴다.

Redis의 특징은?
• 영속성을 지원하는 인 메모리 데이터 저장소
• 다양한 자료 구조를 지원함.
• 싱글 스레드 방식으로 인해 연산을 원자적으로 수행이 가능함.
• 읽기 성능 증대를 위한 서버 측 리플리케이션을 지원
• 쓰기 성능 증대를 위한 클라이언트 측 샤딩 지원
• 다양한 서비스에서 사용되며 검증된 기술

Redis는 왜 Thread Safe한가?
싱글 스레드 방식이어서 연산을 하나씩 처리한다. Redis는 왜 속도가 빠른가?Á
Key-Value 방식이므로 쿼리를 날리지 않고 결과를 얻을 수 있다.

Redis는 영속성을 어떻게 보장하는가?
RDB(Snapshotting) 방식
• 순간적으로 메모리에 있는 내용 전체를 디스크에 옮겨 담는 방식
AOF(Append On File) 방식
• Redis의 모든 write/update 연산 자체를 모두 log 파일에 기록하는 형태

Redis와 Memcached의 차이는 무엇인가?


모놀리식 아키텍처란?
모놀리식 아키텍처는 마이크로서비스(MSA) 아키텍처에 반대되는 개념으로, 애플리케이션의 모든 구성 요소가 한 프로젝트에 통합되어 있는 형태를 말한다.

모놀리식 아키텍처의 장단점을 설명하라.
장점
• 개발 초기에 단순한 아키텍처 구조로 인해 개발에 용이하다.
• 어떤 서비스든지 개발되어 있는 환경이 같아서 복잡하지 않다.
• 배포가 간단하다.
• 확장성이 쉽다.
• 로드밸런스를 이용하여 로드 부하를 나눠 가지는 방식으로 진행한다.
• 쉽게 고가용성 서버 환경을 만들 수 있다.
• End-to-End 테스트가 용이하다.
단점
• 프로젝트의 규모가 커짐에 따라 애플리케이션 구동 시간이 늘어나고 빌드 및 배포 시간이 길어진다.
• 조그마한 수정 사항이 있어도 전체를 다시 빌드하고 배포해야 한다.
• 많은 양의 코드가 몰려 있어서 개발자가 모든 코드를 이해하기 힘들며, 유지 보수가 어렵다.
• 일부분의 오류가 전체에 영향을 미친다. (장애가 전파된다.)
• 기술 스택이 한 번 정해지면 바꾸기 어렵다.
• 전체 애플리케이션 확장은 쉽지만, 부하 분산을 위해 각 컴포넌트를 독립적으로 확장하기 어렵다.

MSA 아키텍처란?
MSA 아키텍처는 하나의 큰 애플리케이션을 여러 개의 작은 애플리케이션으로 쪼개어 변경과 조합이 가능하도록 만든 형태를 말한다. 작은 레고 블록(microservice) 하나 하나를 붙여 어떠한 큰 결과물을 만드는 레고 놀이를 생각하면 이해하기 쉽다.

마이크로 서비스가 무엇인가?
마이크로 서비스는 스스로 돌아갈 수 있으며 독립적으로 배포가 가능한 서비스를 의미한다. 

마이크로 서비스의 특징을 설명하라.
• 각각의 서비스는 그 크기가 작을 뿐, 서비스 자체는 하나의 모놀리식 아키텍처와 유사한 구조를 갖는다.
• 각각의 서비스는 독립적으로 배포가 가능해야 한다.
• 각각의 서비스는 다른 서비스에 대한 의존성이 작아야 한다.
• 각 서비스는 개별 프로세스로 구동되며, REST API와 같은 가벼운 방식으로 통신되어야 함.

MSA 아키텍처의 장단점을 설명하라.
장점
• 배포 관점
• 서비스 별 개별 배포가 가능하다. (배포 시 전체 서비스의 중단이 없음.)
• 독립 배포가 가능하므로 개발자의 자율성이 증가한다. (내가 A 기능 다 만들었고, 다른 사람이 B 기능 못 만들었으면, 나는 그냥 놀아도 됨.)
• 요구 사항을 신속하게 반영하여 빠르게 배포할 수 있다.
확장 관점
• 특정 서비스에 대한 확장성이 용이하다.
• 클라우드 사용에 적합하다.
장애 관점
• 장애가 전체 서비스로 확장될 가능성이 적다.
• 부분적 장애에 대한 격리가 수월하다.
• 코드 / 유지 보수 관점
• 팀 별로 프로젝트가 분리되어 있으므로 코드의 이해도가 증가하고, 그에 따라 유지 보수하기 쉽다.
• 신기술의 적용이 유연하고, 서비스를 polyglot하게 개발 및 운영할 수 있다.
• polyglot 개발: 여러 프로그래밍 언어, 패러다임 등을 사용
단점
성능 관점
• 서비스 간 호출 시 API를 사용하기 때문에 통신 비용 및 지연 시간이 증가한다.
데이터 관리 관점
• 데이터가 여러 서비스에 걸쳐서 분산되므로 한 번에 조회하기 어렵고, 데이터의 정합성 또한 관리하기 어렵다.
테스트 / 트랜잭션 관점
• 단위 테스트는 쉽지만, 통합 테스트 및 End-to-End 테스트 단위로 들어가면 여러 서비스의 API를 검증해야 하므로 시간과 비용이 많이 든다.
• 각 서비스 별로 데이터베이스가 있으므로 트랜잭션을 구현하기 까다롭다.
• 아키텍처가 다소 복잡하므로 개발 및 관리가 어렵고, 비용이 많이 든다.

언제 모놀리식 아키텍처를 사용하고, 언제 MSA 아키텍처를 사용해야 하는가?
초기 시작은 프로젝트의 규모가 작은 경우가 많으므로 모놀리식 아키텍처로 사용하다가 다음 관점들을 비교하여 이득이 된다면 MSA 아키텍처로 전환하는 것이 좋다. •  비용: MSA 아키텍처를 도입할 경우, 모놀리식 아키텍처에 비해 비용을 얼마나 절감할 수 있는가?
• 개발 생산성: 마이크로 서비스를 요구할 만큼 시스템 복잡도가 높은가? 또는 복잡도를 지나치게 높인 마이크로 서비스가 생산성을 저해하고 있진 않은가?
• 운영: 개발 팀에게 개발과 운영을 동시에 할 만큼 인프라가 준비되어 있는가? 또는 개발 인력이 마이크로 서비스를 관리할 역량이 있는가?
• 배포: 배포를 충분히 자주 하고 있는가? MSA는 빠른 변화에 대응하기 위해 도입하는 것인데, 회사마다 배포 일이 정해져 있고, 배포가 가끔 일어난다면 효율이 떨어진다.

JAVA

동일성과 동등성의 차이는 무엇인가?
두 객체가 할당된 메모리 주소가 같으면 동일하고, 두 객체의 내용이 같으면 동등하다고 말한다. 동일성은 == 연산자를 통해 판별할 수 있고, 동등성은 equals 연산자를 통해 판별할 수 있다. 

== 연산자와 equals 연산자의 차이는 무엇인가?
== 연산자는 객체의 동일성을 판별하기 위해 사용하며, equals 연산자는 두 객체의 동등성을 판별하기 위해 사용한다.equals 연산자는 재정의하지 않으면 내부적으로 == 연산자와 같은 로직을 수행하므로 차이가 없다. 따라서 equals 연산자는 각 객체의 특성에 맞게 재정의를 해야 동등성의 기능을 수행한다.

오버로딩이 무엇인가?
오버로딩은 같은 이름의 메소드를 중복하여 정의하는 것을 의미한다. 즉, 서로 다른 시그니처를 갖는 여러 메소드를 같은 이름으로 정의하는 것이라고 할 수 있다.

메소드 시그니처란?
메소드 시그니처는 메소드의 이름과 매개변수 리스트의 조합을 말한다. 자바 컴파일러는 메소드 시그니처를 통해 메소드 간의 차이를 식별한다.

오버로딩의 장점
유사한 기능을 하는 동일한 이름의 메소드가 묶여있기 때문에 메소드명을 절약할 수 있고 기능 예측이 쉬워져서 소스코드의 가독성이 향상된다는 장점이 있다. 또한 매개변수 값에 따라 다양한 처리를 할 수 있으므로 다형성을 구현할 수 있다.

오버라이딩이 무엇인가?
상속 관계에 있는 클래스 간에 같은 이름의 메소드를 정의하는 기술을 오버라이딩이라고 한다. 

오버라이딩의 조건은?
부모 클래스의 메소드와 동일한 시그니처를 갖어야 하는 조건, 접근 제어자는 부모 클래스보다 좁은 범위로 변경할 수 없다는 조건, 부모 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다는 조건이 있다.

오버라이딩을 왜 사용하는가?
다형성을 구현하기 위해 사용한다.

스레드 풀이란?
스레드 풀은 작업 처리에 사용되는 스레드를 제한된 개수만큼 정해 놓고, 작업 큐에 들어오는 작업들을 하나씩 스레드가 맡아 처리하는 기법이다.

스레드 풀을 왜 사용하는가?
• 병렬 작업 처리가 많아지면 스레드 개수가 중가되고, 그에 따른 스레드 생성과 스케줄링으로 인해 CPU가 바빠져 메모리 사용량이 늘어난다. 이는 애플리케이션의 성능 저하로 이어진다.
• 스레드 풀은 작업 처리에 사용되는 스레드를 제한된 개수만큼 정해 놓고, 작업 큐에 들어오는 작업들을 하나씩 스레드가 맡아 처리한다.
• 작업 처리가 끝난 스레드는 다시 작업 큐에서 새로운 작업을 가져와 처리한다.
• 따라서 작업 처리 요청이 폭증해도 작업 큐라는 곳에 작업이 대기하다가 여유가 있는 스레드가 그것을 처리하므로 스레드의 전체 개수는 일정하며 애플리케이션의 성능도 저하되지 않는다.

블로킹 방식과 콜백 방식의 차이를 설명하라.
블로킹 방식은 작업 처리를 요청한 후 작업이 완료될 때까지 블로킹되지만, 콜백 방식은 작업 처리를 요청한 후 결과를 기다릴 필요 없이 다른 기능을 수행할 수 있다.

동시성 프로그래밍에서 발생할 수 있는 문제는?
동시성 프로그램에서는 CPU와 RAM의 중간에 위치하는 CPU Cache Memory와 병렬성이라는 특징때문에 가시성 문제, 원자성 문제가 발생할 수 있다.

가시성 문제와 원자성 문제에 대해 설명하라.
가시성 문제
• 여러 개의 스레드가 사용됨에 따라, CPU Cache Memory와 RAM의 데이터가 서로 일치하지 않아 생기는 문제를 의미한다. 가시성을 보장되어야 하는 변수에 volatile 키워드를 붙여줘서 RAM에서 바로 읽도록 해야 한다. 그러나 여러 스레드가 공유 자원에 쓰기 연산을 할 경우 가시성을 보장했다고 해서 동시성이 보장되지 않는다.
원자성 문제
• 여러 스레드가 공유 자원에 동시에 쓰기 연산을 할 경우 잘못된 결과를 반환하는 것을 의미한다. 따라서 synchronized, atomic 을 통해 원자성을 보장해야 한다.

volatile 키워드에 대해 설명하라
동시성 프로그래밍에서 발생할 수 있는 문제 중 하나인 가시성 문제를 해결하기 위해 사용되는 키워드이다. 가시성 문제는 여러 개의 스레드가 사용됨에 따라, CPU Cache Memory와 RAM의 데이터가 서로 일치하지 않아 생기는 문제를 의미한다. volatile 키워드를 붙인 공유 자원은 RAM에 직접 읽고 쓰는 작업을 수행할 수 있도록 해준다.

자바에서 동기화 문제를 신경 써야 하는 이유는?
자바 멀티 스레드 환경에서는 스레드끼리 static 영역과 heap 영역을 공유하기 때문에, 공유 자원에 대한 동기화 문제를 신경 써야한다.

synchronized 키워드에 대해 설명하라
synchronized 는 lock 을 이용해 동기화를 시키는데 총 4가지 사용법이 있다
.• synchronized method
• 동기화를 시키고 싶은 클래스의 메소드에 synchronized 키워드를 붙이면 되고, synchronized method 는 인스턴스 단위의 synchronized 키워드가 붙은 메소드에 대해서만 lock 공유한다.
• static synchronized method 는 인스턴스가 아닌 클래스 단위로 lock 을 공유하며, synchronized method 와 동일하게 함수 간의 동기화가 발생한다. 만약 synchronized method 과 함께 사용하게 되면 인스턴스 락과 클래스 락은 공유가 안 되기 때문에 동기화 이슈가 발생할 수 있다는 점을 주의해야 한다.
• synchronized block 은 block 단위로 lock 을 걸며, 2가지 사용 방법이 있다.
• 첫번 째는 synchronized 의 인자 값에 this 를 사용하는 방식이다. 이 방식은 여러 스레드가 들어와 서로 다른 block 을 호출해도 this 를 사용해 자기 자신에 lock 을 걸었기 때문에 기다려야 한다.
• 두번 쨰는 synchronized 의 인자 값에 Object 를 사용하는 방식이다. 이 방식은 block 마다 서로 다른 lock 을 걸리게해 훨씬 효율적인 코드를 작성할 수 있다.
• static synchroinzed method방식과 차이는 lock객체를 지정하고 block으로 범위를 한정지을 수 있다는 점이다. 클래스 단위로 lock을 공유한다는 점은 같다.

Singleton 객체에 synchronized 키워드를 사용하면 생기는 문제점은?
Singleton 에 synchronized 메소드가 많을수록 멀티 스레드는 병목현상을 겪게 된다. 쉽게 말하자면 멀티 스레드를 사용하지만 Singleton 을 사용할 때는 싱글 스레드처럼 동작하는 문제가 발생한다.

위 문제의 해결 방법은?
LazyHolder 방식을 사용하면 된다. 이 방법은 JVM 의 클래스 초기화 과정에 보장되는 thread-safe 특성을 이용해 Singleton 의 초기화 책임을 JVM 에게 넘겨 개발자가 직접 동기화 코드를 작성할 때 생기는 문제를 회피할 수 있다. 또한 내부 static class 를 참조하기 전까지 클래스 로딩이 발생하지 않기 때문에 메모리를 효율적으로 사용할 수 있다.

Vector는 Thread-Safe한가?
Vector는 모든 메소드에 동기화 처리가 되어 있다.예를 들어, if문 안에서 size() > 0이 만족해서 lock을 푸는 순간 다른 스레드가 Vector에 접근해서 remove() 메소드 같은 것을 호출해 버릴 수도 있다.

뮤텍스에 대해 설명하라
여러 스레드를 실행하는 환경에서 자원에 대한 접근에 제한을 강제하기 위한 동기화 기법이며 다음과 같은 특징이 있다. . Boolean 타입의 Lock 변수를 사용한다. 따라서 1개의 공유자원에 대한 접근을 제한한다.
. 공유자원을 사용 중인 스레드가 있을 때, 다른 스레드가 공유자원에 접근한다면 Blocking 후 대기 큐로 보낸다.
. Lock을 건 스레드만 Lock을 해제할 수 있다.

세마포어에 대해 설명하라
멀티 프로그래밍 환경에서 다수의 프로세스나 스레드가 n개의 공유 자원에 대한 접근을 제한하는 방법으로 사용되는 동기화 기볍이며 다음과 같은 특징이 있다. . 세마포어 변수를 통해 wait, signal을 관리한다. 세마포어 변수는 0 이상의 정수형 변수를 갖는다.
. n 개의 공유자원에 대한 접근을 제한할 수 있으며 이를 계수 세마포어라고 한다.
. 접근 가능한 공유 자원의 수가 1개일 때는 이진 세마포어로 뮤텍스처럼 사용할 수 있다.
. 큐에 연결된 스레드를 깨우는 방식에 따라 강성 세마포어(큐에 연결된 스레드를 깨울 때 FIFO 정책), 약성 세마포어(큐에 연결된 스레드를 깨울 때 순서를 특별히 명시하지 않음)로 구분된다.
. 세마포어는 Signaling 메커니즘으로 Lock을 걸지 않은 스레드도 Signal을 보내 Lock을 해제할 수 있다.

세마포어의 단점
세마포어는 wait & signal 연산 순서를 바꿔서 실행하거나 둘 중 하나라도 생략하면 교착 상태가 발생하고, wait & signal 연산이 프로그램 전체에 구성되어 있으면 세마포어의 영향이 미치는 곳이 어딘지 파악하기 어렵기 때문에 세마포어를 사용해 프로그램을 구현하는 것은 매우 어렵다. 이런 단점을 극복하기 위해 모니터가 등장했다.

모니터에 대해 설명
모니터는 임계 구역을 지켜내기 위한 방법인 상호 배제를 프로그램으로 구현한 것이며, 공유 자원, 공유 자원 접근함수와 두 개의 큐로 구성되어 있다. 공유 자원을 점유 중인 프로세스(스레드)는 Lock을 가지고 상호베타 큐에 대기하며, 공유 자원의 Lock이 해제되기를 기다리는 프로세스(스레드)는 조건동기 큐에서 대기한다.자바에서 동기화를 위해 모니터 방식을 채택하고 있다. synchronized를 임계 영역을 정해 공유 자원의 스레드 간의 동기화를 할 수 있고 모니터의 공유 자원 접근 함수(wait(), notify(), notifyAll() )를 통해 Lock을 관리할 수 있다.

가변 객체와 불변 객체를 설명하라
가변 객체가변 객체는 Java에서 Class의 인스턴스가 생성된 이후에 내부 상태가 변경 가능한 객체이다. 가변 객체는 멀티 스레드 환경에서 사용하려면 별도의 동기화 처리가 필요하며, 대표적인 가변 객체로 ArrayList, HashMap, StringBuilder, StringBuffer 등이 존재한다. 이외에도 프로그래머가 커스텀 객체를 생성하여 내부 상태를 변경할 수 있게 만든다면, 그것도 가변 객체가 된다. 불변 객체불변 객체는 가변 객체와 반대로 Java에서 Class의 인스턴스가 생성된 이후에 내부 상태를 변경할 수 없는 객체이다. 불변 객체는 멀티 스레드 환경에서도 안전하게 사용할 수 있다는 신뢰성을 보장하며, 대표적인 불변 객체로 String 등이 존재한다. 이외에도 프로그래머가 커스텀 객체를 생성하여 내부 상태가 변경되지 않게 만들면, 그것도 불변 객체가 된다.

불변 객체의 장점을 설명하라
• Thread-safe하여 병렬 프로그래밍에 유용하며, 동기화를 고려하지 않아도 된다.
• 실패 원자적인(Failure Atomic) 메소드를 만들 수 있다.
• Cache, Map, Set 등의 요소로 활용하기에 적합하다.
• 부수 효과(Side Effect)를 피해 오류 가능성을 최소화할 수 있다.
• 다른 사람이 작성한 함수를 예측 가능하며 안전하게 사용할 수 있다.

불변 객체를 만드는 방법을 설명하라
• 모든 필드에 대해 final을 설정한다.
• 필드에 참조 타입이 있을 경우, 해당 객체도 불변성을 보장해야 한다.
• 필드에 컬렉션이 존재할 경우, 생성자 및 getter에 대해 방어적 복사를 수행해야 한다.

방어적 복사와 Unmodifiable의 차이점은?
방어적 복사는 A 리스트와 B 리스트 사이의 참조를 끊는 행위이지만, Unmodifiable은 참조를 끊지 않고 단순히 특정 리스트에서 요소의 변경이 일어날 경우 예외를 던진다. 그래서 생성자 단계에서 방어적 복사를 취하지 않고, getter에서 Unmodifiable만 취할 경우 초기 생성자로 주입한 컬렉션의 변화가 생기면 불변성이 깨진다.

방어적 복사를 사용하면 항상 불변성을 보장하는가?
그렇지 않다. 방어적 복사는 컬렉션의 요소에 대해 얕은 복사를 수행하므로 컬렉션의 참조 타입이 가변 객체라면, 복사하려는 컬렉션의 요소가 변경될 경우 불변성이 깨진다.

String Pool에 대해 설명하라.
String Pool은 Java Heap 영역에 존재하는 String 저장소로, String literal을 보관한다.

String Pool이 있으면 무엇이 좋은가?
= 연산자로 String을 생성할 때, 같은 값이 String Pool에 있다면, 새로운 메모리 할당 없이 주소를 공유하여 사용할 수 있다. 또한, String은 불변 객체이므로 동일한 주소를 여러 객체가 참조하여도 동기화 문제가 발생하지 않으므로 안전하다.

String과 StringBuilder의 차이는?
String은 불변 객체이므로 + 연산으로 문자열을 이어 붙이려고 해도 매번 새로운 객체를 할당해야 한다. 하지만, StringBuilder는 가변 객체이고 내부 char[] 배열의 사이즈를 조절하여 문자열을 이어 붙이기 때문에 새로운 객체를 최소로 할당할 수 있다.

StringBuilder와 StringBuffer의 차이는?
StringBuilder는 동기화 처리가 되어 있지 않아 스레드 불안전하지만, StringBuffer는 대부분의 메소드에 대해 synchronized 처리가 되어 있으므로 일반적으로 스레드 안전하다.

StringBuffer가 일반적으로 스레드 안전하다는 것은 무슨 뜻인가?
StringBuffer는 단일 synchronized 메소드를 여러 스레드가 사용하는 것은 스레드 안전하지만, 단일 synchronized 메소드 여러 개로 구성된 일반 메소드에서 사용할 때는 스레드 안전하지 않다. 

Vector, HashTable, Collections.SynchronziedXXX의 문제점은?
Vector, HashTable, SynchronziedXxx 클래스는 synchronized 메소드 또는 블록을 사용하며, 하나의 잠금 객체를 공유한다. 따라서, 컬렉션에 하나의 스레드가 잠금을 획득하는 경우 다른 스레드들은 모든 메소드를 사용하지 못하고 Blocking 상태가 된다. 이는 애플리케이션 성능 저하의 원인이 될 수 있다.

SynchronizedList와 CopyOnArrayList의 차이점은?
SynchronizedList는 읽기와 쓰기 동작시 인스턴스 자체에 잠금이 걸린다. 그러나 CopyOnArrayList는 쓰기 동작시 해당 블록에 잠금을 걸고 원본 배열에 있는 요소를 복사하여 새로운 임시 배열을 만들고, 이 임시 배열에 쓰기 동작을 수행한 후 원본 배열을 갱신한다. 이 덕분에 읽기 동작은 잠금이 걸리지 않아 SynchronizedList보다 읽기 성능이 좋다. 그러나 쓰기 동작은 비용이 높은 배열 복사 작업을 하기 때문에 SynchronizedList보다 쓰기 성능이 떨어진다.따라서, 변경 작업보다 읽는 작업이 많을 경우 CopyOnArrayList를 사용하는 것이 더 효과적이다.

SynchronizedMap과 ConcurrentHashMap의 차이점은?
SynchronziedMap은 읽기와 쓰기 동작 시 인스턴스 자체에 잠금이 걸린다. 그러나 ConcurrentHashMap은 각 테이블 버킷을 독립적으로 잠그는 방식을 사용한다. 만약, 빈 버킷에 노드를 삽입할 경우 잠금(Lock) 대신 CAS 알고리즘을 사용하고, 그 외의 변경은 접근한 버킷에만 잠금이 걸려 스레드 경합을 최소화하며 동시성을 보장해준다.

직렬화란?
메모리를 디스크에 저장하거나, 네트워크 통신에 사용하기 위한 형식으로 변환하는 것이다. 특별히, 자바 직렬화는 자바 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 바이트 형태로 데이터 변환하는 기술을 뜻한다.

직렬화가 왜 필요한가?
디스크에 저장하거나 통신할 때는 값 형식 데이터만 사용할 수 있다. 참조 형식 데이터는 실제 데이터 값이 아닌 힙에 할당되어 있는 메모리 번지 주소를 가지고 있기 때문이다.이때 직렬화를 하게 되면 각 주소 값이 가지는 데이터를 전부 끌어 모아서 값 형식 데이터로 변환해 준다. 직렬화가 된 데이터는 언어에 따라서 텍스트 또는 바이너리 등의 형태가 되는데, 이러한 형태가 되었을 때 저장하거나 통신할 때 파싱이 가능한 유의미한 데이터가 된다.

역직렬화란?
디스크에 저장한 데이터를 읽거나, 네트워크 통신으로 받은 데이터를 메모리에 쓸 수 있도록 변환하는 것이다. 특별히, 자바 역직렬화는 바이트로 변환된 데이터를 다시 객체로 변환하는 기술을 뜻한다.

자바 직렬화는 언제 쓰는가?
• 짧은 만료 시간을 지니는 데이터를 가지고 있는 객체를 직렬화 할 때
• 거의 변경되지 않는 데이터를 지닌 객체를 직렬화 할 때

자바 직렬화를 사용하는 기술은 무엇이 있는가?
• 서블릿 세션, 캐시, 자바 RMI

자바 직렬화의 장점은?
• 자바 직렬화는 자바 시스템에서 개발에 최적화되어 있다.
• 복잡한 데이터 구조의 클래스의 객체라도 직렬화 기본 조건만 지키면 큰 작업 없이 바로 직렬화, 역직렬화가 가능하다.
• 데이터 타입이 자동으로 맞춰지기 때문에 역직렬화가 되면 기존 객체처럼 바로 사용이 가능하다.

자바 직렬화의 단점은?
• 직렬화한 객체의 구조와 역직렬화 할 현재 객체의 구조가 다르면 에러가 발생한다.
• 타입 체크가 매우 엄격하다.
• 타 직렬화에 비해 직렬화 된 데이터의 용량이 크다.

에러(Error)란?
예외(Exception)란 입력 값에 대한 처리가 불가능하거나, 프로그램 실행 중에 참조된 값이 잘못된 경우 등 정상적인 프로그램의 흐름을 어긋나는 것을 말한다. 자바에서 예외는 개발자가 직접 처리할 수 있기 때문에 예외 상황을 미리 예측하여 핸들링할 수 있다.

예외(Exception)란?
에러(Error)는 시스템에 무엇인가 비정상적인 상황이 발생한 경우에 사용된다. 주로 자바 가상 머신에서 발생시키는 것이며 예외와 반대로 이를 애플리케이션 코드에서 잡을 수 없다.

Checked Exception에 대해 설명하라
Checked Exception은 RuntimeException을 상속하지 않은 클래스이며, 명시적인 예외 처리를 해야 한다. 컴파일 시점에 확인할 수 있고 트랜잭션 안에서 동작할 때 Checked Exception이 발생하면 롤백되지 않는다는 특징이 있다.

Unchecked Exception에 대해 설명하라
Unchecked Exception은 RuntimeException을 상속한 클래스이며, 명시적인 예외 처리를 하지 않는다. 런타임 시점에 확인할 수 있고 트랜잭션 안에서 동작할 때 Unchecked Exception이 발생하면 롤백된다는 특징이 있다.

예외(Checked Exception)를 처리하는 방식에 대해 설명하라
예외 상황을 파악하고 문제를 해결해서 정상 상태로 복구하는 예외 복구 방식, 예외 처리를 직접 담당하지 않고 호출한 쪽으로 넘기는 예외 처리 회피, 적절한 예외로 전환해서 넘기는 예외 전환 방식이 있다.

올바른 예외 처리 방식
예외 복구 전략이 명확하고 복구가 가능하다면 Checked Excetpion을 try-catch로 잡아서 예외를 복구하는 것이 좋다. 복구가 불가능한 Checked Exception이 발생하면 더 구체적인 Unchecked Exception을 발생시키고 예외에 대한 메시지를 명확하게 전달하는 것이 좋다. 무책임하게 상위 메서드에 throw로 예외를 던지는 것은 상위 메서드의 책임이 증가하기 때문에 좋지 않은 방법이다.

GC란?
GC는 메모리 관리 기법 중 하나로, 동적으로 할당했던 메모리 영역 중 필요 없게 된 영역을 해제하는 기능이다. 여기서 동적으로 할당했던 메모리 영역은 프로그램 런타임에 사용되는 Heap 영역 메모리를 뜻하고, 필요 없게 된 영역은 어떤 변수도 가리키지 않게 된 영역을 뜻한다.

GC의 장단점은?
장점
• 메모리를 수동으로 관리하던 것에서 비롯된 에러를 예방할 수 있다.
• 개발자의 실수로 인한 메모리 누수,
• 해제된 메모리를 또 해제하는 이중 해제
• 해제된 메모리에 접근
단점
• GC의 메모리 해제 타이밍을 개발자가 정확히 알기 어렵다.
• 어떠한 메모리 영역이 해제의 대상이 될 지 검사하고, 실제로 해제하는 일이 모두 오버헤드다.

GC에서 사용하는 알고리즘을 설명하라.
• Reference Counting
• 힙 영역의 객체들이 각각 reference count를 가지고 있고, 이 count가 0이 되면 해당 객체를 해제한다. reference count는 몇 가지 방법으로 해당 객체에 접근할 수 있는 지 뜻한다.
• Mark And Sweep
• 알고리즘은 Root Space부터 해당 객체에 접근 가능한지, 아닌지를 메모리 해제의 기준으로 삼는다. Root Space부터 그래프 순회를 통해 연결된 객체를 찾아내고(Mark) 연결이 끊어진 객체는 지운다.
• Java에서 사용하는 GC 알고리즘이다.

GC는 언제 실행되는가?
JVM의 Heap은 Young Generation, Old Generation으로 나뉘고, Young Generation은 다시 Eden, Servival 0, Servival 1 영역으로 나뉜다. Eden 영역이 꽉 차면 minor gc가 실행되어 Mark And Sweep 알고리즘을 통해 참조가 되고 있는 객체만 Servival 0 또는 Servival 1 영역으로 옮긴다.만약 여러 번 minor gc를 실행하고도 참조된 객체가 있다면 이 객체를 Servival 영역에서 Old Generation 영역으로 옮긴다. 시간이 지나서 Old Generation 영역이 꽉 차면 major gc를 실행하여 Mark And Sweep 알고리즘을 통해 필요 없는 메모리를 비운다.

왜 Heap 영역은 Young Generation과 Old Generation으로 나누는가?
통계적으로 대부분의 객체가 수명이 짧으므로 특정 부분만 탐색함으로써 GC의 성능을 높이기 위해 나누었다.

GC의 실행 방식을 설명하라.
Serial GC
• Serial GC는 하나의 스레드로 GC를 실행하는 방식인데, 하나의 스레드로 GC를 실행하다 보니 Stop The World 시간이 길다.
• GC 실행 이후 메모리 파편화를 막는 Compaction 과정을 수행한다.
Parallel GC
• Serial GC를 멀티 스레딩으로 수행한다.
CMS GC
•  대부분의 가비지 수집 작업을 애플리케이션 스레드와 동시에 수행하여, Stop The World 시간을 최소화하고 있다. 하지만 메모리와 CPU를 많이 사용하고, Mark And Sweep 과정 이후 메모리 파편화를 해결하는 Compaction이 기본적으로 제공되지 않는다는 단점이 있다.

자바의 실행 방식
. 자바 프로그램이 실행되면 JVM은 OS로부터 프로그램이 필요로 하는 메모리를 할당 받는다.
. 자바 파일이 자바 컴파일러에 의해 자바 바이트 코드로 변환된다.
. 클래스 로더를 통해 자바 바이트 코드를 JVM으로 필요한 시점에 로딩한다.
. 해석된 바이트 코드는 런타임 데이터 영역에 배치되어 수행이 이루어지게 된다.
. 실행 과정 속에서 JVM은 필요에 따라 GC같은 관리 작업을 수행한다.

JVM의 정의
자바 프로그램은 자바 컴파일러에 의해 자바 바이트 코드로 번역되는데, JVM은 OS를 대신해서 컴파일된 자바 바이트 코드를 실행하는 가상의 운영체제 역할을 한다. 따라서, 자바 프로그램은 플랫폼에(=운영체제, CPU)에 종속되지 않는다. 다만, JVM은 플랫폼에 의존하기 때문에 OS에 맞는 JVM을 설치해야 한다.

JVM의 특징
• 스택 기반의 가상 머신
• 심볼릭 레퍼런스
• 가비지 컬렉션(garbage collection)
• 기본 자료형을 명확하게 정의하여 플랫폼 독립성 보장

JVM의 구조
• 자바 프로그램을 실행하는 역할
o 컴파일러를 통해 바이트 코드로 변환된 파일을 JVM에 로딩하여 실행
• Class Loader : JVM 내(Runtime Data Area)로 Class 파일을 로드하고 링크
• Execution Engine : 메모리(Runtime Data Area)에 적재된 클래스들을 기계어로 변경해 실행
• Garbage Collector : 힙 메모리에서 참조되지 않는 개체들 제거
• Runtime Data Area : 자바 프로그램을 실행할 때, 데이터를 저장

JVM 메모리(Runtime Data Area) 구조
메서드(static) 영역
o  클래스가 사용되면 해당 클래스의 파일(.class)을 읽어들여, 클래스에 대한 정보(바이트 코드)를 메서드 영역에 저장
o  클래스와 인터페이스, 메서드, 필드, static 변수, final 변수 등이 저장되는 영역입니다.
JVM 스택 영역
o  스레드마다 존재하여 스레드가 시작할 때마다 할당
o  지역변수, 매개변수, 연산 중 발생하는 임시 데이터 저장
o  메서드 호출 시마다 개별적 스택 생성
JVM 힙 영역
o  런타임 시 동적으로 할당하여 사용하는 영역
o  new 연산자로 생성된 객체와 배열 저장
o  참조가 없는 객체는 GC(가비지 컬렉터)의 대상
pc register
o  쓰레드가 현재 실행할 스택 프레임의 주소를 저장
Native Method Stack
o  C/C++ 등의 Low level 코드를 실행하는 스택

G1 GC란?
G1은 Garbage First의 약어로 Garbage만 있는 Region을 먼저 회수한다고 해서 붙여진 이름이다. 빈 공간 확보를 더 빨리 한다는 것은 조기 승격이나 급격히 할당률이 늘어나는 것을 방지하여 Old Generation을 비교적 한가하게 만들 수 있다.

G1 GC의 장단점은?
장점
• 별도의 STW 없이도 여유 메모리 공간을 압축하는 기능을 제공한다. 또한, 전체 Old Generation 혹은 Young Generation 통째로 Compaction을 할 필요 없고, 해당 Generation의 일부분 Region에 대해서만 Compaction을 하면 된다.
• Heap 크기가 클수록 잘 동작한다.
• CMS의 비해 개선된 알고리즘을 사용하고, 처리 속도가 더 빠르다.
• Garbage로 가득찬 영역을 빠르게 회수하여 빈 공간을 확보하므로 GC 빈도가 줄어든다.
단점
• 공간 부족 상태를 조심해야 한다. (Minor GC, Major GC 수행하고 나서도 여유 공간이 부족한 경우)
• 이때는 Full GC가 발생하는데, 이 GC는 Single Thread로 동작한다.
• Full GC는 heap 전반적으로 GC가 발생하는 것을 뜻한다.
• 작은 Heap 공간을 가지는 Application에서는 제 성능을 발휘하지 못하고 Full GC가 발생한다.
• Humonogous 영역은 제대로 최적화되지 않으므로 해당 영역이 많으면 성능이 떨어진다.

G1 GC의 Heap 구조를 설명하라.
G1 GC는 기존 힙 구조와 완전히 다른 양상을 띈다. 전통적인 힙 구조는 Young, Old 영역을 명확하게 구분하였지만, G1 GC는 개념적으로 그들이 존재하나 일정 크기의 논리적 단위인 region으로 구분하고 있다.
• Humonogous: Region 크기의 50%를 초과하는 큰 객체를 저장하기 위한 공간
• Available/Unused: 아직 사용되지 않은 Region

G1 GC의 동작 과정을 설명하라.
기본적으로 G1 GC는 Young-Only 단계와 Space Reclamation 단계를 반복하면서 수행하는 Cycle 구조로 진행된다.Young Only 단계는 Minor GC만 수행하다가 한정된 Old Generation 비율이 넘으면 Major GC가 수행된다. 그리고 Young Only 단계가 끝날 때까지 두 GC가 혼용된다.Space Reclamation 단계는 Old 영역의 Garbage까지 수집하는 Minor GC 방식의 Mixed GC 방식이 수행된다.

G1 GC에서 Minor GC는 어떻게 동작하는가?
연속되지 않은 Young Generation에 있는 live object를 Survivor 영역이나 Old Generation으로 이동시킨다. 이 단계에서 STW가 발생하며, 모든 과정은 멀티 스레드로 동작한다.

G1 GC에서 Major GC는 어떻게 동작하는가?
Major GC는 initial mark, root region scan, concurrent mark, remark, copy/cleanup 단계로 구분되어 있으며, 중간 중간 마킹을 수행하면서 Garbage만 존재하는 영역 및 live object가 적은 순으로 영역을 정리하여 가용 공간을 만들어내는 것이 특징이다.

G1 GC에서 Mixed GC는 어떻게 동작하는가?
Mixed GC는 Minor GC와 비슷한 방식으로 동작하지만, 추가로 Old 영역의 Garbage도 정리하는 방식으로 동작한다.

Heap을 왜 모니터링 해야 하는가?
Spring 개발한 웹 애플리케이션을 운영하다 보면, 어떠한 이유로 사용하지 않는 메모리가 쌓이면서 메모리 누수 현상이 발생할 수 있다. 이것은 모니터링을 하지 않는 이상 정확한 이유를 알기 매우 어려우며, 메모리 누수를 방치하면 어느 순간 OOM(Out Of Memory) 에러가 발생할 수 있다. 따라서 주기적으로 Heap 영역을 모니터링하고, 의심되는 상황이 있다면 Heap Dump를 떠서 어떤 객체가 원인이 분석해야 한다.

Heap Dump는 언제 사용하는가?
Heap Dump는 메모리 누수 현상 혹은 OOM 에러가 발생했을 때, 어떠한 객체가 원인인지 분석하기 위해 사용된다.

Heap Dump를 분석하여 OOM을 해결한 사례가 있는가?
개인의 경험을 이야기할 것. 필자는 엑셀 라이브러리인 XSSF 라이브러리를 사용하다가 OOM 에러가 발생하였음.

클래스 로더란?
자바는 런타임에 클래스 로드하고 링크하는 특징이 있다. 클래스 로더는 런타임 중에 JVM의 Method 영역에 동적으로 Java 클래스를 로드하는 역할을 한다.

클래스 로더의 동작 방식은?
. JVM의 Method Area에 클래스가 로드되어 있는지 확인한다. 만일 로드되어 있는 경우 해당 클래스를 사용한다.
. Method Area에 클래스가 로드되어 있지 않을 경우, 시스템 클래스 로더에 클래스 로드를 요청한다.
. 시스템 클래스 로더는 확장 클래스 로더에 요청을 위임한다.
. 확장 클래스 로더는 부트스트랩 클래스 로더에 요청을 위임합니다.
. 부트스트랩 클래스로더는 부트스트랩 Classpath(JDK/JRE/LIB)에 해당 클래스가 있는지 확인한다. 클래스가 존재하지 않는 경우 확장 클래스로더에게 요청을 넘긴다.
. 확장 클래스 로더는 확장 Classpath(JDK/JRE/LIB/EXT)에 해당 클래스가 있는지 확인한다. 클래스가 존재하지 않는 경우 시스템 클래스 로더에게 요청을 넘긴다.
. 시스템 애플리케이션 클래스로더는 시스템 Classpath에 해당 클래스가 있는지 확인한다. 클래스가 존재하지 않는 경우 ClassNotFoundException을 발생시킨다.

클래스 로더의 세 가지 원칙이란?
• 위임 원칙
• 가시범위 원칙
• 유일성의 원칙

클래스 로더가 어떻게 클래스를 동적으로 로딩하는지?
하나의 클래스를 로딩하는 과정에서 동적으로 다른 클래스를 로딩하는 로드타임 동적 로딩 방식과 코드를 실행하는 순간에 클래스를 로딩하는 런타임 동적 로딩 방식이 있다.

클래스의 로딩 시점
• 클래스의 인스턴스 생성
• 클래스의 정적 변수 사용 (final 키워드 X)
• 클래스의 정적 메소드 호출

클래스의 초기화 시점
• 클래스의 인스턴스 생성
• 클래스의 정적 메소드 호출
• 클래스의 정적 변수 사용 (final 키워드 X)

싱글톤 패턴과 클래스 로더는 어떤 연관이 있는지?
holder에 의한 초기화 방식을 사용하면 클래스 로딩 및 초기화 과정이 스레드 세이프함을 이용해 싱글톤 인스턴스를 생성할 수 있다.자세한 내용은 본문을 참고하자. 코드와 함께 자세히 설명할 수 있어야 한다.

스레드 모니터링과 스레드 덤프가 왜 필요한가?
웹 서버에서는 많은 수의 동시 사용자를 처리하기 위해 수많은 스레드를 사용한다. 두 개 이상의 스레드가 같은 자원을 이용할 때는 필연적으로 스레드 간에 경합(Contention)이 발생한다. 스레드 경합 때문에 데드락과 같은 다양한 문제가 발생할 수 있으며, 이런 문제들을 분석하기 위해서는 스레드 모니터링과 스레드 덤프가 필수이다.

Java 언어의 장단점을 설명하라.
장점
• 객체지향 언어이다.
• 유지 보수가 쉽고 확장성이 높다.
• 이식성이 높다.
• JVM에서 작동하기 때문에 운영 체제의 종류에 상관없이 작동한다.
• 메모리를 자동으로 관리한다.
• 프로그램이 C/C++에 비해 안정적이다.
• 멀티 스레드 구현이 쉽다.
• 스레드 생성 및 제어와 관련된 라이브러리 API를 제공한다.
• 동적 로딩을 지원한다.
• 실행 시에 모든 클래스가 로딩되는 것이 아니라 필요한 시점에 클래스를 로딩한다.
• 애플리케이션의 변경 사항도 비교적 적은 작업으로 처리가 가능하다.
• 분산 환경을 지원한다.
• 기본적으로 TCP/IP 라이브러리가 포함되어 있고, HTTP 프로토콜을 지원한다.
• 오픈 소스 라이브러리가 풍부하다.
단점
• JVM에 의해 기계어로 번역되고 실행되는 과정을 거쳐서, 컴파일되자마자 기계어로 변환되는 C,C++에 비하면 속도가 현저히 떨어진다
• 다만 최근에는 JIT 컴파일 방식으로 자바 컴파일러를 개선하여 속도가 많이 빨라지긴 했다.
• 다른 언어에 비해 작성해야 하는 코드의 길이가 긴 편이다.
• 프로그램 발생 시 발생할 수 있는 예외를 개발자가 직접 처리해야 한다.

왜 Java 언어를 사용하는가?
Java는 객체지향 프로그래밍을 가장 대중적이고 편하게 구현할 수 있는 언어라고 생각하며, 많은 엔터프라이즈급 회사에서 오랜 기간 사용된 만큼 안정성이 보장된 언어라고 판단했다. 또한 자바 진영은 하위 호환성을 중요하게 여기는 점과 레퍼런스와 커뮤니티가 활성화 되어있는 점이 매력적으로 다가왔다. 이러한 이유로 필자는 Java를 주 언어로 사용하여 개발하고 있다.

Java 8에서 새로 추가된 기능을 설명하라.
• Heap Permanent Generation 제거
• 인터페이스에 디폴트 메소드와 정적 메소드 추가
• 함수형 인터페이스, 람다 표현식, 메소드 참조 기능 추가
• 스트림 API 도입
• 새로운 날짜 관련 라이브러리 추가
• Optional 지원
• 병렬 처리 지원

Java 11에서 새로 추가된 기능을 설명하라.
• Spring에 새로운 메소드 추가
• Files 클래스에 새로운 메소드 추가
• 컬렉션 인터페이스에 새로운 메소드 추가
• Predicate 인터페이스에 새로운 메소드 추가
• 람다에서 로컬 변수 Var 사용
• 자바 파일 실행 방식 단순화

Java 8과 Java 11 중 무엇을 선택할 것인가?
현재 기업을 보면 Java 8 혹은 Java 11을 주로 채택하여 사용하고 있는 것 같다. 개인적으로는 Java 8의 기능을 수용하면서 더 나은 라이브러리가 추가 되었고, 성능이 개선된 G1 GC를 사용하는 Java 11을 사용하는 편이다. 또한 Java 11은 LTS 버전이므로 장기적인 지원이 보장된 버전이므로 앞으로도 유익한 기능이 나올 것으로 기대한다.

static이란?
Static(정적)은 고정된이라는 의미를 가지고 있으며, 프로그램이 시작되는 시점에 클래스 로더가 클래스를 해석하여 메소드 영역 혹은 힙 영역에 클래스 메타 데이터 및 정적 변수 등을 적재한다. 

static은 어디에 저장되는가?
java 8 이전에는 메소드 영역인 Permanent 영역, Java 8 이후에는 힙 영역에 저장된다.

static 사용을 왜 지양해야 하는가?
• 메모리 문제
• 동시성 이슈 문제
• 런타임 다형성 불가
• 객체의 상태를 이용할 수 없다.
• 테스트하기 어려움

static은 언제 사용하는가?
• 상수 정의
• 유틸리티 클래스 정의

equals()와 hashCode()는 왜 같이 사용하는가?
해시를 사용한 자료 구조는 Key를 결정할 때 hashCode() 를 사용하기 때문이다. 즉, 객체가 동일한지 비교하기 전에, 두 객체의 해시 코드가 같은지 비교하고 그 후 두 객체가 동등한지 판단한다. 이때, hashCode() 가 재정의되어 있지 않다면 Object의 hashCode()를 사용하므로 각 객체가 저장된 메모리 주소가 반환된다. 따라서 해시 자료 구조를 사용하는 경우를 위해 equals() 외에 hashCode() 도 재정의해 주는 것이 좋다.

원시 타입의 크기를 설명하라.


원시 타입과 참조 타입의 차이를 설명하라.
성능 관점
• 원시 타입은 스택 영역에 존재한다. 반면 참조 타입은 스택 영역에는 참조 값만 있고, 실제 값은 힙 영역에 존재한다. 참조 타입은 최소 2번 메모리 접근을 해야 하고, 일부 타입의 경우 값을 필요로 할 때 언박싱 과정(ex. Double → double, Integer → int)을 거쳐야 하므로 원시 타입과 비교해서 접근 속도가 느린 편이다.
메모리 관점
• 원시 타입보다 참조 타입이 사용하는 메모리 양이 압도적으로 높다. 이외의 참조 타입은 최근 들어 64 비트의 JVM을 많이 사용하므로 일반적으로 64 bits를 차지한다고 한다.
NULL 관점
• 원시 타입은 null을 담을 수 없지만, 참조 타입은 null을 담을 수 있다. 이것은 원시 타입의 경우, 값이 없으면 디폴트 값을 반환하기 때문이다. (ex. int은 0, boolean은 false)
제네릭 관점
• 원시 타입은 제네릭 타입에서 사용할 수 없지만, 참조 타입은 가능하다.

리플렉션이란?
리플렉션은 힙 영역에 로드된 Class 타입의 객체를 통해, 원하는 클래스의 인스턴스를 생성할 수 있도록 지원하고, 인스턴스의 필드와 메소드를 접근 제어자와 상관 없이 사용할 수 있도록 지원하는 API이다.

리플렉션의 장단점을 설명하라.
장점
• 런타임 시점에서 클래스의 인스턴스를 생성하고, 접근 제어자와 관계 없이 필드와 메소드에 접근하여 필요한 작업을 수행할 수 있는 유연성을 가지고 있다.
단점
• 캡슐화를 저해한다.
• 런타임 시점에서 인스턴스를 생성하므로 컴파일 시점에서 해당 타입을 체크할 수 없다.
• 런타임 시점에서 인스턴스를 생성하므로 구체적인 동작 흐름을 파악하기 어렵다.
• 단순히 필드 및 메소드를 접근할 때보다 리플렉션을 사용하여 접근할 때 성능이 느리다. (모든 상황에서 성능이 느리지는 않음.)

리플렉션은 언제 사용하는가?
규모가 작은 콘솔 단계에서는 개발자가 충분히 컴파일 시점에 프로그램에서 사용될 객체와 의존 관계를 모두 파악할 수 있다. 하지만 프레임워크와 같이 큰 규모의 개발 단계에서는 수많은 객체와 의존 관계를 파악하기 어렵다. 이때 리플렉션을 사용하면 동적으로 클래스를 만들어서 의존 관계를 맺어줄 수 있다.가령, Spring의 Bean Factory를 보면, @Controller, @Service, @Repository 등의 어노테이션만 붙이면 Bean Factory에서 알아서 해당 어노테이션이 붙은 클래스를 생성하고 관리해 주는 것을 알 수 있다. 개발자는 Bean Factory에 해당 클래스를 알려준 적이 없는데, 이것이 가능한 이유는 바로 리플렉션 덕분이다. 런타임에 해당 어노테이션이 붙은 클래스를 탐색하고 발견한다면, 리플렉션을 통해 해당 클래스의 인스턴스를 생성하고 필요한 필드를 주입하여 Bean Factory에 저장하는 식으로 사용이 된다.

Call by value와 Call by reference의 차이
Call by value는 메소드를 호출할 때 넘겨주고 싶은 변수(인자)를 지정하면, 메소드의 매개변수가 지정한 변수 값의 복사본으로 초기화되는 것이다.Call by reference는 메소드를 호출할 때 넘겨주고 싶은 변수(인자)를 지정하면, 메소드의 매개변수가 지정한 변수의 레퍼런스로 초기화되는 것이다.

Java는 Call by value일까, Call by reference일까?
Java에서 인자를 넘기는 과정에 직접적인 참조를 넘긴 게 아닌, 주소 값을 복사해서 넘기기 때문에 이는 Call by value이다.

템플릿 메소드 패턴이란?
알고리즘의 구조를 메소드에 정의하고, 하위 클래스에서 알고리즘 구조의 변경 없이 알고리즘을 재정의 하는 패턴이다.

스프링에서 템플릿 메소드 패턴은 어디서 사용되는가?
Spring에서 템플릿 메소드 패턴은 FrameworkServlet의 상속을 받은 DispatcherServlet의 doService() 에서 사용되고 있다.FrameworkServlet은 processRequest() 라는 템플릿 메소드가 정의되어 있는데, 이 메소드 안에 doService() 가 추상 메소드로 구현되어 있다. 즉, processRequest() 를 호출하면 일반적인 로직을 수행하다가 doService() 를 만나면 DispatcherServlet의 doService() 를 호출하는 것이다.

추상 클래스와 인터페이스 차이
추상 메서드
o  abstract 키워드와 함께 원형만 선언되고 코드는 작성하지 않은 메서드
추상 클래스
o  개념 : abstract 키워드로 선언된 클래스
  추상 메서드가 최소 한 개 이상을 가진 abstract 클래스
  추상 메서드 이외의 다른 것들도 추가 가능
o  목적
  관련성이 높은 클래스 간의 코드를 공유하고 확장하고 싶은 목적
인터페이스
o  개념 : default와 static 을 제외하고는 추상 메서드와 상수만을 포함하여, interface 키워드를 사용하여 선언
  모든 메서드는 추상 메서드로, abstract public이 생략되어 있다.
  상수 필드는 public static final이 생략되어 있다.
  다중상속이 가능하다.
o  목적
  관련성이 없는 클래스들의 논리적으로 같은 기능을 자신에 맞게 구현을 강제하는데 목적
정리하자면, 구조상 차이로 추상 클래스는 abstract 키워드가 붙고 추상 메서드뿐만 아니라 다른 변수, 메서드도 선언이 가능하고, 인터페이스는 추상 메서드와 상수만 선언 가능하다.(자바 8부터는 default 메서드 선언 가능)
목적의 차이로 추상 클래스는 관련성이 높은 클래스 간의 코드 공유(재사용)와 확장을 목적으로 하고, 인터페이스는 관련성이 없는 클래스들의 같은 기능을 자신에 맞게 구현하는데 목적이 있다.

Java Collections
Map
• HashMap
o 내부 hash값에 따라 키순서가 정해지므로 특정 규칙없이 출력된다.
o key와 value에 null값을 허용 한다.
o 비동기 처리
• LinkedHashMap
o 입력 순서대로 출력된다.
o 비동기 처리
• TreeMap
o 내부적으로 레드-블랙 트리(균형 이진 탐색 트리) 로 저장된다.
o Null값 비허용
o 키값이 기본적으로 오름차순 정렬 되어 출력된다.
o Compartor 구현으로 정렬 방법을 지정할 수 있다.
• ConCurrentHashMap
o key,value에 null값 비허용
o 쓰기작업에서만 동기 처리
• HashTable
o key,value에 null값 비허용
o 모든 작업에 동기 처리

List
• ArrayList
o 내부적으로 배열을 사용하는 자료구조로 메모리가 연속적으로 배치된다.
o 배열과 달리 메모리 할당이 동적이다.
O 데이터 삽입, 삭제 시 해당 데이터 이후 모든 데이터가 복사되므로 빈번한 삭제, 삽입이 일어나는 경우에는 부적합하다.
o 검색의 경우는 인덱스의 데이터를 가져오면 되므로 빠르다.
o 재할당 시 크기의 절반씩 증가한다.
• LinkedList
o 양방향 포인터 구조로 각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식으로 데이터를 저장하는 자료 구조
o 데이터의 삽입, 삭제 시 해당 노드의 주소지만 바꾸면 되므로 삽입, 삭제가 빈번한 데이터에 적합하다.
o 메모리가 불연속적이다.
o 데이터 검색 시 처음부터 순회하므로 검색에는 부적합하다.
o 스택, 큐, 양방향 큐를 만들기 위한 용도로 사용한다.
o 양옆의 정보만을 갖고 있기 때문에 순차적으로 검색을 진행하여 검색 속도가 느리다.
• Vector
o 내부에서 자동으로 동기처리가 일어난다.
o 성능이 좋지 않아 잘 사용하지 않는다.
o 재할당 시 크기의 두 배로 증가한다.
• Stack
o new 키워드로 직접 사용 가능
o Vector를 상속받아 동기 처리
cf) 배열과 리스트는 다른 것
• 배열(Array)은 크기가 고정적이라 선언 시 지정한 크기를 변경할 수 없다.(Immutable)

Set
• HashSet
o 저장 순서를 유지하지 않는 데이터의 집합
o Null 저장 가능
o 해시 알고리즘을 사용하여 검색속도가 매우 빠르다.
o 내부적으로 HashMap 인스턴스를 이용하여 요소를 저장한다.
• LinkedHashSet
o 저장 순서를 유지하는 HashSet
•  reeSet
o 데이터가 정렬된 상태로 저장되는 이진 탐색 트리의 형태로 요소를 저장한다.
o Null 저장 불가능
o 레드 블랙 트리(균형 이진 탐색 트리) 로 구현되어 있다.
o Compartor 구현으로 정렬 방법을 지정할 수 있다.

Sync vs Async
Sync(동기)
o 동기는 함수 A가 B를 호출한 뒤, B의 결과값이 나오면 해당 결과값을 가지고 바로 처리하는 방식이다.
Async(비동기)
o 비동기는 함수 A가 B를 호출한 뒤, B의 결과값에 큰 비중을 두지 않고 결과가 나오면 처리를 할 수도 있고 안 할 수도 있다.

Stream
o java 8 에서 추가된 API
o 컬렉션 타입의 데이터를 Stream 메서드로 내부 반복을 통해 정렬, 필터링 등이 가능
o parallel 메서드 제공을 통해 병렬처리가 가능
o 데이터를 변경하지 않는다(Immutable)
o 작업을 내부 반복으로 처리하므로 불필요한 코딩을 줄일 수 있다.
o 최종 연산 후 stream이 닫히므로 일회용 이다.

템플릿 콜백 패턴이란?
템플릿 콜백 패턴은 전략 패턴의 변형된 형태이다. 전략 패턴은 변화되는 부분을 매번 클래스로 만들고 외부에서 구체 클래스를 주입해 주어야 한다. 반면 템플릿 콜백 패턴은 변화되는 부분을 독립된 클래스를 만드는 것이 아니라 익명 내부 클래스를 생성하여 이를 활용하므로 주입이 필요하지 않다.

템플릿 콜백 패턴의 장단점
장점
• 전략 패턴은 객체와 전략 객체 간의 의존성을 설정해 주는 팩토리 객체가 필요한데, 템플릿 콜백 패턴은 팩토리 객체 없이 해당 객체를 사용하는 메소드에서 인터페이스의 전략을 선택한다. 그래서 수동 DI, 메소드 수준의 DI라고 부른다. 이를 통해 모든 전략마다 팩토리 객체를 일일이 만들 필요가 없다.
• 외부에서 어떤 전략을 사용하는지 감추고 중요한 부분에 집중할 수 있다.
단점
• 인터페이스를 사용하긴 하지만, 실제 사용할 클래스를 직접 선언할 경우 결합도가 증가할 수 있다.

Spring에서 템플릿 콜백 패턴은 어디서 쓰이는가?
JdbcTemplate의 update() 메소드에서 내부의 익명 객체를 정의하여 사용하고 있다.

스프링 빈이란?
스프링 빈은 스프링 컨테이너에 의해 관리되는 자바 객체(POJO)를 의미한다.

스프링 컨테이너란?
스프링 컨테이너는 스프링 빈의 생명 주기를 관리하며, 생성된 스프링 빈들에게 추가적인 기능을 제공하는 역할을 한다. IoC와 DI의 원리가 스프링 컨테이너에 적용된다.

스프링 빈 등록 방식을 설명하라.
클래스 위에 @Component를 붙인 후 ComponentScan을 이용하여 빈을 자동 등록하거나, @Configuration이 붙은 설정 파일 내의 특정 타입을 리턴하는 메소드 위에 @Bean을 붙여서 빈을 등록하는 방법이 있다.

Bean 생명주기
스프링 컨테이너 생성 -> 스프링 빈 생성 -> 의존 관계 주입 -> 초기화 콜백 -> 사용 -> 소멸전 콜백 -> 스프링 종료
• 스프링 컨테이너에 의해 생명주기 관리
• 스프링 컨테이너 초기화 시 빈 객체 생성, 의존 객체 주입 및 초기화
• 생성과 의존관계 주입과 초기화 분리
o 의존관계 주입(생성자 주입)은 필수정보를 받고 메모리 할당을 통해 객채 생성 책임
o 초기화는 생성된 값들을 활용해 외부 커넥션을 연결하는 등 무거운 작업 수행
o 명확하게 분리하는 것이 유지보수 관점에서 좋다.
• 싱글톤 빈들은 컨테이너가 종료되기 직전에 소멸전 콜백이 발생
초기화와 소멸 메서드는 애노테이션으로 @PostConstruct, @PreDestroy 를 사용하는 것이 권장된다.

@Component vs @Bean
@Bean
• 개발자가 컨트롤이 불가능한 외부 라이브러리들을 Bean으로 등록하고 싶은 경우
에 사용된다.
• 메소드 또는 어노테이션 단위에 붙일 수 있다.
• 컨테이너 안에 들어있는 객체
• 컨테이너에 담겨있으며, 필요할 때 컨테이너에서 가져와서 사용
• @Bean을 사용해 등록하거나 xml을 사용해 등록하고, Bean으로 등록된 객체는 쉽게 주입하여 사용 가능

@Component
• 개발자가 직접 컨트롤이 가능한 클래스들의 경우에 사용된다.
• 클래스 또는 인터페이스 단위에 붙일 수 있다.

@Configuration은 어떻게 싱글톤 빈을 보장하는가?
클래스의 바이트 코드를 조작하는 CGLIB 라이브러리를 사용하여 싱글톤을 보장한다. CGLIB는 프록시 객체의 일종으로 설정 파일이 빈으로 등록될 때, 해당 설정 파일을 상속 받은 프록시 객체가 빈으로 등록된다. 그리고 설장 파일에서 @Bean이 붙은 메소드마다 이미 스프링 빈이 존재하면 존재하는 빈을 반환하고, 스프링 빈이 없으면 비로소 등록하고 반환하는 식으로 싱글톤을 보장한다.

Bean Lite Mode가 무엇인가?
Bean Lite Mode는 CGLIB를 이용하여 바이트 코드 조작을 하지 않는 방식을 의미한다. 이때 스프링 빈에 대해 싱글톤을 보장하지 않는다.

스프링 빈 스코프에 대해 설명하라.
싱글톤
o spring 프레임워크의 기본이 되는 스코프
o 스프링 컨테이너 시작과 종료까지 1개의 객체로 유지
프로토타입
o 빈의 생성, 의존관계 주입, 초기화까지만 관여하고 이후에는 컨테이너에서 관리하지 않는 스코프
o 따라서 매번 요청마다 새로 만들어짐
o 싱글톤은 스프링이 뜰때 생성되는데 반해, 프로토타입은 요청할때 생성됨
웹 스코프
o request : 각 요청이 들어오고 나갈때까지 유지
o session : 세션이 생성되고 종료될때까지 유지
o application : 웹의 서블릿 컨텍스트와 동일한 생명주기를 갖는 스코프
 서블릿 컨텍스트는 web application내에 있는 모든 서블릿들을 관리하며 정보공유할 수 있게 도와 주는 역할 을 하는데, 톰캣 컨테이너가 실행 시 애플리케이션 하나당 한개의 서블릿컨텍스트가 생성된다.
 생명 주기는 보통 톰캣의 시작과 종료와 일치한다.

Spring Annotation
@ComponentScan
o @Component, @Service, @Repository, @Controller, @Configuration이 붙은 클래스 Bean들을 찾아서 Context에 bean을 등록해주는 애노테이션
o 전부 다 @Component를 사용하지 않고 @Repository 등으로 분리해서 사용하는 이유는, 예를 들어 @Repository는 DAO에서 발생할 수 있는 unchecked exception들을 스프링의 DataAccessException으로 처리할 수 있기 때문이다.
o 또한 가독성에서도 해당 애노테이션을 갖는 클래스가 무엇을 하는지 단 번에 알 수 있다.
@EnableAutoConfiguration
o autoConfiguration도 Configuration중 하나에 해당한다.
o spring.factories 내부에 여러 Configuration들이 있고 조건에 따라 Bean이 등록되게 되는데 메인 클래스 @SpringBootApplication을 실행하면 @EnableAutoConfiguration에 의해 spring.factories 안에 있는 수많은 자동 설정들이 조건에 따라 적용되어 수 많은 Bean들이 생성된다.
o 간단하게 정리하면, Application Context를 만들 때 자동으로 빈설정이 되도록 하는 기능이다.
@Component
o 개발자가 직접 작성한 class를 Bean으로 등록하기 위한 애노테이션
@Bean
o 개발자가 직접 제어가 불가능한 외부 라이브러리등을 bean으로 만들려할 때 사용되는 애노테이션
@Configuration
o @Configuration을 클래스에 적용하고 @Bean을 해당 class의 메서드에 적용하면 @autowired로 Bean을 부를 수 있다.
@Autowired
o 스프링이 Type에 따라 알아서 Bean을 주입해준다.
o Type을 먼저 확인한 후 못 찾으면 Name에 따라 주입한다.
o 강제로 주입하고자 하는 경우 @Qulifier을 같이 명시
@Qualifier
o 같은 타입의 빈이 두 개 이상 존재하는 경우 스프링이 어떤 빈을 주입해야할 지 알 수 없어서 스프링 컨테이너를 초기화하는 과정에서 예외가 발생한다.
o @Qualifier는 @Autowired와 함께 사용하여 정확히 어떤 bean을 사용할지 지정하여 특정 의존 객체를 주입할 수 있다.
@Resource
o @Autowired와 마찬가지로 Bean 객체를 주입해주는데 차이점은 Autowired는 타입으로, Resource는 이름으로 연결해준다.
o 애노테이션 사용으로 인해 특정 Framework에 종속적인 애플리케이션을 구성하지 않기 위해서 @Resource 사용을 권장한다.
@Controller
o API와 view를 동시에 사용하는 경우에 사용
o 보통 view 화면 return을 목적으로 사용한다.
@RestController
o view가 필요 없이 API만 지원하는 서비스에서 사용
@SpringBootApplication
O @Configuration, @EnableAutoConfiguration, @ComponentScan 3가지를 하나로 합친 애노테이션

Singleton 빈이란?
• 싱글톤 빈은 스프링 컨테이너에서 한 번만 생성되며, 컨테이너가 사라질 때 제거된다.
• 생성된 하나의 인스턴스는 Spring Beans Cache에 저장되고, 해당 빈에 대한 요청과 참조가 있으며 캐시된 객체를 반환한다. 하나만 생성되기 때문에 동일 참조를 보장한다.
• 기본적으로 모든 빈은 스코프가 명시적으로 지정되지 않으면 싱글톤이다.

Prototype 빈이란?
• 프로토 타입 빈은 DI가 발생할 때마다 새로운 객체가 생성되어 주입된다.
• 빈 소멸에 스프링 컨테이너가 관여하지 않고, gc에 의해 빈이 제거된다.

언제 Singleton 빈을 사용하고, 언제 Prototype 빈을 사용하는가?
• 싱글톤 타입으로 적합한 객체
• 상태가 없는 공유 객체
• 읽기 전용으로만 상태를 가진 객체
• 쓰기가 가능한 상태를 지니면서도 사용 빈도가 매우 높은 객체
• 단, 이때는 동기화 전략이 필요함.
• 프로토 타입으로 적합한 객체
• 사용할 때마다 상태가 달라져야 하는 객체
• 쓰기가 가능한 상태가 있는 객체

Singleton 빈과 Prototype 빈과 같이 사용할 때 어떤 문제가 생길 수 있는가?
싱글톤 객체가 프로토 타입 객체를 가지고 있는 경우에는 의도한 것과 다른 결과를 낼 수도 있다. 이미 싱글톤 빈으로 생성되는 시점에 프로토 타입 빈이 생성되어 들어오기 때문에 싱글톤 빈 내부의 프로토 타입 빈을 호출하게 되면 매번 같은 값을 가져 온다.

Singleton 빈 내부의 Prototype 빈을 사용할 때마다 다른 인스턴스를 받아오려면 어떻게 해야 하는가?
Java.inject의 Provider를 사용하거나, 빈 스코프 설정에서 프록스 모드를 TAGET_CLASS로 설정하면 된다.

웹 스코프가 무엇인가?
웹 스코프는 웹 환경에서만 동작하는 스코프이며 프로토 타입과 다르게 특정 주기가 끝날 때까지 관리를 해 준다. 따라서 @PreDestory와 같은 소멸 콜백이 호출된다는 특징이 있다.

웹 스코프의 종류는?
Request
• HTTP 요청 하나가 들어오고 나갈 때까지 유지되는 스코프
• 각각의 HTTP 요청마다 별도의 빈 인스턴스가 생성되고 관리된다.
Session
• HTTP Session과 동일한 생명 주기를 가지는 스코프
Application
• 서블릿 컨텍스트와 동일한 생명 주기를 가지는 스코프
WebSocket
• 웹 소켓과 동일한 생명 주기를 가지는 스코프

Singleton 빈의 생명 주기를 설명하라.
. 스프링 컨테이너 생성
. 스프링 빈 생성
. 의존 관계 주입
. 초기화 콜백
. 사용
. 소멸 전 콜백
. 스프링 종료

Prototype 빈의 생명 주기를 설명하라.
. 스프링 컨테이너 생성
. 스프링 빈 생성
. 의존 관계 주입
. 초기화 콜백
. 사용
. GC에 의해 수거

싱글톤 빈은 Thread-Safe한가?
결론부터 말하자면 Thread-Safe하지 않다. 스프링은 싱글톤 레지스트리를 통해 private 생성자, static 변수 등의 코드 없이 비즈니스 로직에 집중하고 테스트 코드에 용이한 싱글톤 객체를 제공해 주는 것 뿐이지, 동기화 문제는 개발자가 처리해야 한다. 만약에 싱글톤 빈이 상태를 갖게 되고, 아무런 동기화 처리를 하지 않는다면 멀티 스레드 환경에서 부작용이 발생할 수 있으니 주의해야 한다.

Servlet이란?
서블릿은 클라이언트 요청을 처리하고, 그 결과를 다시 클라이언트에게 전송하는 Servlet 클래스의 구현 규칙을 지킨 자바프로그램이다. 서블릿을 사용하게 되면 웹 페이지를 동적으로 생성하여 클라이언트에게 반환해 줄 수 있다.

Servlet의 동작 방식을 설명하라.
• 사용자가 URL을 입력하면 요청이 서블릿 컨테이너로 전송된다.
• 요청을 전송 받은 서블릿 컨테이너는 Http Request, HttpResponse 객체를 생성한다.
• 사용자가 요청한 URL이 어느 서블릿에 대한 요청인지 찾는다. 위 예제에서는 helloServlet을 찾게 된다.
• 서블릿의 service() 메소드를 호출한 후 클라이언트의 GET, POST 여부에 따라 doGet(), doPost() 메소드를 호출한다.
• 동적 페이지를 생성한 후 HttpServletResponse 객체에 응답을 보낸다.
• 클라이언트에 최종 결과를 응답한 후 HttpServletRequest, HttpServletResponse 객체를 소멸한다.

Servlet의 생명 주기를 설명하라.
• 클라이언트 요청이 들어오면 서블릿 컨테이너는 서블릿이 메모리에 있는지 확인한다. 메모리에 없다면 init() 메소드를 호출하여 적재한다.
• 클라이언트 요청에 따라서 service() 메소드를 통해 요청에 대한 응답이 doGet(), doPost()로 분기한다.
• 서블릿 컨테이너가 서블릿에 종료 요청을 하면 destory() 메소드가 호출된다. 종료 시 처리해야 하는 작업은 destory() 메소드를 오버라이딩하여 구현하면된다. destory() 메소드가 끝난 서블릿 인스턴스는 GC에 의해 제거된다.

Servlet과 일반 자바 객체는 무슨 차이가 있는가?
JVM에서 호출 방식은 서블릿과 일반 클래스 모두 같으나, 서블릿은 main() 메소드로 직접 호출되지 않고, 웹 컨테이너(Servlet Container)에 의해 실행된다.

Servlet Container란?
서블릿 컨테이너는 구현되어 있는 Servlet 클래스의 규칙에 맞게 서블릿 객체를 생성, 초기화, 호출, 종료하는 생명 주기를 관리한다.

Servlet Container의 특징을 설명하라.
• 개발자가 비즈니스 로직에 집중할 수 있도록 HTTP 요청 메시지 파싱, Content-Type 확인, HTTP 응답 메시지 생성 등 작업을 대신 처리 해준다.
• 서블릿의 생명 주기를 관리한다.
• 요청이 올 때마다 자바 스레드 하나를 생성하여 멀티 스레딩 처리를 한다.

Servlet Container의 동작 과정을 설명하라.
. 웹 브라우저에서 웹 서버에 HTTP 요청을 보내면, 웹 서버는 받은 HTTP 요청을 WAS의 Web Server로 전달한다.
. WAS의 웹 서버는 HTTP 요청을 서블릿 컨테이너에 전달한다.
. 서블릿 컨테이너는 HTTP 요청 처리에 필요한 서블릿 인스턴스가 힙 메모리 영역에 있는지 확인한다. 존재하지 않는다면, 서블릿 인스턴스를 생성하고 해당 서블릿 인스턴스의 init() 메소드를 호출하여 서블릿 인스턴스를 초기화한다.
. 서블릿 컨테이너는 서블릿 인스턴스의 service() 메소드를 호출하여 HTTP 요청을 처리하고, WAS의 웹 서버에게 처리 결과를 전달한다.
. WAS의 웹 서버는 HTTP 응답을 앞 단에 위치한 웹 서버에게 전달하고, 앞 단의 웹 서버는 받은 HTTP 응답을 웹 브라우저에게 전달한다.

Spring MVC란?
Spring MVC란 프론트 컨트롤러 패턴에 기초한 웹 MVC 프레임워크이다. Spring 프레임워크의 하위 모듈이며, Model, View, Controller를 명확하게 분리하여 매우 유연하고 확장성이 좋다는 특징이 있다.

프론트 컨트롤러 패턴이란?
프론트 컨트롤러 패턴은 모든 요청을 프론트 컨트롤러(하나의 서블릿)에게 보내고, 프론트 컨트롤러는 각 요청에 맞는 컨트롤러를 찾아서 호출하는 역할을 한다. 그래서 공통 기능은 프론트 컨트롤러에서 처리하고, 서로 다른 코드들만 각 컨트롤러에서 처리하도록 할 수 있다. 

DispatcherServlet이란?
DispatcherServlet은 표현 계층 전면에서 HTTP 프로토콜을 통해 들어오는 모든 요청을 중앙 집중식으로 처리하는 프론트 컨트롤러이다. DispatcherServlet은 Spring MVC의 핵심 요소 중 하나로, 클라이언트로부터 어떤 요청이 들어오면 서블릿 컨테이너가 요청을 받는다. 이후 공통 작업을 DipatcherServlet에 처리하고, 이외 작업은 적절한 세부 컨트롤러로 위임한다.

Spring MVC의 흐름을 DispatcherServlet 위주로 설명하라.
. DispatcherServlet으로 클라이언트의 웹 요청이 들어온다.
. 웹 요청을 Handler Mapping에 위임하여 해당 요청을 처리할 Handler(Controller)를 탐색한다.
. 찾은 Handler를 실행할 수 있는 HandlerAdapter를 탐색한다.
. 찾은 Handler Adapter를 사용해서 Handler의 메소드를 실행한다.
. Handler의 반환 값은 Model과 View이다.
. View 이름을 ViewResolver에게 전달하고, ViewResolver는 해당하는 View 객체를 전달한다.
. DispatcherServlet은 View에게 Model을 전달하고 화면 표시를 요청한다. 이때, Model이 null이면 View를 그대로 사용하고, 그렇지 않으면 View에 Model 데이터를 렌더링한다.
. 최종적으로 DispatcherServlet은 View 결과(HttpServletResponse)를 클라이언트에게 반환한다.

Controller 1개는 어떻게 수십 만 개의 요청을 처리하는가?
톰캣은 하나의 프로세스에서 동작하고, 내부적으로 스레드 풀을 만들어서 HTTP 요청이 오면 스레드 풀에서 스레드 하나를 가져온다. 따라서 여러 요청이 오면, 각각 스레드를 생성하여 하나의 컨트롤러에 요청을 한다. 그러면, 컨트롤러는 요청에 맞게 로직을 수행하여 적절한 데이터를 반환한다. 이때 컨트롤러가 Thread-Safe하게 설계되었고, 싱글톤 빈으로 생성되었다면 안전하게 1개의 Controller 객체만으로 다중 요청을 처리할 수 있다.

IoC 컨테이너란?
스프링 애플리케이션에서는 객체(빈)의 생성과 관계설정, 사용, 제거 등의 작업을 애플리케이션 코드 대신 스프링 컨테이너가 담당하는데, 이를 IoC 컨테이너라고 한다.

IoC 컨테이너의 장점은?
스프링 애플리케이션의 객체(빈)을 IoC 컨테이터가 관리해줌으로써 개발자의 부담이 줄고 비즈니스 로직에 더욱 집중할 수 있다는 장점이 있다.

DI란?
DI는 객체(빈)들 간의 의존관계를 외부에서 결정하고 주입하는 것이다.BurgerChef 클래스와 BurgerRecipe 인터페이스를 예시로 설명하자.

DI의 장점은?
• 의존성이 줄어든다.
• 의존한다는 것은 그 의존대상의 변화에 취약하다는 것이다.(대상이 변화하였을 때, 이에 맞게 수정해야함)
• DI로 구현하게 되었을 때, 주입받는 대상이 변하더라도 그 구현 자체를 수정할 일이 없거나 줄어들게된다.
• 재사용성이 높은 코드가 된다.
• 기존에 BurgerChef 내부에서만 사용되었던 BurgerRecipe을 별도로 구분하여 구현하면, 다른 클래스에서 재사용할 수가 있다.
• 테스트하기 좋은 코드가 된다.
• BurgerRecipe의 테스트를 BurgerChef 테스트와 분리하여 진행할 수 있다.
• 가독성이 높아진다.
• BurgerRecipe의 기능들을 별도로 분리하게 되어 자연스레 가동성이 높아진다.

DI의 종류는?
DI는 생성자 삽입, 수정자 삽입, 필드 주입이 있다.생성자 주입은 생성자 호출시점에 딱 1번만 호출되는 것을 보장하며 불변, 필수 의존관계에 사용한다.수정자 주입은 선택, 변경 가능성이 있는 의존관계에 사용되며 빈을 선택적으로 주입이 가능하다.필드 주입은 외부에서 변경이 불가능하여 테스트 하기 힘들다. DI 프레임워크 없이는 작동하기 힘들며, 주로 애플리케이션과 관계없는 테스트코드나 @Configuration 같은 스프링 설정 목적으로 사용한다.

순환 참조가 무엇이고 언제 발생하는가?
순환 참조란 서로 다른 여러 빈들이 서로를 참조하고 있음을 의미한다. 필드 주입이나 수정자 주입은 객체 생성 후 비즈니스 로직 상에서 순환 참조가 일어나기 때문에 컴파일 단계에서 순환 참조를 잡아낼 수 없다. 반면에 생성자 주입을 사용하면 스프링 컨테이너가 빈을 생성하는 시점에 순환 참조를 확인하기 때문에 컴파일 단계에서 순환 참조를 잡아낼 수 있다

생성자 주입을 사용해야 하는 이유는?
• 의존관계를 모두 주입하지 않은 경우에 객체를 생성할 수 없기 때문에 NPE가 발생하지 않는다.
• final 키워드를 사용할 수 있어 불변성을 보장할 수 있다.
• 생성자 주입은 컴파일 단계에서 순환 참조를 잡아 낼 수 있다.
• 의존성을 주입하기 번거롭고 생성자 인자가 많아지면 코드가 길어져 위기감을 느낄 수 있다. 이를 바탕으로 SRP 원칙을 생각하게 되고, 리팩토링을 하게 된다.
• DI 컨테이너 없이 직접 의존성을 주입할 수 있다.

Spring IoC/DI의 동작 과정은?
IoC(제어의 역전)은 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것으로 코드의 최종 호출은 개발자가 제어하는 것이 아닌 프레임워크의 내부에서 결정된 대로 이루어진다.DI(의존관계 주입)은 스프링 프레임워크에서 지원하는 IoC의 형태로 객체(빈) 사이의 의존관계를 빈 설정 정보를 바탕으로 DI 컨테이너가 자동으로 연결한다.

Autowiring 동작 과정은?
스프링 서버가 올라갈 때 애플리케이션 컨텍스트가 @Bean이나 @Service, @Controller 등 어노테이션을 이용하여 등록한 스프링 빈을 생성하고, @Autowired 어노테이션이 붙은 위치 또는 생성자, 수정자를 통해 주입한다.

DI와 IoC의 차이는?
DI는 의존관계를 어떻게 가질 것인가에 대한 문제고, IoC는 누가 소프트웨어의 제어권을 갖고 있느냐의 문제다. IoC 컨테이너가 빈을 생성할 때 빈들간의 의존관계를 DI를 통해 해결한다. DI는 IoC 사용을 필수로 요구하지 않는다는 점을 주의해야 한다.

필터란?
필터는 디스패처 서블릿에 요청이 전달되기 전/후에 url 패턴에 맞는 모든 요청에 대해 부가 작업을 처리할 수 있는 기능을 제공하며 서블릿 컨테이너 단에서 동작한다.

필터의 사용 시기는?
필터에서는 스프링과 무관하게 전역적으로 처리해야 하는 작업들을 처리할 수 있다. 혹은, 요청 파라미터를 중심으로 검증할 때 사용된다.대표적으로 보안 관련 공통 작업, 모든 요청에 대한 로깅, 이미지/데이터 압축 및 문자열 인코딩, ServletRequest 커스터마이징 작업을 처리한다. 

인터셉터란?
인터셉터는 디스패처 서블릿이 컨트롤러를 호출하기 전과 후에 요청과 응답을 참조하거나 가공할 수 있는 기능을 제공하며, 즉, 스프링 컨테이너 단에서 동작한다.

인터셉터의 사용 시기는?
인터셉터는 클라이언트의 요청과 관련되어 전역적으로 처리해야 하는 작업들을 처리할 수 있고, 검증 시 서비스 로직을 호출할 때 주로 사용된다.대표적으로 인증/인가 등과 같은 공통 작업, API 호출에 대한 로깅, Controller로 넘겨주는 데이터 가공 작업을 처리한다.

필터와 인터셉터의 차이는?
필터는 서블릿 컨테이너 단에서 실행되고 인터셉터는 스프링 컨테이너 단에서 실행된다.필터는 디스패처 서블릿의 전후를 다룰 수 있고, 인터셉터는 컨트롤러의 전후를 다룰 수 있다. 따라서, 필터는 스프링과 무관하게 전역적으로 처리해야 하는 작업을 하는 것이 좋고, 인터셉터는 클라이언트의 요청과 관련되어 전역적으로 처리해야 하는 작업을 하는 것이 좋다.

Argument Resolver란?
ArgumentResolver는 어떠한 요청이 컨트롤러에 들어왔을 때, 요청에 들어온 값으로부터 원하는 객체를 만들어내는 일을 간접적으로 해준다.

Argument Resolver의 사용 시기는?
JWT 토큰과 함께 요청이 들어왔을 때, 유효한 토큰인지 검증을 거친 후에 토큰에 저장된 id를 꺼내 LoginMember라는 객체로 만들어내는 작업을 할 때 사용할 수 있다.

인터셉터와 Argument Resolver의 차이는?
ArgumentResolver는 어떠한 요청이 컨트롤러에 들어왔을 때, 요청에 들어온 값으로부터 원하는 객체를 반환한다. 반면에 인터셉터는 위 처럼 객체를 반환할 할 수가 없으며, 인터셉터가 실행된 후에 Argument Resolver가 실행된다.

AOP란?
AOP는 Aspect Oriented Programming의 약자로 관점 지향 프로그래밍을 뜻한다. 관점 지향은 어떤 로직을 기준으로 핵심적인 관점, 부가적인 관점으로 나누고, 그 관점을 기준으로 각각 모듈화하겠다는 의미이다. 여기서 모듈화란 어떤 공통된 로직이나 기능을 하나의 단위로 묶는 것을 말한다. 예를 들어, 핵심적인 관점은 비즈니스 로직이 되며, 부가적인 관점은 실행 시간 측정, 트랜잭션, 로깅 등이 될 수 있다.

AOP의 장점은?
각 클래스에서 로깅, 트랜잭션과 같은 반복되는 기능이 생길 수 있는데, 이것을 흩어진 관심사라고 부르며, 이렇게 흩어진 관심사를 Aspect로 모듈화하고 핵심적인 비즈니스 로직에서 분리하면 재사용할 수 있고 OOP를 더욱 잘 구현할 수 있다.

프록시 패턴과 특징을 설명하라.
프록시 패턴은 실제 기능을 수행하는 객체 대신 가상의 객체를 사용하여 로직의 흐름을 제어하는 디자인 패턴이다. 
• 특징
• 원래 하려던 기능을 수행하며 그 외의 부가적인 작업(로깅, 인증, 트랜잭션 등)을 별도로 수행할 수 있다.
• 비용이 많이 드는 연산(DB 쿼리, 대용량 텍스트 파일 등)을 실제로 필요한 시점까지 미룰 수 있다.

Spring AOP 동작 원리를 설명하라.
프록시는 타겟을 감싸서 타겟의 요청을 대신 받아주는 Wrapping 오브젝트이다. 클라이언트에서 타겟을 호출하게 되면 타겟이 아닌, 타겟을 감싸고 있는 프록시가 호출된다. 이때 프록시는 타겟 메소드 실행 전후로 부가 기능을 실행하도록 구성되어 있다.다만, 프록시 패턴은 타겟 하나 하나마다 프록시 객체를 정의해야하므로 번거롭고 코드의 중복이 생긴다는 점이 있다. 그래서 Spring AOP에서는 런타임 시에 JDK Dynamic Proxy 또는 CGLIB를 활용하여 프록시를 생성해 준다. 

JDK Dynamic Proxy란?
JDK Dynamic Proxy는 Java의 리플렉션 패키지에 존재하는 Proxy라는 클래스를 통해 생성된 프록시 객체를 의미한다. 리플렉션의 Proxy 클래스가 동적으로 프록시 객체를 생성해 주므로 JDK Dynamic Proxy라는 이름이 붙여졌다.

JDK Dynamic Proxy의 동작 과정을 설명하라.
. 타겟의 인터페이스에 대해 자체적인 검증 로직을 거치고, ProxyFactory에 의해 타겟의 인터페이스를 상속한 프록시 객체를 생성한다.
. 프록시 객체에 InvocationHandler를 포함하여 하나의 객체로 변환한다.

JDK Dynamic Proxy의 장단점을 설명하라.
장점
•  개발자가 직접 프록시 객체를 만들 필요가 없다.
단점
•  프록시하려는 클래스는 반드시 인터페이스의 구현체여야한다.
•  리플렉션을 활용하므로 성능이 떨어진다.

CGLIB란?
CGLIB는 Code Generator Libray의 약자로, 클래스의 바이트 코드를 조작하여 프록시 객체를 생성해 주는 라이브러리다. CGLIB를 사용하면 인터페이스가 아닌 타겟 클래스에 대해서도 프록시 객체를 만들어 줄 수 있고, 이 과정에서 Enhancer라는 클래스를 활용한다.

CGLIB의 동작 과정을 설명하라.
CGLIB는 타겟 클래스의 상속을 받아서 프록시를 생성한다. 이때 타겟 클래스에 포함된 모든 메소드를 재정의하고, 타겟 클래스에 대한 바이트 코드를 조작하여 프록시를 생성한다.

CGLIB의 장단점을 설명하라.
장점
• 인터페이스 없이 단순 클래스만으로도 프록시 객체를 동적으로 생성해 줄 수 있다.
• 리플렉션이 아닌 바이트 조작을 사용하며, 타겟에 대한 정보를 알고 있기 때문에 JDK Dynamic Proxy에 비해 성능이 좋다.
단점
• 의존성을 추가해야 한다. (Spring 3.2 이후 버전의 경우 Spring Core 패키지에 포함되어 있음)
• default 생성자가 필요하다. (현재는 objenesis 라이브러리를 통해 해결)
• 타겟의 생성자가 두 번 호출된다. (현재는 objenesis 라이브러리를 통해 해결)

Spring AOP를 사용할 때 주의할 점이 있는가?
• 타겟 클래스의 자기 호출(inner method invoke)은 AOP가 동작하지 않는다.
• 클라이언트는 프록시를 타겟 클래스라고 생각하고, 프록시 메소드를 호출하게 된다.
• 프록시는 클라이언트로부터 요청을 받으면 타겟 클래스의 메소드로 위임하고, 경우에 따라 부가 작업을 추가한다.
• 즉 프록시는 클라이언트가 타겟 클래스를 호출하는 과정에만 동작한다.
• 타겟 클래스가 자기 자신의 메소드를 호출할 때는 AOP가 적용되지 않고 대상 객체를 직접 호출하게 된다.
• 프록시를 만들 때, Default로 CGLIB 라이브러리를 사용하여 클래스를 상속하므로 private 메소드에서 AOP가 동작하지 않는다.
• 마찬가지로 final 메소드나 final 클래스에도 AOP가 적용되지 않는다.

선언전 트랜잭션 방식을 사용하는 이유는?
비즈니스 로직이 트랜잭션 처리를 필요로 할 때, 트랜잭션 처리 코드와 비즈니스 로직이 공존한다면 코드 중복이 발생하고 비즈니스 로직에 집중하기 어렵다. 따라서 트랜잭션 처리와 비즈니스 로직을 분리할 수 있는 선언적 트랜잭션 방식을 자주 사용한다.

@Transactional의 동작 원리는?
@Transactional을 메소드 또는 클래스에 명시하면 AOP를 통해 Target이 상속하고 있는 인터페이스 또는 Target 객체를 상속한 Proxy 객체가 생성되며, Proxy 객체의 메소드를 호출하면 Target 메소드 전 후로 트랜잭션 처리를 수행한다.

@Transactional을 사용할 때 주의할 점은?
• Proxy 객체의 Target Method가 내부 메소드를 호출하면 실제 메소드가 호출되기 때문에 Inner Method에서 @Transactional 어노테이션이 적용되지 않는 것을 주의해야 한다.
• @Transactional 어노테이션을 붙이면 트랜잭션 처리를 위해 Proxy 객체를 생성하는데, Proxy는 Target Class를 상속하여 생성된다. 따라서 상속이 불가능한 Private 메소드의 경우 @Transactional 어노테이션을 적용할 수 없다는 것을 주의해야 한다.

@Transactional를 스프링 Bean의 메소드 A에 적용하였고, 해당 Bean의 메소드 B가 호출되었을 때, B 메소드 내부에서 A 메소드를 호출하면 어떤 요청 흐름이 발생하는지 설명하라.
프록시는 클라이언트가 타겟 객체를 호출하는 과정에만 동작하며, 타겟 객체의 메소드가 자기 자신의 다른 메소드를 호출할 때는 프록시가 동작하지 않는다. 즉 A 메소드는 프록시로 감싸진 메소드가 아니므로 트랜잭션이 적용되지 않는 일반 코드가 수행된다.

A라는 Service 객체의 메소드가 존재하고, 그 메소드 내부에서 로컬 트랜잭션 3개(다른 Service 객체의 트랜잭션 메소드를 호출했다는 의미)가 존재한다고 할 때, @Transactional을 A 메소드에 적용하면 어떤 요청 흐름이 발생하는지 설명하라.
트랜잭션 전파 수준에 따라 달라진다. 만약 기본 옵션인 REQUIRED를 가져간다면 로컬 트랜잭션 3개가 모두 부모 트랜잭션인 A에 합류하여 수행된다. 그래서 부모 트랜잭션이나 로컬 트랜잭션 3개나 모두 같은 트랜잭션이므로 어느 하나의 로직에서든 문제가 발생하면 전부 롤백이 된다.

CORS란?
CORS는 Cross-Origin Resource Sharing 의 줄임말로, 교차 출처 리소스 공유를 의미하며, 교차 출차는 ‘다른 출처’라고 생각하면 된다.

SOP란?
SOP는 Same-Origin Policy의 줄임말로, 단어 뜻 그대로 같은 출처만 허용한다는 정책을 의미한다. 과거에는 보안을 위해 엄격하게 같은 출처만 통신하도록 허용하였으나, 최근에는 다른 출처에 있는 리소스를 가져와서 사용하는 일이 아주 흔하므로 SOP의 예외 조항인 CORS 정책을 두게 되었다.

같은 출처인 것을 어떻게 판단하는가?
URL은 Protocol, Host, Path, Query String, Fragment로 이루어져 있는데, 해당 구성 요소 중 출처(Origin)는 Protocol과 Host, 그리고 :80 , :443 같은 포트 번호까지 모두 합친 것을 의미한다. 즉, Protocol, Host, Port 번호가 같으면 같은 출처이다.

CORS의 동작 과정을 설명하라.
기본적으로 웹 클라이언트 애플리케이션이 다른 출처의 리소스를 요청할 때는 HTTP 프로토콜을 사용하여 요청을 보내게 되고, 이때 브라우저는 요청 헤더에 Origin 이라는 필드에 요청을 보내는 출처를 함께 담는다. Origin: https://google.com 과 같이 출처를 담아서 서버로 보내면, 서버는 응답 헤더의 Access-Control-Allow-Origin이라는 값에 이 리소스를 접근하는 것이 허용된 출처 목록을 담아준다. 이후 응답을 받은 브라우저는 자신이 보냈던 요청의 Origin과 서버가 보내준 응답의 Access-Control-Allow-Origin을 비교한다. 만약 허용되지 않는 Origin이면 CORS 정책 위반 이슈가 발생한다. 

Preflight Request에 대해 설명하라.
Preflight Request 방식은 일반적으로 사용하는 방식으로, 브라우저는 요청을 한 번에 보내지 않고 예비 요청과 본 요청으로 나누어서 서버로 전송한다. 이때 예비 요청은 OPTIONS 메소드를 사용하여 본 요청을 보내기 전에, 브라우저 스스로 이 요청이 안전한지 확인하는 역할을 한다. 동작 과정은 다음과 같다. . JavaScript의 fetch() API를 사용하여 브라우저에게 서버의 리소스를 받아오라는 명령을 내린다.
. 브라우저는 서버에게 예비 요청을 보낸다.
. 예비 요청의 응답으로 Access-Control-Allow-Origin의 값을 확인하여, 허용하는 출처를 조회한다.
. 브라우저 요청의 출처가 허용되지 않는다면, CORS 정책 위반 이슈가 발생한다. (이때 응답의 상태 코드는 200번이 온다.)
. 예비 요청의 응답이 성공하지 못하면, CORS 정책 위반 이슈가 발생한다.
. 예비 요청이 성공하면, 실제 본 요청을 보내서 서버의 리소스를 받아 온다.

Simple Request에 대해 설명하라.
Simple Request는 예비 요청을 보내지 않고 서버에게 바로 본 요청을 보낸 후, 응답 헤더의 Access-Control-Allow-Origin 값을 확인하여 CORS 정책 위반 여부를 확인한다. 다만, 아무 때나 Simple Request를 사용할 수 있는 것은 아니고 특정 조건을 만족해야 한다. 조건은 다음과 같다. 1. 요청의 메소드는 GET, HEAD, POST 중 하나여야 한다. 2. Accept, Accept-Language, Content-Language, Content-Type, DPR, Downlink, Save-Data, Viewport-Width, Width를 제외한 헤더를 사용하면 안 된다. 3. 만약 Content-Type를 사용하는 경우에는 application/x-www-form-urlencoded, multipart/form-data, text/plain만 허용된다.

조건만 봐도 일반적인 웹 애플리케이션의 경우 지키기 어려워서 거의 사용되지 않는다. Spring에서 CORS 이슈를 해결하는 방법을 설명하라.
@CrossOrigin 어노테이션을 CORS 정책을 적용할 대상에 적용하거나, WebMvcConfigurer를 상속한 Config 클래스를 만들어서 CORS 정책을 설정하거나, RestTemplate을 이용한 프록시 서버를 구현하면 된다.

영속성 컨텍스트란?
영속성 컨텍스트는 엔티티를 영구 저장하는 환경이다. 엔티티 매니저를 통해서 영속성 컨텍스트에 접근할 수 있고, 영속성 컨텍스트를 관리할 수 있다.

영속성 컨텍스트의 특징을 아는 대로 설명해 보시오.
• 영속성 컨텍스트와 식별자 값
• 영속성 컨텍스트는 엔티티를 식별자 값 (ex. ID)로 구분하므로 영속 상태는 식별자가 필요하다.
• 영속성 컨텍스트와 데이터베이스 저장
• JPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영한다. (flush)
• 영속성 컨텍스트로 엔티티를 관리했을 때 장점
• 1차 캐시
• 동일성 보장
• 트랜잭션을 지원하는 쓰기 지연
• 변경 감지
• 지연 로딩

트랜잭션을 지원하는 쓰기 지연의 장점이 무엇인가?
트랜잭션을 지원하는 쓰기 지연의 가장 큰 장점은 데이터베이스에 lock이 걸리는 시간을 최소화한다는 것이다. 이 기능은 트랜잭션을 커밋해서 영속성 컨텍스트를 플러시하기 전까지는 데이터베이스에 데이터를 등록, 수정, 삭제 하지 않는다. 따라서 커밋 전까지 데이터베이스에 lock을 걸지 않는다. 이는 동시에 더 많은 트랜잭션을 처리하게 도와준다. 

JPA는 엔티티를 어떻게 수정하는가?
JPA는 변경 감지 기능을 제공한다. 엔티티를 수정하는 Flow는 다음과 같다. . 트랜잭션을 커밋하면 엔티티 매니저 내부에서 플러시가 호출된다.
. 엔티티와 스냅샷을 비교해서 변경된 엔티티를 찾는다.
. 변경된 엔티티가 있으면 수정 쿼리를 생성해서 쓰기 지연 SQL 저장소에 보낸다.
. 쓰기 지연 저장소의 SQL을 데이터베이스에 보낸다.
. 데이터베이스 트랜잭션을 커밋한다.

N + 1 문제는 무엇이고 이것이 발생하는 이유와 이를 해결하는 방법을 설명
N + 1 쿼리 문제는 즉시 로딩과 지연 로딩 전략 각각의 상황에서 발생할 수 있습니다. 하위 엔티티들이 존재하는 경우 한 쿼리에서 모두 가져오는 것이 아닌, 필요한 곳에서 각각 쿼리가 발생하는 경우를 이릅니다.즉시 로딩에서 발생하는 이유는 JPQL을 사용하는 경우 전체 조회를 했을 때, 영속성 컨텍스트가 아닌 데이터베이스에서 직접 데이터를 조회한 다음 즉시로딩 전략이 동작하기 때문입니다.
지연 로딩에서 발생하는 이유는 지연로딩 전략을 사용한 하위 엔티티를 로드할 때, JPA에서 프록시 엔티티를 unproxy 할 때 해당 엔티티를 조회하기 위한 추가적인 쿼리가 실행되어 발생합니다.해결 방법으로는 Fetch Join이라고 불리는 JPQL의 join fetch를 사용하는 방법이 있으며, 또 다른 방법으로는 @EntityGraph를 사용하는 방법, @Fetch(FetchMode.SUBSELECT)를 사용하는 방법, @BatchSize를 사용해 조절하거나 전역적인 batch-size를 설정하는 방법이 있습니다.

JWT란, 
보통 로그인 방식으로는 세션과 쿠기를 통해 구현한다.
세션에 저장된 정보는 고유 세션ID가 부여되는데 사용자가 로그인을 하면 서버는 쿠키에 세션ID를 실어서 보낸다. 브라우저는 쿠키를 쿠키저장소에 갖고 있다가 다음 페이지를 요청할 때 해당 유저의 쿠키를 다시 요청헤더에 포함해서 전송한다. 서버는 쿠키 내부의 세션ID를 통해 세션 내부에 일치하는 유저 정보를 가져와서 처음에 로그인한 유저가 맞는지 확인하는 작업이 반복되면서 로그인 상태가 유지된다.
세션은 서버의 메모리 내부에 저장되기 때문에 많아지는 만큼 메모리에 부하가 걸리게 되고, 확장 시 세션을 분산시키는 기술을 따로 설계해야 한다.
JWT는 토큰을 만들어 발행하는 방식 으로 쿠키에 담거나 HTTP 헤더에 담아서 보낼 수 있다. 따로 서버에서 저장하지 않기 때문에 토큰이 유효한지 검증하는 과정만 있으면 된다.
하지만 탈취에 의해 악의적으로 사용될 가능성이 있기에 보통 유효시간을 짧게 가져가고 Refresh 토큰을 사용하는 방식으로 구현한다.
쿠키는 웹브라우저에서 사용할 수 있는 기능이므로 모바일 애플리케이션에서는 JWT를 사용한 인증방식이 최적이다.

OOP(객체 지향 프로그래밍) 특징
객체 지향 프로그래밍이란 프로그램 구현에 필요한 객체를 파악하고 객체들 간의 상호작용을 통해 프로그램을 만드는 것 을 말한다.•  캡슐화
o  정보 은닉 : 필요 없는 정보는 외부에서 접근하지 못하도록 제한
o  높은 응집도, 낮은 결합도로 유연함과 유지보수성 증가
•  추상화
o  사물들의 공통적인 특징을 파악해서 하나의 개념(집합)으로 다루는 것
o  목적과 관련이 없는 부분을 제거하여 필요한 부분만을 표현하기 위한 개념
•  상속
o  기존 상위클래스에 근거하여 새롭게 클래스와 행위를 정의할 수 있게 도와주는 개념
•  다형성
o  형태가 같은데 다른 기능을 하는 것을 의미
o  오버라이딩, 오버로딩

OOP(객체 지향 프로그래밍) SOLID 원칙
S : 단일 책임 원칙(Single Responsible Principle)
o  객체는 단 하나의 책임만을 가져야한다.
o  어떤 변화에 의해 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.
O : 개방 폐쇄 원칙(Open Closed Principle)
o  기존 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계되어야 한다.
L : 리스코프 치환 원칙
o  자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야한다.
I : 인터페이스 분리 원칙
o  특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
o  인터페이스가 명확해지고, 대체 가능성이 높아진다.
D : 의존관계 역전 원칙 (Dependency Inversion Principle)
o  의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운 것, 거의 변화가 없는 것에 의존하라는 것이다.
o  쉽게 이야기하면, 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻

DDD 구조
• DDD란 비즈니스 도메인 별로 나눠서 설계하는 방식으로 여러 도메인들이 서로 상호작용하도록 도메인을 중심으로 설계하는 것을 말한다.
• DDD의 핵심 목표는 모듈간의 의존성을 최소화하고 응집성은 최대화하는 것이다.
• Presentation, application, domain, infrastructure 계층으로 구분되어 있다.
o presentation -> application -> domain -> infrastructure
o 하위 계층으로만 의존함으로서 구조가 복잡하여 발생할 수 있는 순환참조를 막을 수 있다.
o 단방향으로 구성되어있기에 각 계층별 로직을 쉽게 이해할 수 있다.
o infrastructure는 domain의 추상화를 구현하는 계층으로 DIP의 활용을 극대화할 수 있다.

싱글톤 패턴에 대해서 설명
전역 변수를 사용하지 않고 객체를 하나만 생성하도록 하며, 생성된 객체를 어디에서든지 참조할 수 있도록 하는 패턴입니다.하나의 인스턴스만을 생성하며 getInstance메서드로 모든 클라이언트에게 동일한 인스턴스를 반환합니다.private 생성자를 가지는 특징을 가지며, 생성된 싱글톤 오브젝트는 저장할 수 있는 자신과 같은 타입의 스태틱 필드를 정의합니다.싱글톤 패턴의 문제점은 다음과 같습니다.•  의존 관계상 클라이언트가 구체 클래스에 의존합니다.
• private 생성자 때문에 테스트가 어렵습니다.
• 객체 인스턴스를 하나만 생성해서 공유하는 방식 때문에 싱글톤 객체를 stateful하게 설계 했을 경우 큰 장애 발생요인이 됩니다.
싱글톤의 단점을 해결하기 위해 무상태(stateless)로 설계해야 합니다.•  특정 클라이언트에 의존적인 필드가 있으면 안됩니다.
• 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안됩니다.
• 가급적 읽기 전용으로 만들고, 필드 대신에 자바에서 공유되지 않는 지역변수, 파라미터, ThreadLocal 등을 사용합니다.

가교 패턴(브릿지 패턴)에 대해서 설명
가교 패턴은 추상부와 구현부를 분리하는 디자인 패턴입니다. 해당 패턴에서 기능은 인터페이스를 통해 정의 및 이용되고 해당 인터페이스를 따르는 클래스를 통해 구현됩니다. 해당 패턴을 통해서 사용자는 추상부와 구현부를 독립적으로 수정 및 확장할 수 있습니다. 가교 패턴은 객체지향 설계의 SOLID 원칙 중 단일 책임 원칙(SRP)과 개방 폐쇄 원칙(OCP)에 부합한 패턴입니다.

전략 패턴에 대해서 설명
전략 패턴은 알고리즘을 객체 단위로 캡슐화하는 디자인 패턴입니다. 해당 패턴에서 알고리즘은 인터페이스를 통해 정의 및 이용되고 해당 인터페이스를 따르는 클래스를 통해 구현됩니다. 해당 패턴을 통해서 사용자는 알고리즘을 필요에 따라 바꿔서 사용할 수 있게 됩니다. 전략 패턴은 객체지향 설계의 SOLID 원칙 중 개방 폐쇄 원칙(OCP)에 부합한 패턴입니다.전략 패턴은 가교 패턴과 구조가 비슷하지만 목적에 차이가 있습니다. 가교 패턴이 추상과 구현의 분리를 통한 독립적 개발의 용이성에 중점을 둔다면 전략 패턴은 알고리즘의 캡슐화를 통한 알고리즘 변경의 유연성에 중점을 둡니다.

퍼사드 패턴에 대한 예를 들어주세요.
바운디드 컨텍스트로 구분된 각각의 독립적인 애플리케이션을 UI 서버를 통해 파사드 역할을 담당하도록 두고 각 바운디드 컨텍스트에서 UI 서버와 통신하기 위해 HTTP, Protobuf, Thrift와 같은 방식을 이용할 수 있습니다.
